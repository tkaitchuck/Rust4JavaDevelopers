<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Generics - Rust for Java developers</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guide to learning Rust for developers familiar with Java">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="why_rust.html"><strong aria-hidden="true">1.</strong> Why Rust</a></li><li class="expanded "><a href="history_of_rust.html"><strong aria-hidden="true">2.</strong> History of Rust</a></li><li class="expanded "><a href="rust_community.html"><strong aria-hidden="true">3.</strong> The Rust Community</a></li><li class="expanded "><a href="variable_declaration.html"><strong aria-hidden="true">4.</strong> Variable declaration</a></li><li class="expanded "><a href="method_signatures.html"><strong aria-hidden="true">5.</strong> Method Signatures</a></li><li class="expanded "><a href="flowcontrol.html"><strong aria-hidden="true">6.</strong> Flowcontrol</a></li><li class="expanded "><a href="ownership.html"><strong aria-hidden="true">7.</strong> Ownership</a></li><li class="expanded "><a href="objects.html"><strong aria-hidden="true">8.</strong> Objects and Traits</a></li><li class="expanded "><a href="generics.html" class="active"><strong aria-hidden="true">9.</strong> Generics</a></li><li class="expanded "><a href="collections.html"><strong aria-hidden="true">10.</strong> Collections</a></li><li class="expanded "><a href="enums.html"><strong aria-hidden="true">11.</strong> Enums, tuples, and aliases</a></li><li class="expanded "><a href="modules.html"><strong aria-hidden="true">12.</strong> Modules</a></li><li class="expanded "><a href="cargo.html"><strong aria-hidden="true">13.</strong> Cargo</a></li><li class="expanded "><a href="equivalent_frameworks.html"><strong aria-hidden="true">14.</strong> Equivalent frameworks</a></li><li class="expanded "><a href="error_handling.html"><strong aria-hidden="true">15.</strong> Error handling</a></li><li class="expanded "><a href="rust_makes_you_better_at_java.html"><strong aria-hidden="true">16.</strong> How Rust makes you a better Java programmer</a></li><li class="expanded "><a href="concurrency.html"><strong aria-hidden="true">17.</strong> Concurrency</a></li><li class="expanded "><a href="testing.html"><strong aria-hidden="true">18.</strong> Testing</a></li><li class="expanded "><a href="debugging.html"><strong aria-hidden="true">19.</strong> Debugging</a></li><li class="expanded "><a href="operator_overloading.html"><strong aria-hidden="true">20.</strong> Operator Overloading</a></li><li class="expanded "><a href="lifetimes.html"><strong aria-hidden="true">21.</strong> Lifetimes</a></li><li class="expanded "><a href="cool_rust_tricks.html"><strong aria-hidden="true">22.</strong> Cool Rust Tricks</a></li><li class="expanded "><a href="writing_macros.html"><strong aria-hidden="true">23.</strong> Writing Mactos</a></li><li class="expanded "><a href="command_line_programs.html"><strong aria-hidden="true">24.</strong> Command line programs</a></li><li class="expanded "><a href="example_program.html"><strong aria-hidden="true">25.</strong> Example program</a></li><li class="expanded "><a href="webasm.html"><strong aria-hidden="true">26.</strong> Webasm</a></li><li class="expanded "><a href="rust_with_java.html"><strong aria-hidden="true">27.</strong> Using Rust with Java</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust for Java developers</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#generics-aka-type-parameters" id="generics-aka-type-parameters">Generics (aka Type parameters)</a></h1>
<p>Non-trivial example to show assignment + use</p>
<ul>
<li>Strongly Prefer associated types on traits
<ul>
<li>Better declaration syntax with multiple values</li>
<li>Real name for type</li>
<li>Named when used so more clear what is what vs order</li>
<li>No call site turbofish</li>
<li>Allows certain patterns, like continuation token. (Doesn't go up the stack)</li>
<li>Makes faster code (one impl, static dispatch)</li>
<li>It avoids “generics hell”</li>
<li>If you are the one implementing the trait, you can add new types without breaking users</li>
<li>Can also have default.</li>
<li>Does not work for things like Add where you want many impls depending on both Lhs and rhs</li>
<li>Only case for normal generic is for overloading</li>
</ul>
</li>
<li>Conditional trait implementation</li>
<li>Traits with methods contingent of a generic implementing a specific trait.
<ul>
<li>IE: cell has take if T is default or get if T is copy. Or a wrapper implements order if the thing it wraps does.</li>
</ul>
</li>
<li>Syntax for ‘where’ vs ‘:’ (also ‘+’)</li>
<li>Generics + Builders</li>
<li>Self type 
<ul>
<li>Can return an newly created instance of a generic type. (collect on iterator)</li>
</ul>
</li>
<li>Generics and dyn</li>
<li>static vs dynamic dispatch
<ul>
<li>Dyn keyword</li>
</ul>
</li>
</ul>
<p>Rust generics look a lot like Javas. When declared on a type:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::marker::PhantomData;
</span>pub struct LinkedList&lt;T&gt; {
  //...
<span class="boring">not_implemented : PhantomData&lt;T&gt;,
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>When instantiated:</p>
<pre><code class="language-rust ignore">let connection : HashMap&lt;String, TcpStream&gt; = //...
</code></pre>
<p>When in a function signature:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
pub fn lookup_emojis(characters : Vec&lt;&amp;str&gt;) -&gt; HashMap&lt;&amp;str, &amp;str&gt; {
  //...
<span class="boring">HashMap::new()
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>The biggest difference is that Rust calls them &quot;Type Parameters&quot;. <a href="https://bluejekyll.github.io/blog/rust/2017/08/06/type-parameters.html">Just as a function may take various parameters, it can
also take a parameter which is a type.</a></p>
<p>Below are some additional examples:
TODO:</p>
<ul>
<li>Functions</li>
<li>In structs</li>
<li>In traits</li>
<li>Defaults</li>
<li>Associated types - FromStr provides a good example. </li>
</ul>
<h2><a class="header" href="#type-inference" id="type-inference">Type Inference</a></h2>
<p>Rust also has some shortcuts to make things easier. For example a type can be declared like this:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn get_items() -&gt; Vec&lt;String&gt; {
  vec![&quot;Hello&quot;.to_string()] 
}
let to_print : Vec&lt;_&gt; = get_items();
<span class="boring">}
</span></code></pre></pre>
<p>Here the character ‘_’ tells the compiler “You figure out what's supposed to go here, I'm not going to bother to type it.”. This allows you to specify a type, while still allowing the generics to be infered. This works and can be used any place where the compiler has enough content to work out the generic value.</p>
<h2><a class="header" href="#bounds" id="bounds">Bounds</a></h2>
<p>In java you might write a function that looks like this:</p>
<pre><code class="language-java">public static void &lt;T extends Comparable&lt;T&gt;&gt; sort(List&lt;T&gt; toSort) {
  //...
}
</code></pre>
<p>Here the <code>entends</code> keyword is used to specify that the geric type <code>T</code> is must satisfy the &quot;bounds&quot; of Implementing <code>Comparable&lt;T&gt;</code>.
The same function in Rust would look like this:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn sort&lt;T : Ord&gt;(to_sort : &amp;mut Vec&lt;T&gt;) {
  //...
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>:</code> takes the place of &quot;extends&quot;. <code>Ord</code> is a trait that allows items to be ordered similar to <code>Comparable</code> in Java.</p>
<p>You may be wondering, &quot;Why doesn't Ord take a generic parameter?&quot;. After all <code>Comparable</code> in Java needs one because the interface is not specific to one implementation, and needs to refer to the same type. This is due to another feature, the &quot;Self&quot; type. </p>
<p>If you'll recall, when we define a method on an object we write:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Foo;
impl Foo {
  fn bar(&amp;self) {
    //...
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Where the 'self' variable is a way to pass the equivlent of &quot;this&quot; in Java. Well that's actually just shorthand for:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Foo;
impl Foo {
  fn bar(self : &amp;Self) {
    //...
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Where <code>Self</code> is the type of the object. This isn't useful on an impl because you know the type, but on an interface it can be. For example you can define something like this:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Doubleable {
  fn double(self) -&gt; Self;
}
impl Doubleable for i32 {
  fn double(self) -&gt; Self {
    self * 2
  }
}
//then this method can be invoked
assert_eq!(4, 2.double());
<span class="boring">}
</span></code></pre></pre>
<p>So the <code>Self</code> type allows the trait to refer to whatever is implementing the interface without actually knowing what that is or having to have a generic itself.</p>
<h2><a class="header" href="#features-unique-to-rust" id="features-unique-to-rust">Features unique to Rust</a></h2>
<p>Rust also has a few other features that help avoid so called &quot;generics hell&quot; that sometimes crops up in Java. </p>
<ul>
<li>Rust avoids generics hell
<ul>
<li>Ownership and borrowing save the day</li>
<li>https://doc.rust-lang.org/nomicon/subtyping.html </li>
</ul>
</li>
</ul>
<h3><a class="header" href="#where-clauses" id="where-clauses">Where clauses</a></h3>
<p>A simple one is &quot;where&quot; clauses. Suppose you had an interface like this:</p>
<pre><code class="language-java">public &lt;T extends Comparable&lt;T&gt;, ProcT extends Serializable, Processor&lt;T&gt;&gt; byte[] serializeMaximumValue(List&lt;T&gt;, ProcT processor);
</code></pre>
<p>You could just do the same thing in Rust:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">//Normally Serialize is imported as: use serde::Serialize;
</span><span class="boring">pub trait Serialize {}
</span>pub fn serialize_max_value&lt;T : Ord, ProcT : Proc&lt;T&gt; + Serialize&gt;(items : Vec&lt;T&gt;, processor : ProcT) -&gt; Vec&lt;u8&gt; {
  //...
<span class="boring">vec![]
</span>}
<span class="boring">pub trait Proc&lt;T&gt; {
</span><span class="boring"> fn do_something(item : T);
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>The problem with this in both Rust and java is the generics really get in the way and make the function signature hard to read. So it's easier to use the <code>where</code> keyword to move these bounds over to the right, so they can be wrapped onto the following lines:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">//Normally Serialize is imported as: use serde::Serialize;
</span><span class="boring">pub trait Serialize {}
</span>pub fn serialize_max_value&lt;T, ProcT&gt;(items : Vec&lt;T&gt;, processor : ProcT) -&gt; Vec&lt;u8&gt; where
 T : Ord,
 ProcT : Proc&lt;T&gt; + Serialize {
  //...
<span class="boring">vec![]
</span>}
<span class="boring">pub trait Proc&lt;T&gt; {
</span><span class="boring"> fn do_something(item : T);
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>This is strictly equivlent, but hopefully easier to read.</p>
<h3><a class="header" href="#impl-keyword" id="impl-keyword">Impl keyword</a></h3>
<p>In the case of a single trait/interface. In Java you might write __ where 'T extends’ is used to indicate there is some type T but the function doesn't care about the exact type of the object, provided it implements the specified interface. In Rust there is a shorthand for this using the 'impl’ keyword. __. This is most commonly used for return values for example __ specifies that this function is returning a _ but without providing the exact type. This is especially common when a function is returning a function. (Like a callback for example) __ here the function is specifying that it is returning a function with a particular signature but without specifying exactly which function it is returning. So you can think of impl as meaning “some implementation of this trait”. (It doesn't matter which) ‘impl’ only can refer to one trait. So if you need to use multiple, you'll have to use a where clause _ or an alias _.</p>
<p>Optimizer: I can actually make methods invoked on an ‘impl’ parameter a lot faster. So take advantage of that.</p>
<h3><a class="header" href="#associated-types" id="associated-types">Associated Types</a></h3>
<p>Finally there is one feature that cuts down on the burdon of generics a lot: &quot;Associated types&quot;. In Java the Supplier interface is defined as:</p>
<pre><code class="language-java">interface Supplier&lt;T&gt; {
  public T get();
}
</code></pre>
<p>To do the same thing in Rust, you could write:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Supplier&lt;T&gt; {
  fn get(&amp;self) -&gt; T;
}
<span class="boring">}
</span></code></pre></pre>
<p>Or you could instead write:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Supplier {
  type Item;
  fn get(&amp;self) -&gt; Self::Item;
}
<span class="boring">}
</span></code></pre></pre>
<p>Here <code>type</code> is a keyword, and <code>Item</code> is the name of the generic type rather than <code>T</code>.
This has a few advantages. First it allows the generics to be specified by name, rather than relying on order: </p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Supplier {
</span><span class="boring">type Item;
</span><span class="boring">fn get(&amp;self) -&gt; Self::Item;
</span><span class="boring">}
</span>struct StringWrapper(String);
impl Supplier for StringWrapper {
  type Item = String;

  fn get(&amp;self) -&gt; String {
    self.0.clone()
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>This can segnifigantly improve readability when there are multiple types. It also allows the type to be refered to without specifying the type. For example:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Countable {
    fn count(self) -&gt; i32;
}
impl&lt;T&gt; Countable for T where T:Iterator {
    fn count(self) -&gt; i32 {
        let mut count = 0;
        for value in self {
            count += 1;
        }
        count
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here <code>Iterator</code> is refered to without needing to specify the generic associated with Iterator. This means that Countable does not itself have to be generic even though it operates on things that are. In the above code, they type of <code>value</code> is <code>T::Item</code>. A similar example using the supplier interface defined above would look like:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Supplier {
  type Item;
  fn get(&amp;self) -&gt; Self::Item;
}
//...
fn vec_of_value&lt;S:Supplier&gt;(supplier : &amp;S) -&gt; Vec&lt;S::Item&gt; {
  vec![supplier.get()]
}
<span class="boring">}
</span></code></pre></pre>
<p>In general the major difference between associated types and generics, is that for an associated type each implementation is tied to a speffic type. (For the language geeks this is called &quot;unicity&quot;.) For example If you were to define a concrete class <code>LinkedList</code> it should use generics because any sort of item should be able to go into one. However when defining a more general trait for example <code>Iterator</code> in that case it should use an associated type, because each implementation of iterator is only going to have one perticular type associated with it. Usually this is the type of whatever collection is implementing it, which of course itself is likely a generic. For example:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Storage {
  type Item;
  //...
  fn insert(&amp;self, item: Self::Item);
}
struct Message {/*...*/}
struct MessageStore {
  //...
}
impl Storage for MessageStore {
    type Item = Message;
    fn insert(&amp;self, item: Message) {
      //...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we have a <code>MessageStore</code> is tied to the type <code>Message</code> so it uses an associated type.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="objects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="collections.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="objects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="collections.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
