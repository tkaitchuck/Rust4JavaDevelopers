<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust for Java developers</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guide to learning Rust for developers familiar with Java">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="why_rust.html"><strong aria-hidden="true">1.</strong> Why Rust</a></li><li class="expanded "><a href="history_of_rust.html"><strong aria-hidden="true">2.</strong> History of Rust</a></li><li class="expanded "><a href="rust_community.html"><strong aria-hidden="true">3.</strong> The Rust Community</a></li><li class="expanded "><a href="variable_declaration.html"><strong aria-hidden="true">4.</strong> Variable declaration</a></li><li class="expanded "><a href="method_signatures.html"><strong aria-hidden="true">5.</strong> Method Signatures</a></li><li class="expanded "><a href="flowcontrol.html"><strong aria-hidden="true">6.</strong> Flowcontrol</a></li><li class="expanded "><a href="ownership.html"><strong aria-hidden="true">7.</strong> Ownership</a></li><li class="expanded "><a href="objects.html"><strong aria-hidden="true">8.</strong> Objects and Traits</a></li><li class="expanded "><a href="generics.html"><strong aria-hidden="true">9.</strong> Generics</a></li><li class="expanded "><a href="collections.html"><strong aria-hidden="true">10.</strong> Collections</a></li><li class="expanded "><a href="enums.html"><strong aria-hidden="true">11.</strong> Enums, tuples, and aliases</a></li><li class="expanded "><a href="modules.html"><strong aria-hidden="true">12.</strong> Modules</a></li><li class="expanded "><a href="cargo.html"><strong aria-hidden="true">13.</strong> Cargo</a></li><li class="expanded "><a href="equivalent_frameworks.html"><strong aria-hidden="true">14.</strong> Equivalent frameworks</a></li><li class="expanded "><a href="error_handling.html"><strong aria-hidden="true">15.</strong> Error handling</a></li><li class="expanded "><a href="rust_makes_you_better_at_java.html"><strong aria-hidden="true">16.</strong> How Rust makes you a better Java programmer</a></li><li class="expanded "><a href="concurrency.html"><strong aria-hidden="true">17.</strong> Concurrency</a></li><li class="expanded "><a href="testing.html"><strong aria-hidden="true">18.</strong> Testing</a></li><li class="expanded "><a href="debugging.html"><strong aria-hidden="true">19.</strong> Debugging</a></li><li class="expanded "><a href="operator_overloading.html"><strong aria-hidden="true">20.</strong> Operator Overloading</a></li><li class="expanded "><a href="lifetimes.html"><strong aria-hidden="true">21.</strong> Lifetimes</a></li><li class="expanded "><a href="cool_rust_tricks.html"><strong aria-hidden="true">22.</strong> Cool Rust Tricks</a></li><li class="expanded "><a href="writing_macros.html"><strong aria-hidden="true">23.</strong> Writing Mactos</a></li><li class="expanded "><a href="command_line_programs.html"><strong aria-hidden="true">24.</strong> Command line programs</a></li><li class="expanded "><a href="example_program.html"><strong aria-hidden="true">25.</strong> Example program</a></li><li class="expanded "><a href="webasm.html"><strong aria-hidden="true">26.</strong> Webasm</a></li><li class="expanded "><a href="rust_with_java.html"><strong aria-hidden="true">27.</strong> Using Rust with Java</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust for Java developers</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#why-rust" id="why-rust">Why Rust</a></h1>
<p>Rust is designed to be a safe, productive, and performant general-purpose programming language.</p>
<p>In that space there is a lot of competition. New language since c has ever really taken over that space. C++, Python, Java, and C# have each, carved off a piece of that space. But none of them have ever really been able to be the best in all of the different niches.</p>
<p>To even carve off a portion of this space is quite a challenge because any new language has to be better than the best language out there for a given usecase. It can't be just a little bit better either. It has to be a lot better, because there are huge switching costs. Libraries need to be rewritten. People need to be retrained. To gain traction a new language needs to be a lot better.</p>
<p>Rust is a lot better.</p>
<p>Rust is still very young but it's starting to compete with other languages on their own terms. Some have argued that may soon be better for web development than Javascript. And in many ways it is already a better C++ than C++. But, as I will argue in this book: Rust is a better Java than Java.</p>
<p>I decided to write this book because a lot of the Rust documentation was written in a way that was geared towards people coming from C++. If you know about pointers, memory layout, and RIIA are second nature to you, then these explanations make sense. I wanted to go in a different direction describe Rust from the perspective of Java. As such, this book won’t mention any of those things, and will describe and define how Rust work from the perspective of a Java developer. This book is first and foremost targeted at developers who already know and have experience in Java and are looking to learn Rust. If this is not your situation you might still get a fair amount out of this book but it is not my goal. </p>
<p>Throughout, the book will provide side-by-side comparisons of Java and Rust code that is identical in functionality. Because the goal is to facilitate comparison between the languages sometimes the examples are not idiomatic Rust or idiomatic Java. Rather they are written to make the comparison clear and direct.</p>
<p>Throughout the book we’ll have running commentary from two characters:</p>
<table width="100%">
<tr>
<td> 
<p><img src="images/borrow.png" alt="Safety monitor" /></p>
</td>
<td width="80%">
<blockquote>
<p><em>“Hi, I make sure your program is correct, and won’t fail at runtime. A lot of people call me ‘the borrow checker’ because that’s a big part of my job. But I do more than that. I enforce style guidelines, memory safety, thread safety, type safety and more. I’ll act as a guide and alert you if you do anything that could go wrong.”</em></p>
</blockquote>
</td>
<tr>
<td>
<p><img src="images/professor.png" alt="Optimizer" /></p>
</td>
<td width="80%">
<blockquote>
<p><em>“Hi, I focus on making everything you write go as fast as possible. My goal is to allow you to write code in the safest, most readable, way possible so you don’t make mistakes. Then once she has approved it, I’ll take over and remove all of those abstractions so they don’t cost you a thing. Then I fine tune everything to be as fast as if you had written it all in assembler by hand.”</em></p>
</blockquote>
</td>
</tr>
</table>
<h1><a class="header" href="#history-of-rust" id="history-of-rust">History of Rust</a></h1>
<table style="background: maroon; color: white">
<tr>
<td>
<p>
<b>
The Beast adopted <em style="font-size:1.2em;line-height:0">new raiment</em> and studied the ways of <em style="font-size:1.2em;line-height:0">Time</em> and
<em style="font-size:1.2em;line-height:0">Space</em> and <em style="font-size:1.2em;line-height:0">Light</em> and the <em style="font-size:1.2em;line-height:0">Flow</em> of energy through the Universe.
From its studies, the Beast fashioned new structures from <em style="font-size:1.3em;line-height:0">oxidised metal</em> and proclaimed
their glories. And the Beast’s followers rejoiced, finding renewed purpose in these <em style="font-size:1.2em;line-height:0">teachings</em>.
</b>
</p>
<p><em>-- The Book of Mozilla, 11:14</em></p>
</td>
</tr>
</table>
<h2><a class="header" href="#prehistory" id="prehistory">Prehistory</a></h2>
<p>The history of programming is one of ever increassing levels of abstraction. Electrial signals were abstracted into instructions. CPU instructions were abstracted by assembly languages. The next innovation was proceedural programming. This provided a layer of abstraction helps avoid errors in flow control. Soon after their creation soon almost all programing was done in proceederal languages. </p>
<p>Proceedural programming is great for reasoning about flow control, but the introduction of variables which provide a useful name and abstract over registers and memory addresses intruduces a source of potential problems: It is often desireable or nessicary to have two variables refer to the same thing, and it is possible to forget that is the case. This seems subtle at first, but this problem of shared state, speffically shared <em>mutable</em> state, has become the root of most bugs.</p>
<p>It might not seem obvious that this is the case, after all it's usually simple enough to keep things strait. But shared mutable state manifests in a lot of different ways. In C++ these show up as:</p>
<ul>
<li>Dangling pointers</li>
<li>Use after free bugs</li>
<li>Segfaults</li>
<li>Iterator invalidation</li>
</ul>
<p>In Java you see:</p>
<ul>
<li>Null pointer exceptions</li>
<li>Concurrent modification exceptions</li>
<li>Race conditions</li>
<li>The need for synchronized blocks</li>
<li>The need for a garbage collector</li>
<li>The need for a JIT compiler because many optimizations can't be reasoned about from the code</li>
</ul>
<p>There were two major responses to dealing with the problem of shared mutable state. Functional programming which sought to remove the mutability, and write code using only immutable shared data. Object oriented programming which sought to use encapsulation to prevent state from being shared, while maintaining mutability.</p>
<p>Both approaches have been developed over the course of decades. Now they both work quite well. However they usually don't work together. Because if nieevly combining ideas from the two results in shared mutable state, which loses the benefit of either approach. So while there have been many ideas that have crossed over from OO languages to Functional languages and vice versa, the have been limited and adapted to the language they are in, and in general don't achieve the same effect they do in the language they came from.</p>
<p>The most important idea in Rust is to go beyond this dichotomy. By allowing state to be mutable and shared, but not at the same time Rust can bring the full power of Object Orientation and Functional programming to bare in the same language at the same time. This allows for:</p>
<ul>
<li>Memory safety without Garbage collection</li>
<li>High level abstraction without overhead</li>
<li>Compile time prevention of all NPEs, CMEs, Resource leaks, and Race conditions.
More importantly Rust opens the door to future paradigms and design patterns that just wouldn't be practical in other languages because they would be too error prone.</li>
</ul>
<h2><a class="header" href="#history-of-rust-1" id="history-of-rust-1">History of Rust</a></h2>
<p>Work on Rust began in earnest in 2009 at Mozilla based on a prototype that Graydon Hoare had been working on for a few years previously. After three years of development the first pre-alpha version of the compiler was released in 2012. </p>
<p>Shortly after the first release Graydon stepped back from the project. This change was a hugely important milestone, because it allowed other people step up. This allowed the project to move to a open governance model, with many people providing different perspectives. Over the next three years the language changed, a lot. New features were added and more importantly several features were removed or moved into third party libraries. These changes dramatically improved the language, because it turns out a lot of ideas that sound great don’t turn out so well in practice. </p>
<p>Rust’s evolution because changes were always anchored in very practical concerns as the core team spent most of their time working on Firefox. (a 4.4 million line C++ code base.) Eventually, in 2015 Rust 1.0 was released. This marked the first point where code could be written and still compile later. This marked a major change from pre-1.0 where if code that was more than 6 months old, you might as well rewrite it because the language was changing so quickly. </p>
<p>Since 2015 many features were added or modified, or moved out into libraries, but compatibility was always maintained. However overtime, things arose that would be better if compatibility could be broken. So to maintain their release frequency, and to avoid getting stuck in the compatibility trap that a lot of languages find themselves in, the Rust project team settled on a release system, where compatibility would with old versions would be maintained, but every three years a backwards incompatible changes would be introduced in a new ‘epoch’. The ‘epoch’ is specified explicitly and multiple different ones can co-exist in the same program. So the language can be stable, but without stagnating. </p>
<p>As of this writing the latest version is the 2018 release which contains a lot of improvements over Rust 1.0. It has been a rare pleasure to watch Rust continue to make rapid and significant improvements even as it’s usage grows. I believe this is a big part of why it was voted the “Most Loved Language” in the StackOverflow developer survey in 2016, 2017, and 2018. The percent of developers who have used it has grown each year, and the percentage of those who ‘love it’ has grown each year also. </p>
<p>As the name implies Rust isn’t about new ideas. It’s about taking well established and vetted ideas, and putting them together in a coherent way. Almost nothing in Rust is completely original. So in this guide you will see lots of familiar concepts, but they fit together very well. In large part this is due the fact that during its history Rust very aggressivly explored a lot of possible design space. It has had a very fast release cycle, and gone through many rounds of expermentation, design and redesign. The features that have landed have had tremendious amount of thought put into how they fit in and work together and in most cases many alternitive approaches were tried and rejected. </p>
<h2><a class="header" href="#geneology-of-rust" id="geneology-of-rust">Geneology of Rust</a></h2>
<p>Below is a chart of what languages influenced which other languages. Arrows go from the influencing language to the one influenced. Time moves from top to bottom. The left-right axis represents how abstract vs concrete the language is. Finally the languages are color coated by their type.</p>
<p><img src="images/history.png" alt="Geneology of Rust" /></p>
<p>While it might not be immediately obvious from looking a random code sample. As can be seen in the genealogy above, that Rust and Java are actually closely related. Rust draws heavily from Java's most influential predicessor C++ as well as C# which was very heavily influenced by Java. Java's philosophy of safety is also present throughout Rust.</p>
<p>Java was the first popular language to embrace the idea of safety. Unlike lower level languages Java prohibits users from directly manipulating memory or doing other dangerous operations, and unlike a lot of other high-level language is it has a strong type system which ensures that you don't get errors at runtime that could be caught earlier. Rust takes this idea of safety and really runs with it. It aims to prevent as many bugs as possible from reaching production by making incorrect code impossible to write. So like Java it prevents use of uninitialized memory, dangling pointers, use after free, memory leaks. Similarly Rust also provides exception safety, and prevents type errors through static type checking with generics. But Rust goes further and also prevents iterator invalidation / ConcurrentModificationExceptions, null pointers, resource leaks, ordering bugs due to static initialization or partial initialization, and data races in multi threaded code.</p>
<p>Rust’s primary goal is to prevent errors. If it is possible errors should be prevented at compile time. </p>
<table width="100%">
<tr>
<td> 
<p><img src="images/borrow.png" alt="Safety monitor" /></p>
</td>
<td width="80%">
<blockquote>
<p><em>The safest program is the program that doesn't compile</em></p>
</blockquote>
</td>
</tr>
</table>
<p>Portability
Java has a goal that you should build your code once and be able to run anywhere Rust doesn't quite have the same goal: it has the goal that you should be able to write your code once, compiler it many times, and have it run almost anywhere. Rust compiles to native code on each platform it supports which as of today is 23 CPU architectures, Windows, MacOS, Linux, Bsd, all major web browsers, Android, iOS, and even several different micro controllers. Part of the reason that Rust is able to be ond so many architectures is that it is self-hosting. The Rust compiler is written in Rust. The standard library is also written in Rust and it depends on very little native code. Rust even brings its own memory allocator. Because Rust compiles using llvm, as long as there is an llvm target available for a system, Rust can target it.</p>
<p>Performance
Usability</p>
<ul>
<li>Be a Good language
<ul>
<li>Safe, concurrent, practical</li>
<li>We can have nice things:  https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html</li>
</ul>
</li>
<li>Be usable
<ul>
<li>Many platforms</li>
<li>Package management</li>
<li>Build system and test harness</li>
<li>Fast enough that you won't need anything else.</li>
</ul>
</li>
<li>Pillars of rust
<ul>
<li>Speed without wizardry 
<ul>
<li>http://fitzgeraldnick.com/2018/02/26/speed-without-wizardry.html</li>
</ul>
</li>
<li>Memory safety without garbage collection</li>
<li>Concurrency without data races</li>
<li>Abstraction without overhead</li>
<li>Stability without stagnation
<ul>
<li>No unexpected changes to language and functionality
<ul>
<li>Across versions</li>
<li>By depending on something</li>
</ul>
</li>
</ul>
</li>
<li>Hack without fear. 
<ul>
<li>Confident systems programming</li>
</ul>
</li>
<li>Rust: fast, reliable, productive—pick three.</li>
<li>Zero cost abstractions
<ul>
<li>4 compiler optimization phases.</li>
<li>Normal code is just as fast as unsafe if you can explain to the compiler why it is safe</li>
<li>Zero size types mean hashMap&lt;k,()&gt; == set&lt;&gt; with not overhead.</li>
</ul>
</li>
</ul>
</li>
<li>API guidelines https://rust-lang-nursery.github.io/api-guidelines/
<ul>
<li>https://deterministic.space/elegant-apis-in-rust.html</li>
<li>Don't use booleans in API use named enums. It is more readable at the call site.</li>
</ul>
</li>
<li>Rust is implemented in Rust.
<ul>
<li>Look at String, or Vec, or Exceptions, or Channels or anything else, it’s written in pure rust. </li>
<li>THere are a number of primitives but all of the standard library is built on just these primitives. It doesn’t break out into some other language or ‘native’ code. </li>
<li>For example, you can perform a lot of fancy operations on Strings. But a lot of those actually just come from iterator, which automatically provides a lot of functionality for types that implement it. But Strings implementation of iterator isn’t some special native code, in fact String itself is just a Vec of UTF-8 characters. Vec is itself is a struct.</li>
<li>This allows Rust to be compiled and built in Rust, but more importantly it has forced those primitives on which the language is build to be sufficiently robust and flexible to support everything above them. And when one of those basic building blocks improves, everything above them benefits.</li>
</ul>
</li>
<li>Rust itself if a somewhat complicated language. It has a lot of features, more than Java (Though not as many a c++). But this is everything. The standard library is built using just these primitives, and compared to most languages (Especially Java) it’s standard library is small. Most of the features are developed externally to the language itself. Even things you wouldn’t necessarily expect, like Non-blocking IO, Concurrency support, and even Exceptions. 
<ul>
<li>This allows these components to be versioned independently and evolve more quickly than the language itself. It also allows competing libraries to replace them when they have a superior design.</li>
<li>Key to making this work is a built in dependency management system: Cargo. There will be a full chapter on it later.</li>
</ul>
</li>
<li>Culture of documentation</li>
<li>Culture of testing</li>
<li>Culture of inclusivity</li>
<li>Clippy</li>
</ul>
<h2><a class="header" href="#what-makes-a-good-language" id="what-makes-a-good-language">What makes a good language?</a></h2>
<ul>
<li>Code can be imagined as shapes
<ul>
<li>Width is interface complexity</li>
<li>Depth is complexity of problem</li>
<li>Volume is proportional to code volume 
<ul>
<li>Some languages are more concise and others more verbose, but this doesn't matter</li>
</ul>
</li>
<li>Narrow and Deep is better</li>
<li>Too shallow is worse than useless</li>
</ul>
</li>
<li>The best language is the one in which you write the best code.
<ul>
<li>Code can have problems:</li>
<li>Redundant</li>
<li>Interface covers things the impl doesn't</li>
<li>Interface is complicated</li>
<li>Poorly factored</li>
</ul>
</li>
<li>It is better if a language allows you to make three transformations
<ul>
<li>Factor out code</li>
<li>Generalize</li>
<li>Refine interface (eliminate unsupported features)</li>
<li>Shrink width (reducing impl)</li>
<li>Shrink interface preserving volume.</li>
</ul>
</li>
<li>A language feature is good if it let's you do these things.
<ul>
<li>It is bad if it causes the reverse
<ul>
<li>Example: exceptions and futures together.</li>
</ul>
</li>
</ul>
</li>
<li>Some languages enable all the things, others say none of them</li>
<li>To decide which are good think in terms of a standard library.
<ul>
<li>Where to draw the line?</li>
<li>To the left slows discourages improvement by impeding replacement and slowing development</li>
<li>To the right causes distribution issues.</li>
<li>For Java including a large stdlib was great… at first</li>
<li>Today we have deps management tools. So j2ee and similar things are now out. If this were the norm in 1995 java would be different.</li>
<li>This refactoring visualized
<ul>
<li>From the perspective of any given developer</li>
</ul>
</li>
</ul>
</li>
<li>Language features and the stdlib and the languages interface. </li>
<li>A language is just like any other program, it's just more important to get right.
<ul>
<li>It is bad if It has coupling with other features, causing the interface of the language, or worse application code to expand. (For this reason it is important that features be orthogonal and well factored) this is true of all interfaces but for a language it is more important because they have a lot of dependant code.</li>
<li>Causes ambiguity about what something does</li>
<li>Is easily confused with another feature/behaviour in the same language</li>
<li>Introduces inconsistency: An internal library can do something but a user library can’t copy that code and have it work</li>
<li>Forces additional complexity anywhere it isn’t used</li>
<li>Introduces a source of potential bugs</li>
<li>Causes a runtime failure, in the event that the user’s code is using it incorrectly</li>
<li>Makes errors go undetected</li>
<li>Forces repetition that can’t be factored out</li>
</ul>
</li>
<li>So a feature is good in a language if adding it:
<ul>
<li>Hide a lot of complexity behind a simple interface (ie: is just good code)</li>
<li>If it can't be implemented in application code and be effective. (Note this may be a red flag, as we want the minimal set)</li>
<li>Shrinks the overall interface by allowing code to be moved out. (As in the above example)</li>
<li>If it allows external code to shrink their interfaces</li>
<li>If it allows for external code to refine their interfaces</li>
<li>Serves can’t be met by normal library or application code</li>
<li>Moves bugs from latent to explicit, or from runtime to compile time</li>
</ul>
</li>
<li>Great features:
<ul>
<li>Interfaces and polymorphism</li>
<li>Generics
<ul>
<li>Constraint Based Generics and Parametric Polymorphism</li>
</ul>
</li>
<li>Symbols for complex but well defined tasks that can be plugged into
<ul>
<li>enhanced for loop</li>
<li>Try / with resources</li>
<li>Functional interfaces</li>
</ul>
</li>
<li>Exceptions
<ul>
<li>Algebraic Types and Type-safe Failure Modes</li>
</ul>
</li>
<li>Rust feature: Algebraic Types and Type-safe Failure Modes (more on this later)</li>
<li>Type Inference
<ul>
<li>Rust uses the Hindley-Milner type system, which is considered the best at this.</li>
</ul>
</li>
<li>Immutability
<ul>
<li>Better: Immutable by default.</li>
<li>Even better: Marking when data is modified.</li>
</ul>
</li>
<li>Pattern Matching and Compound Expressions</li>
<li>Isolating dangerous / low level operations</li>
<li>https://yager.io/programming/go.html </li>
</ul>
</li>
</ul>
<h1><a class="header" href="#the-rust-community" id="the-rust-community">The Rust Community</a></h1>
<p>Rust is known for having a very helpful community. You can see dozens of links different community spaces prominently featured on the Rust homepage. This is a pretty big contrast to a lot of programming communities. In many languages there either isn’t a recognisable community, or there is one, but it can be unwelcoming or outright hostile to beginners. </p>
<p>A big part of this is that Rust was born out of Mozilla, which has a lot of experience managing open source communities. They established a code of conduct, a moderation team, user groups, forms, and open source development teams. </p>
<p>Another aspect it the language itself. Rust’s learning curve is both initially steep and long. Fortunately this process isn’t painful because the difficulty does not come from ‘magic’. Rust is very explicit and almost everything works exactly the way you’d expect. Rather it comes from learning to work within the safety rules. It is sometimes complicated and isn’t similar to other languages. But this has a way of keeping people humble. In a lot of other languages, it’s easy to forget that things that seem second nature now used to be confusing. </p>
<p>So in some languages, you might be mocked for asking for help, or be unable to find it, or write what you think is right only to have things break at Runtime. With Rust, you might have to ask for help more or work harder to get things to compiler. But you’ll find lots of people will be happy to help. And once your code does compile, you can be fairly confident it is correct.</p>
<h2><a class="header" href="#rfc-process" id="rfc-process">RFC process</a></h2>
<p>TODO:</p>
<ul>
<li>Pluralism and positive sum game (multiple sources of authority working together)</li>
<li>Different perspectives reach a better solution
<ul>
<li>Yelling lowder and ‘thicker skin’ is bad because it does not bring new insight</li>
<li>https://aturon.github.io/2018/06/02/listening-part-2/</li>
<li>Humility, empathy, and introspection</li>
</ul>
</li>
<li>Discuss</li>
<li>Pre-rfc</li>
<li>RFC</li>
<li>Impl</li>
<li>Nightly</li>
<li>Crater to rebuild to world</li>
<li>Beta - through release</li>
<li>No new reasoning</li>
<li>Committees and many perspectives. </li>
</ul>
<h1><a class="header" href="#variable-declaration" id="variable-declaration">Variable declaration</a></h1>
<p>Below is an example of a variable being declared in Java and the equivalent expression in rust.</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let foo : i32 = 5;
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-java">int foo = 5;
</code></pre>
<p>The keyword <code>let</code>is used to indicate you are declaring a variable. This is followed by the variable name, then a colon and then the type. 
The reason Rust puts the type one the right is because the type is optional anytime it can be inferred by the compiler. Which means that most of the time we can just write:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let foo = 5;
<span class="boring">}
</span></code></pre></pre>
<p>The equals sign for assignment works the same way it does in Java. Primitives also work the same way but they have different names. Below is a table to help:</p>
<table><thead><tr><th>Java</th><th>Rust</th></tr></thead><tbody>
<tr><td>long</td><td>i64</td></tr>
<tr><td>int</td><td>i32</td></tr>
<tr><td>short</td><td>i16</td></tr>
<tr><td>byte</td><td>i8</td></tr>
<tr><td>double</td><td>f64</td></tr>
<tr><td>float</td><td>f32</td></tr>
</tbody></table>
<p>Rust also supports unsigned integers these cannot be negative and use their highest order bit to represent higher numbers just like any other bit. The range of values that can be represented in each is listed in the table below. </p>
<table><thead><tr><th>Type</th><th>Min</th><th>Max</th></tr></thead><tbody>
<tr><td>u8</td><td>0</td><td>2^8-1</td></tr>
<tr><td>u16</td><td>0</td><td>2^16-1</td></tr>
<tr><td>u32</td><td>0</td><td>2^32-1</td></tr>
<tr><td>u64</td><td>0</td><td>2^64-1</td></tr>
<tr><td>u128</td><td>0</td><td>2^128-1</td></tr>
</tbody></table>
<p>Constants can also explicitly specify their type. (Similar to Java) The examples below are equivalent.</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const SECONDS_PER_MINUTE : i64 = 60;
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-java">static final long SECONDS_PER_MINUTE = 60;
</code></pre>
<p>By default all variables in Rust are final. So instead of a final keyword there is the <code>mut</code> keyword to indicate the variable is mutable (non-final). For example:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut counter = 0;
<span class="boring">}
</span></code></pre></pre>
<p>The advantage of using <code>mut</code> rather than <code>final</code> (besides being fewer characters) is it makes the declaration is far more likely to be accurate. In Java it very common to simply omit the final keyword even when a variable is final. As a result when reading Java you often don’t know if a variable is final or not. </p>
<table width="100%">
<tr>
<td> 
<p><img src="images/borrow.png" alt="Safety monitor" /></p>
</td>
<td width="80%">
<blockquote>
<p><em>Rust's default declaration actually provides an even stronger guarantee than Java's final, because we not only enforce that the variable won't be reassigned, but also that it's contents won't be changed.</em></p>
</blockquote>
</td>
</tr>
</table>
<p>A ‘final-by-default’ policy makes reasoning about code a lot easier, because you know if something is going to change. This makes writing multi-threaded code easier, because if something is immutable can always be shared safely between threads. (We’ll come back to this in a later chapter).</p>
<h1><a class="header" href="#common-types" id="common-types">Common types</a></h1>
<p>There are some common builtin types that appear in a lot of the examples. The details of each will be explained later.</p>
<h2><a class="header" href="#box" id="box">Box</a></h2>
<p>The first and most embarassingly simple of which is <code>Box</code>. Box is a collection of exactly one item. (It can't even be empty) It's just a wrapper around a generic value. If you were to implemente Box in Java it would look like this:</p>
<pre><code class="language-Java">class Box&lt;T&gt; implements Iterable&lt;T&gt; {
  private final T item;

  public Box(T item) {
    this.item = item;
  }

  public Item getItem() {
    return item;
  }

  @Override
  public Iterator&lt;Item&gt; iterator() {
    //...
  }
}
</code></pre>
<p>You may be wondering: &quot;Why would I ever need such a useless class?&quot;. Usually you don't. But it comes up as a to work around some restrictions. 
These cases will be explained when they come up.</p>
<p>Declaring a box is done like this:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let boxed = Box::new(1);
// or if you want to be explicet about the type
let boxed2 : Box&lt;i32&gt; = Box::new(2);
<span class="boring">}
</span></code></pre></pre>
<p>The <code>::</code> operator in the example above acutally does exactly the same thing it does in Java. It is how you can refer to a static method without invoking it. IE: <code>Arrays.sort(stringArray, String::compareToIgnoreCase);</code> but in Rust, once you have a method reference instead of calling <code>method.run()</code> or <code>method.call(arg)</code> you can just invoke it: <code>method()</code> or <code>method(arg)</code>. So <code>Box::new</code> refers to the constructor of <code>Box</code> just like it would in Java, and the <code>(1)</code> following it invokes the method passing the argument <code>1</code>.</p>
<h2><a class="header" href="#vec" id="vec">Vec</a></h2>
<p>Rust has a built in type called <code>Vec</code> which is short for &quot;Vector&quot;. It is equivlent to Java's <code>ArrayList</code>. However because Rust does not have &quot;primitive wrapper&quot; types like Java's &quot;Integer&quot; and &quot;Byte&quot; (as opposed to &quot;int&quot; and &quot;byte&quot;) and is capable of putting primitives in collections directly without any overhead <code>Vec</code> receives a lot more use in Rust than <code>ArrayList</code> does in Java. It is often used in places where in Java you would use an array or 'Collection'.</p>
<p>The syntax looks like this:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">fn get_numbers() -&gt; Vec&lt;i32&gt; { vec![] }
</span>let mut numbers : Vec&lt;i32&gt; = get_numbers();
numbers.push(5); //Pushes 5 onto the vector. (vec will automatically resize if needed)
<span class="boring">}
</span></code></pre></pre>
<p>Because adding layer of abstraction does not add any overhead in Rust it is common to pass a <code>Vec&lt;u8&gt;</code> where you would use a byte array in Java.</p>
<h2><a class="header" href="#string" id="string">String</a></h2>
<p>Rust has a string type. It's a little different from Java's. While Java's String is built out of a <code>char[]</code> where each <code>char</code> is a UTF-16 code point, Rust's String is based on a <code>Vec&lt;u8&gt;</code> where the bytes are valid UTF-8.</p>
<p>This has advantages for size and serialization. But the real gain is that Strings can be mutable if desired. If is declared with <code>let mut directions : String = ...</code> it is mutable, and if it is declared with <code>let name : String = ...</code> it is not. </p>
<p>Of course, passing around mutable Strings would be error prone in Java. We'll cover why this is not a problem in Rust in the <a href="./ownership.html">chapter on Ownership</a>.</p>
<h1><a class="header" href="#method-signatures" id="method-signatures">Method Signatures</a></h1>
<p>Below is a Java method signature and the equivalent rust signature. </p>
<pre><code class="language-java">void printNum(int num);
</code></pre>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Example {
</span>fn print_num(num: i32);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Things to notice: 
The Rust method starts with the keyword “fn” this simply indicates that a function is being declared. This is followed by the method name and each of the parameters to the method in parentheses. Unlike Java where the type appears on the left followed by the argument name, in Rust the name comes first followed by a ':’ followed by the type. (Similar to how variables are declared)</p>
<p>If the function had a return value it would be declared on the right hand side like this:</p>
<pre><code class="language-java">int add(int a, int b);
</code></pre>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Example {
</span>fn add(a: i32, b: i32) -&gt; i32;
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>There is no “void” in Rust. If there isn't a return value, just don't provide one.</p>
<p>Just as in Java the method body is in between the curly braces.</p>
<pre><code class="language-java">int add(int a, int b) {
    return a + b;
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn add(a: i32, b: i32) -&gt; i32 {
    return a + b;
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#borrowing" id="borrowing">Borrowing</a></h2>
<p>In Rust a variable can also be “borrowed”. When the parameter to a method is borrowed, it means the method promises not keep the parameter after the method has returned. Or anything it obtained from the parameter.</p>
<p>A method that takes a borrowed parameter cannot assign the parameter to a member variable. Also it can only pass that parameter to other methods which also borrow it. (Otherwise it would be able violate its contract indirectly.)</p>
<table width="100%">
<tr>
<td> 
<p><img src="images/borrow.png" alt="Safety monitor" /></p>
</td>
<td width="80%">
<blockquote>
<p><em>I will act as the borrow checker to make sure you don't make a mistake.</em></p>
</blockquote>
</td>
</tr>
</table>
<p>To indicate a parameter is borrowed, in the method signature, place a “&amp;” in front of the type.</p>
<p>As an example, in Java you might define a method 'isSorted’ like this </p>
<pre><code class="language-java">boolean isSorted(List&lt;Integer&gt; values);
</code></pre>
<p>that returns a boolean indicating if a list is sorted. In Rust you would add an ‘&amp;’ in front of the type in the method signature to indicate that it will not retain any references to the list or it's contents when the method returns.</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Example {
</span>fn is_sorted(values: &amp; Vec&lt;i32&gt;) -&gt; bool;
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>It is helpful to think of 'borrowed’ as being part of the type. IE “The method takes a borrowed list.” </p>
<p>This declaration provides a strong and useful guarantee to the callers of a method. </p>
<p>Of course it would be worthless if in a newer version, the method just deleted the ‘&amp;’ from it's signature and removed the guarantee. To prevent this, and to make the guarantee explicit in the caller's code, when a method is being invoked; When a method that borrows a parameter is invoked, the caller puts an ‘&amp;’ in front of the variable name being passed in. For example </p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">fn is_sorted(values: &amp; Vec&lt;i32&gt;) -&gt; bool { true }
</span><span class="boring">let values = vec![1, 2, 3];
</span>if (is_sorted(&amp;values)) {
    //...
}
<span class="boring">}
</span></code></pre></pre>
<p>This is only needed if the variable being passed isn't borrowed already. (Otherwise it would be redundant, because it can only pass it to methods which borrow it.)</p>
<p>Passing a parameter to a method that borrows is sometimes referred to a the parameter being “lent” to the method. </p>
<h3><a class="header" href="#mutability" id="mutability">Mutability</a></h3>
<p>In Java a variable can be declared <code>final</code>. This means the value cannot be reassigned. It however does not guarentee that its contents won't change. For example if you have the method:</p>
<pre><code class="language-java">void process(final List&lt;Foo&gt; toProcess);
</code></pre>
<p>You can't tell from looking at the signature if the <code>toProcess</code> list will be modified or if the individual items in the list will be modified.</p>
<p>Rust avoids this ambiguity with the keyword <code>mut</code>. All values are unmodifyable by default, and if the variable or any of its contents are going to be changed it is prefixed with the <code>mut</code> keyword for eample:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut value = 0;
value += 10;
<span class="boring">}
</span></code></pre></pre>
<p>Similar to variable declaration, if you want to modify a borrowed parameter, you use the 'mut’ keyword. This goes right in front of the type.</p>
<pre><code class="language-java">void populateCounts(HashMap&lt;String, int&gt; itemCounts);
</code></pre>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">trait Example {
</span>fn populate_counts(item_counts: &amp;mut HashMap&lt;String, i32&gt;);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><code>mut</code> can be thought of a part of the type. IE “a borrowed mutable Hashmap” as opposed to “a Hashmap&quot;.</p>
<p>When 'Borrowed’ is combined with 'mut’ the ‘&amp;’ goes first. If you wanted to write a method to sort a list, it would take a borrowed mutable list.</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Example { 
</span>fn sort(names: &amp;mut Vec&lt;String&gt;);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>This signature means <code>sort()</code> may change the list, but only during the invocation of the method and will retain no references to the list or its contents once the method returns.</p>
<h2><a class="header" href="#javadocs" id="javadocs">Javadocs</a></h2>
<p>Documentation is an area where Rust and Java are very similar. In Java you might add a javdoc like this </p>
<pre><code class="language-java">/**
 * Computes an approximation of {@code 1/sqrt(a)} segnifigantly faster. 
 * However compared to using {@link java.lang.Math.sqrt()} the result is much less accurate.
 * @param   a   the value to compute the inverse square root of.
 * @return an approximate inverse square root of the passed parameter.
 */
public double fastInvSqrt(double a);
</code></pre>
<p>which can be automatically translated into HTML documentation. </p>
<h2><a class="header" href="#rustdocs" id="rustdocs">Rustdocs</a></h2>
<p>Rust has rustdocs which work similarly. You could write the following:</p>
<pre><code class="language-rust ignore">/**
 * Computes an approximation of `1/a.sqrt()` segnifigantly faster.
 * However compared to using [`sqrt`] the result is much less accurate.
 * # Examples
 * ```
 * let a = 7.0_f64;
 * let exact = 1.0 / a.sqrt();
 * let approx = a.fast_inv_sqrt();
 * assert!((approx-exact).abs() &lt; 1e-5);
 * ```
 */
</code></pre>
<p>Or instead of “/**” and a block comment, you can use “///” and line comments. So the following is equivalent:</p>
<pre><code class="language-rust ignore">/// Computes an approximation of `1/a.sqrt()` segnifigantly faster.
/// However compared to using [`sqrt`] the result is much less accurate.
/// # Examples
/// ```
/// let a = 7.0_f64;
/// let exact = 1.0 / a.sqrt();
/// let approx = a.fast_inv_sqrt();
/// assert!((approx-exact).abs() &lt; 1e-5);
/// ```
</code></pre>
<p>(This helps with small comments as it doesn't require an extra line at the top and bottom.)</p>
<p>Javadocs have a number of common tags such as “@param” and “{@link }”. Below are some common ones and their Rust equivalents.</p>
<table><thead><tr><th>Type</th><th>Java</th><th>Rust</th></tr></thead><tbody>
<tr><td>Link to method</td><td><code>{@link Foo#bar() }</code></td><td><code>[`Foo::bar()`]</code></td></tr>
<tr><td>Link to URL</td><td><code>&lt;a href=&quot;https://google.com&quot;&gt; google&lt;/a&gt;</code></td><td><code>[google](https://google.com)</code></td></tr>
<tr><td>Code snippit</td><td><code>{@code foo.bar()}</code></td><td><code>`foo.bar()`</code><br/>or<br/><code>```</code><br/>  <code>foo.bar();</code><br/><code>```</code></td></tr>
<tr><td>Parameter</td><td><code>{@param foo bla bla}</code></td><td>N/A Documented through examples and code snippits</td></tr>
<tr><td>Return</td><td><code>@return bla bla</code></td><td>N/A Documented through examples and code snippits</td></tr>
<tr><td>Examples</td><td><code>&lt;pre&gt;</code> <br/> <code>{@code </code>  <br/>  <code>//...</code> <br/> <code>}</code> <br/> <code>&lt;/pre&gt;</code></td><td><code># Examples</code> <br/> <code>```</code> <br/>  <code>//...</code><br/> <code>```</code></td></tr>
<tr><td>See also</td><td><code>{@see  &quot;Bla bla&quot;}</code></td><td><code># See Also</code> <br/> <code>Bla bla</code></td></tr>
<tr><td>Custom tag</td><td>Requires custom javac args</td><td><code># My custom section</code> <br/> <code>//...</code></td></tr>
<tr><td>Bulleted list</td><td><code>&lt;ul&gt; </code><br/><code>&lt;li&gt;one&lt;/li&gt; </code><br/><code>&lt;ul&gt; &lt;li&gt;one point one&lt;/li&gt; &lt;/ul&gt;</code><br/><code> &lt;/ul&gt;</code></td><td><code>* one</code><br/><code>** one point one</code></td></tr>
</tbody></table>
<p>Difference between Javadocs and Rustdocs is that to do formatting, in Java you would inject HTML tags, where as in Rust you use Markdown syntax. So the following Javadoc and Rustdoc are equivalent __ vs __. As you can see this improves readability a lot.</p>
<p>To generate an view your docs you can run _. Which will put the documentation in _. When you publish your code to Crates.io (Rust’s main package repo, the docs will be published automatically.) There will be more on Crates.io and the Cargo command in chapter _.</p>
<p>Additional information for the doc can also be placed inside of the method, if for some reason that makes more sense from an organization point of view. So the following are equivalent __ and __.</p>
<p>Docs can also be hidden (If for example a feature is still being tested) like this __. Similarly you can use the _ annotation to mark them as being platform specific. For example __.</p>
<p>It is common practice in Rust to write a small example for how to use each function rather than documenting all of the input and output parameters like you would in Java. So instead of __ you might write __ in Rust. These examples aren’t just for show, they also get automatically turned into unit tests. For example __. This makes sure your documentation stays up to date with the code. If you want to hide a few lines of setup at the top of an example you can use _. For example __. </p>
<h2><a class="header" href="#macros" id="macros">Macros</a></h2>
<p>Ok, let’s finally get around to writing HelloWorld:</p>
<pre><pre class="playpen"><code class="language-rust">/// Prints &quot;Hello world!&quot;.
fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p>You may be wondering: “What is that exclamation point doing at the end of that function name?” The answer is 'println!’ is not a normal function it is what is called a “Macro”. Rust macros are &quot;hygienic&quot; so they don't have the horrifyingly dangerous properties of C and C++ macros, and are designed to be safe.</p>
<p>You can think of macros as a function that does things that functions can't normally do. In this case ‘println’ supports string templates. </p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let name = &quot;Ferris&quot;;
    println!(&quot;Hello {}!&quot;, name);
}
</code></pre></pre>
<table width="100%">
<tr>
<td> 
<p><img src="images/borrow.png" alt="Safety monitor" /></p>
</td>
<td width="80%">
<blockquote>
<p>The template is validated at compile time. So if you were to type </p>
<pre><code class="language-rust ignore">println!(&quot;Hello {}!&quot;);
</code></pre>
<p>or </p>
<pre><code class="language-rust ignore"><span class="boring">let name = &quot;a&quot;; let name = &quot;b&quot;
</span>println!(&quot;Hello {}!&quot;, name1, name2);
</code></pre>
<p>the mistake would actually be a compile error. Which is great because it means you can't write incorrect code.</p>
</blockquote>
</td>
<tr>
<td>
<p><img src="images/professor.png" alt="Optimizer" /></p>
</td>
<td width="80%">
<blockquote>
<p><em>This has the added bonus of not spending any CPU at runtime parsing and verifying the template.</em></p>
</blockquote>
</td>
</tr>
<tr>
<td colspan="2">
<blockquote>
<p>Checking a template at compile time is something a normal function couldn't possibly do. Will get into how this implemented in a later chapter. But for now you should think of an elimination mark, as an alert that there's something unusual about that function and you should read its documentation.</p>
</blockquote>
</td>
</tr>
</table>
<p>Another place you'll see macros, is for initilizing collections or places where you might find &quot;varargs&quot; in Java. For example you can initilaize a Vec with the <code>vec!</code> macro:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let number = vec![1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#flowcontrol" id="flowcontrol">Flowcontrol</a></h1>
<p>Similar to Java in Rust variables are defined to exist in the scope where they are declared. So you can do this</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut i = 0;
while i &lt; 10 {
    println!(&quot;Counter: {} &quot;, i);
    i += 1;
}
<span class="boring">}
</span></code></pre></pre>
<table width="100%">
<tr>
<td>
but not this:
<pre><code class="language-rust ignore">  for i in 1..10 {
      let x = i;
  }
  println!(&quot;You can't do this: {}&quot;, x);
</code></pre>
<div style="text-align: right"> 
<p><em>This is a bug because <code>x</code> is out of scope.</em></p>
</div>
</td>
<td>
<p><img src="images/borrow.png" alt="Safety monitor" /></p>
</td>
</tr>
</table>
<p>Rust has <code>return</code> keyword, which works exactly like java:</p>
<pre><code class="language-java">int square(int x) {
    return x * x;
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn square(x: i32) -&gt; i32 {
    return x * x;
}
<span class="boring">}
</span></code></pre></pre>
<p>However in Rust expressions will return the last value in them if it is not followed by a <code>;</code> so you can just write:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn square(x: i32) -&gt; i32 {
    x * x
}
<span class="boring">}
</span></code></pre></pre>
<p>This also holds true for things like if statements</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">fn something() -&gt; bool {true};
</span>let x = if something() { 1 } else { 0 };
<span class="boring">}
</span></code></pre></pre>
<p>is equivalent to</p>
<pre><code class="language-java">int x;
if (something()) {
    x = 1;
} else {
    x = 0;
}
</code></pre>
<p>or</p>
<pre><code class="language-java">int x = something() ? 1 : 0;
</code></pre>
<p>in Java.</p>
<p>Note that the parenthesis around an <code>if</code> or <code>while</code> conditional are totally optional. Because in Rust the conditional is just an expression in Rust, just like any other.</p>
<p>Below are examples of If, for, and while loops compared to their java equivalents. __ and __.</p>
<table><thead><tr><th>Rust</th><th>Java</th></tr></thead><tbody>
<tr><td><code>if _ { _ } else { _ }</code></td><td><code>if (_) { _ } else { _ }</code></td></tr>
<tr><td><code>match _ { _ =&gt; _ }</code></td><td><code>switch (_) { case _ : _ break; }</code></td></tr>
<tr><td><code>while _ { _ }</code></td><td><code>while (_) { _ }</code></td></tr>
<tr><td><code>loop { _ }</code></td><td><code>while (true) { _ }</code></td></tr>
<tr><td><code>for i in _ { _ }</code></td><td><code>for (X i : _) { _ }</code></td></tr>
<tr><td><code>for i in 0..n { _ }</code></td><td><code>for (int i = 0; i &lt; n; i++) { _ }</code></td></tr>
<tr><td><code>break</code> / <code>break 'label</code></td><td><code>break</code> / <code>break label</code></td></tr>
<tr><td><code>continue</code> / <code>continue 'label</code></td><td><code>continue</code> / <code>continue label</code></td></tr>
<tr><td><code>return _;</code></td><td><code>return _;</code></td></tr>
</tbody></table>
<p>There are a few differences: Rust does not have <code>do/while</code> loops. In Rust the <code>match</code> statement can use pattern matching and the cases do not &quot;fallthrough&quot; like <code>switch</code> in Java, so there is no need for a <code>break</code>.</p>
<p>The Rust <code>for</code> loop works like java’s “new” for loop, and doesn’t have the C style 3 part condition version.</p>
<pre><code class="language-java">for (String item : collection) {
    //...
}

</code></pre>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let collection = vec![1,2,3];
</span>for item in collection { //Item's type is infered
    //...
}
<span class="boring">}
</span></code></pre></pre>
<p>If you want to write a pattern like that, you can use a “range” operator instead.</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>for i in 0..10 {
    //...
}
<span class="boring">}
</span></code></pre></pre>
<p>The &quot;..&quot; operator produces an iterator between the value on the left and the one on the right (inclusive and exclusive). Rust also has a “loop” loop which is equivalent to <code>while (true)</code> in Java. The keywords <code>break</code> and <code>continue</code> work the same way they do in Java.</p>
<pre><code class="language-java">while(true) {
    //...
    break;
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>loop {
    //...
    break;
}
<span class="boring">}
</span></code></pre></pre>
<p>Notice that the if, while, and for conditional arguments are just normal expressions that return a boolean. (As opposed to Java where it is a special construct surrounded by parenthesis). And because anything surrounded by curly braces is an expression which returns the last expression inside of it, it is possible to write a loop like conditional like this:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut i = 1;
while { i = i*2; i &lt; 65536 } {
    //...
}
<span class="boring">}
</span></code></pre></pre>
<p>here the code is iterating over the powers of 2, but the code to update the variable <code>i</code> has been put in the top as part of the loop conditional. (The purpose of showing this is not to encourage doing this all over the place, but rather to show how the compiler sees things)</p>
<h2><a class="header" href="#functions-as-arguments" id="functions-as-arguments">Functions as arguments</a></h2>
<p>In Java sometimes you pass functions as arguments. With a named function this is doen like this:</p>
<pre><code class="language-java">Stream printableElements = stream.filter(Element::shouldPrint);
</code></pre>
<p>The Rust equivalent would be do this:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Element();
</span><span class="boring">impl Element {
</span><span class="boring">   fn should_print(&amp;self) -&gt; bool { true }
</span><span class="boring">}
</span><span class="boring">let stream = vec![Element()].into_iter();
</span>let printable_elements = stream.filter(Element::should_print);
<span class="boring">}
</span></code></pre></pre>
<p>Which usses the same <code>::</code> syntax.</p>
<p>Java can also create an “Anonymous function” (So called because it don’t have a function name) or “Closure” (so called because they can refer to local variables in the surrounding function) like this:</p>
<pre><code class="language-java">Stream printableElements = stream.filter(e -&gt; e.shouldPrint());
// or
Stream printableElements = stream.filter((e) -&gt; {
    e.shouldPrint();
});
</code></pre>
<p>In Rust the syntax is:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Element();
</span><span class="boring">impl Element {
</span><span class="boring">   fn should_print(&amp;self) -&gt; bool { true }
</span><span class="boring">}
</span><span class="boring">let stream = vec![Element()].into_iter();
</span>let printable_elements = stream.filter(|e| e.should_print());
// or
<span class="boring">let stream = vec![Element()].into_iter();
</span>let printable_elements = stream.filter(|e| {
    e.should_print()
});
<span class="boring">}
</span></code></pre></pre>
<p>Here the <code>|</code> characters replace the parentheses and the curly braces are optional if there is only a single statement.</p>
<h1><a class="header" href="#memory-safety-and-gc" id="memory-safety-and-gc">Memory safety and GC</a></h1>
<p>Like Java, Rust has automatic memory management so you never have to worry about explicitly allocating or deallocating objects. However unlike Java it does not have a garbage collector. This may sound like a contradiction but it's not. </p>
<p>It turns out, not coincidentally, the same static analysis that solves the problem of allowing sharing or mutability but never both, also solves the problem of perfect garbage collection. </p>
<p>One way to think about it is to think of Rust as having compile time garbage collection. The compiler works out where in your code objects are no longer used automatically generates the necessary code to deallocate them.</p>
<p>So like Java this means Rust does not suffer from memory leaks, use-after-free bugs, dangling pointer bugs, or buffer overflows that plague most compiled languages. At the same time Rust does not have the overhead of garbage collection or the associated runtime which has prevented languages like Java and C# from reaching the performance of C++ in “object heavy” applications.</p>
<h1><a class="header" href="#ownership" id="ownership">Ownership</a></h1>
<p>To explain how Rust achieves automatic memory management without garbage collection and a number of other more advanced features we need to first explain Ownership. </p>
<p>Ownership is a common pattern in programming in any language even though it really isn’t a part of most languages themselves. It’s best to see this through example. In Java compare the method <code>addAll</code> on <code>TreeSet</code> to the static method <code>Collections.sort</code>. Both provide ways to sort a list of items by passing it into a method, but the contract of these methods is quite different. In the case of the <code>TreeSet.add</code> ownership of the values is being implicitly transferred to the TreeSet. The caller should not hold onto references to the items added to the Set. If they want to modify one of the items they should first remove it from the set. Otherwise the change could affect the of sort order and break the TreeSet resulting in undefined behavior. On the other hand <code>Collections.sort</code> does not have this restriction. In fact it is implicit in the contract of the method that the implementation won't hold onto references to the items passed after the method returns. If the implementation of sort were to modify the the list after it returned it would surely break the caller's code. <code>Collections.max</code> is similar but it has the additional implicit assumption that it won't modify the passed list. </p>
<p>In Rust these assumptions are explicitly declared as part of the method signature. So if in Java we were to declare integer speffic versions on each of these, it would look like this: </p>
<pre><code class="language-java">public interface IntegerSet {
  //...
  public void addAll(List&lt;Integer&gt; list);
}
public static Integer max(List&lt;Integer&gt; list) {
   // ...
}
public static void sort(List&lt;Integer&gt; list) {
   // ...
}
</code></pre>
<p>in Rust an equivlent method are declared as:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait MySet {
  //...
  fn add_all(list: Vec&lt;i32&gt;);
}
fn max(list: &amp;Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; { 
  //...
<span class="boring">list.iter().cloned().max()
</span>}
fn sort(list: &amp;mut Vec&lt;i32&gt;) {
   //...
<span class="boring">  list.sort();
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>Notice that the type of the argument changed. When it is just <code>Vec&lt;i32&gt;</code> the method is taking ownership of the value. 
But when it is <code>&amp;Vec&lt;i32&gt;</code> it is a borrowed vector, meaning the caller still retains ownership. And a <code>&amp;mut Vec&lt;i32&gt;</code>
is a borrowed mutable vector meaning that even though the function is not taking ownership, it may modify the provided vector.</p>
<p>For any given object there is one owner. When that variable is reassigned or goes out of scope the value is dropped. 
This applies transitively. For example in the function:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn process(items: Vec&lt;String&gt;) {
  //...
}
<span class="boring">}
</span></code></pre></pre>
<p>when the function returns, the vector <code>items</code> and all of the strings in it will be dropped from memory.</p>
<p>This might seems like it doesn’t allow cycles. There are ways to create cycles, but for the most part they aren’t needed.
Why this is the case will be covered later in <a href="./rust_makes_you_better_at_java.html">“How Rust makes you a better Java programmer”</a>.</p>
<p>The main tool that used in conjunction with ownership is borrowing.</p>
<h1><a class="header" href="#borrows" id="borrows">Borrows</a></h1>
<ul>
<li>Output to be populated</li>
<li>Sort example</li>
<li>Also called reference (Not the same as a C++ ref, more like a smart pointer)</li>
<li>Primitive (copy by value) vs pointer</li>
<li>Copy vs move (is similar)</li>
</ul>
<p>In addition to compile time memory management and <a href="./concurrency.html">guaranteed thread safety</a>),
explicit ownership opens up a lot of useful patterns.</p>
<p>In Java a common pattern is to pass around a byte array with a offset and length to provide access to a part of an array without making a new copy. For example see <code class="java">java.io.OutputStream.write(byte[] b, int off, int len)</code> or <code class="java"> java.io.FileInputStream.read(byte[] b, int off, int len)</code>. In Rust you can use slices. So you can write </p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">let mut output = io::stdout();
</span>let buffer = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
output.write(&amp;buffer[2 .. 8]);
<span class="boring">}
</span></code></pre></pre>
<p>which passes a segment of a byte array to the <code>write</code> function. In addition to convince and performance, it allows you specify if the slice is being passed can be written to or just read from have this enforced by the compiler. So if you have a function that looks like this:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct MyConfig(i32);
</span>pub fn apply_config(config : &amp;MyConfig) {
  //...
}
<span class="boring">}
</span></code></pre></pre>
<p>you can be sure that the <code>config</code> object won’t be changed by passing it to the function. No defensive copies required. Similarly, above the caller is guaranteed that <code>output.write(&amp;buffer)</code> won’t modify the contents of the buffer.</p>
<p>Borrowing also works with loops. When using a for loop to iterate over a collection, you can either pass the for loop the collection itself </p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let strings = vec![&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;bat&quot;];
for value in strings {
  println!(&quot;Hello {}&quot;, value);
}
<span class="boring">}
</span></code></pre></pre>
<p>consuming the collection in the process, much a like a stream in Java. Or you can let it borrow the collection</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let strings = vec![&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;bat&quot;];
for &amp;value in &amp;strings {
  println!(&quot;Hello {}&quot;, value);
}
<span class="boring">}
</span></code></pre></pre>
<p>If the collection is borrowed then inside the loop each entry will itself be borrowed. This is actually a important feature. In Java a for-each loop can't take an iterator only an iterable. This is because if it did you could write</p>
<pre><code class="language-java">Iterator&lt;String&gt; iter = //...
for (value : iter) {
  //...
}
for (oops : iter) {
  //Can't get here...
}
</code></pre>
<p>the second loop wouldn’t make any sense because it can’t get any data because there is no way to invoke .iterator() again and reread the data. For this reason Java introduced a second concept ‘streams’ which don’t work with for loops. Because there was no way to convey to the compiler that the for loop will consume the values it's iterating over, Java had to create two separate concepts <code>stream</code> and <code>iterator</code> that don’t work together. You can either write </p>
<pre><code class="language-java">List&lt;Foo&gt; foos = //...
for (Foo f : foos) {
  if (meetsCriteria(f)) {
    process(f);
  }
}
</code></pre>
<p>or you could write</p>
<pre><code class="language-java">List&lt;Foo&gt; foos = //...
foos.stream().filter(f -&gt; meetsCriteria(f)).forEach(f-&gt;process(f));

</code></pre>
<p>but you can’t mix these ways of coding. In Rust this can be conveyed by either passing or lending the collection to the for loop. This allows the concepts of stream and iterator to be unified into a single simple interface and work with for loops without the risk of accidentally reusing the consumed stream allowing you to write:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo(i32);
</span><span class="boring">fn get_foos() -&gt; Vec&lt;Foo&gt; { vec![Foo(1), Foo(2)] }
</span><span class="boring">fn meets_criteria(f : &amp;Foo) -&gt; bool { true }
</span><span class="boring">fn process(f : Foo) {}
</span>let foos : Vec&lt;Foo&gt; = get_foos();
for f in foos.into_iter().filter(|f| meets_criteria(f)) {
  process(f);
}
<span class="boring">}
</span></code></pre></pre>
<p>In addition to these there are a bunch of other common patterns.</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Example {
</span>fn read_from_buffer(&amp;self, buffer : &amp;[u8]);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Here a method is borrowing a parameter but it's not modifying it. When is the messages returned your guaranteed it is not still holding onto it. </p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::path::Path;
trait Config {
  //...
  fn get_storage_location(&amp;self) -&gt; &amp;Path;
  //...
}
<span class="boring">}
</span></code></pre></pre>
<p>Here an accessor method is lending the caller some of the object's internal state (in a read only way) the calling code
cannot invoke any further methods on the object until it drops the reference to the data that was returned from this method. 
This is a great pattern for simple accessors that would not be safe in Java because they would be exposing the internal 
state of the class and potentially violating it's invariants. While it may not always be a good idea to expose internal 
representation, this provides a way to do it safely that does not violate the integrity of class, and still allows the 
implementation to change in the future. (It can always construct the returned object if needed)</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

trait Config {
  //...
  fn set_attributes(&amp;mut self, attributes: HashMap&lt;String, String&gt;);
  //...
}
<span class="boring">}
</span></code></pre></pre>
<p>here the <code>set_attributes</code> function is making explicit that when called it is now the owner of the provided <code>attributes</code> 
and the caller no longer has any references to it. In Java would be dangerous. Usually to prevent this a defensive copy 
is made. However this comes at a performance cost. To avoid this sometimes Java programs just skip it because the transfer 
of ownership is understood and users know not to do this. For example when inserting an object into a HashSet, it is understood 
that you should not modify the object afterwards. But nothing actually prevents this. </p>
<p>TODO:</p>
<ul>
<li>Similar pattern getting an entry by key and doing .or_insert() += 1. </li>
</ul>
<p>The rules for ownership and borrowing are straight forward: __</p>
<p>...</p>
<p>There are more exotic ways to handle objects then in general aren't really needed the overwhelming majority of the time. 
These include RC (which allows ambiguous ownership where the item is dropped when all references go away.) 
ARC which is similar, but thread safe. This is generally used for Top-level classes with business logic that may need to 
be referenced from multiple places and live for a long time.</p>
<p>All of these compile time rules can be broken by declaring code ‘unsafe’ but you shouldn’t go around do that, 
because it will mean the compiler won’t be able to protect you. Instead the pattern in Rust is to use ‘unsafe’ to build a 
small generic primitive which is itself safe but is for reasons that the compiler doesn’t understand. Then depend on that
component where you need it. There are many such components publicly available, and we’ll cover some of them in depth 
in this book. A short list of common ones is below __</p>
<ul>
<li>
<p>SplitAtMut</p>
</li>
<li>
<p>Cell</p>
</li>
<li>
<p>RefCell</p>
</li>
<li>
<p>Rc/Arc</p>
</li>
<li>
<p>Cell provides internal mutability. Ie you can change data when immutable, but only behind an interface.</p>
<ul>
<li>Can't violate normal immutability rules, because cell requires ownership.</li>
<li>Can't violate normal borrowing rules either.</li>
<li>Cell forbids references to its contents.</li>
<li>Things containing cells are not allowed to cross thread boundaries</li>
<li>When you see realize the field is mutable, and can change between times you use it.</li>
</ul>
</li>
<li>
<p>RefCell allows in stead or replacing a value to change it like cell the ability to borrow and mutable borrow the contents.</p>
<ul>
<li>like cell, can't use to violate normal parameter guarantees</li>
<li>Can't cross thread boundaries.</li>
<li>Still safe. Single writer of multiple readers enforced at runtime.</li>
</ul>
</li>
</ul>
<p>‘Cell’ is a class included in the standard library. It allows the value it is wrapping to be replaced. So you can write a struct like this __ and then modify that field it in a function that only has an immutable borrow like this __. This circumvents the normal mutability rules, and as such the compiler will not allow types using ‘Cells’ to cross thread boundaries. Similarly there a type ‘RefCell’ that allows the value to be modified (as opposed to replaced). __ Here a hashmap is being defined that can be updated by a function that only has a _. ‘RefCell’ does not actually abandon safety all together. While you can get a mutable reference out of an immutable object like so __ it actually just moves the safety check from compile time to runtime. So if your code actually does something bad, like attempts to get two mutable references at the same time, it will panic. <It is still correct if you have full unit test coverage></p>
<ul>
<li>Ref and RefMut are returned. These act as a lifetime tracker which allows the enforcement of one writer at a time.</li>
</ul>
<p>In general using ‘cell’ or ‘RefCell’ a lot is considered bad design. ‘Cell’ and ‘RefCell’ should be reserved for special cases that don’t impact the externally visible functionality. For example they provide a easy way to add things like counters, metrics, debugging information to an existing object without having to refactor all the code that is accessing it. Similarly they are frequently used when constructing Mock objects for test purposes. (The actual code may be accessing the object in a ‘read-only’ way, but the mock still may want to record what calls have occured) </p>
<p>Reference cycles and ambiguous ownership is an anti-pattern in Java, and a really really aggressively discouraged anti-pattern in Rust. But one place it tends to get asked about a lot is doing GUI programing. For example when rendering a window with many widgets it is easy to jump to the conclusion that links are needed between all sorts of objects as changes to one may involve changes to another. This generally arises from the false belief that objects in an object oriented system should be directly modeled after real life objects. often this is not the case because concerns are cross-cutting. If you're writing code in Rust this pattern will fail faster. While this might be frustrating to the author it's actually good because it prevents you from writing bad code. There are actually a lot of good talks on this subject, such as <em>ECS at rustconf</em> and <em>xi-GUI</em>. I'm not going to go into the details here because these problems are application specific. However if you find yourself fighting the borrow checker or tempted to use unsafe or RefCell all over the place, it’s probably worth taking a step back and re evaluating the broader design. …….. data oriented design.</p>
<h1><a class="header" href="#returning-borrowed-values" id="returning-borrowed-values">Returning borrowed values</a></h1>
<p>Borrowing is not just for parameters, it is also for returned values. 
The simplest case is where the returned value is derived from an input parameter. 
For example:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo { bar: Bar }
</span><span class="boring">struct Bar {}
</span>fn get_bar(foo: &amp;Foo) -&gt; &amp;Bar {
    &amp;foo.bar
}
<span class="boring">}
</span></code></pre></pre>
<p>Another case is where the value being returned comes from 'self’ and is being lent to the caller. For example:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Bar {}
</span>struct Foo { 
    bar: Bar 
}
impl Foo {
    fn get_bar(&amp;self) -&gt; &amp;Bar {
        &amp;self.bar
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In both these cases the caller is bound by the contract of borrowing, exactly the same as though it were provided as an input parameter.
If it helps, imagine the rest of the function were factored out into a private method and had the result as a borrowed parameter. For example:</p>
<table width="100%">
<tr>
<td>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo { bar: Bar }
</span><span class="boring">struct Bar {}
</span>impl Foo {
    fn get_bar(&amp;self) -&gt; &amp;Bar {
       &amp;self.bar
    }
}
fn process_foo(foo: &amp;Foo) {
    let bar = foo.get_bar();
    process_bar(bar);
}
<span class="boring">}
</span></code></pre></pre>
</td>
<td>
<p>This is equivalent to:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo { bar: Bar }
</span><span class="boring">struct Bar {}
</span>fn process_foo(foo: &amp;Foo) {
    process_bar(&amp;foo.bar);
}
<span class="boring">}
</span></code></pre></pre>
</td>
</tr>
</table>
<p>When returning borrowed values it is occasionally ambiguous where the returned value came from. 99% of the time the compiler will work it out automatically. But sometimes there are cases that aren't so clear. 
For example here the compiler won't be able to work it out, because it only looks at one method at a time. </p>
<pre><code class="language-rust ignore">fn function_with_two_inputs(arg1: &amp;Something, arg2: &amp;SomethingElse) -&gt; &amp;Output {
    //...
}
</code></pre>
<p>In such a case you can label your inputs. Like so:</p>
<pre><code class="language-rust ignore"><span class="boring">struct Something();
</span><span class="boring">struct SomethingElse();
</span><span class="boring">struct Output();
</span>fn function_with_two_inputs(arg1: &amp;'a Something, arg2: &amp;'b SomethingElse) -&gt; &amp;'a Output {
    //...
}
</code></pre>
<p>(Usually 'a, 'b, 'c, etc are used.) And the apply the same label to the output. In this case it is indicating that the output is derived from the first input and not the second.
So it is explicit which input you intend the output to have come from. (The compiler will still check to make sure the labels are correct.)</p>
<p>This also happens to be the same syntax that you would use to label loops for the <code>break</code> and <code>continue</code> keywords, which work similar to Java:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Item();
</span><span class="boring">fn is_bad(item: &amp;Item) -&gt; bool { true }
</span>fn labeled_loops(collection: &amp;Vec&lt;Vec&lt;Item&gt;&gt;) -&gt; bool {
    'outer: for group in collection {
        'inner: for item in group {
            if (is_bad(item)) {
                break 'outer;     
            }
            //...
        }
        //...
    }
    return false;
}
<span class="boring">}
</span></code></pre></pre>
<p>In the above case the thing being labeled is the loop. In the first case the thing being labeled is the <code>lifetime</code> of the borrow.
It is also possible to have a generic lifetime. This is useful for cases where which parameter a returned value is derived from
is not known at compile time. For example:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>///Returns the longer of two strings.
fn get_longer&lt;'a&gt;(a: &amp;'a str, b: &amp;'a str) -&gt; &amp;'a str {
    if a.len() &gt; b.len() {
        a
    } else {
        b
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#pass-by-value-vs-pass-by-reference" id="pass-by-value-vs-pass-by-reference">Pass by value vs Pass by reference</a></h1>
<p>Similar to Java, Rust's function calls are normally “pass by reference” meaning that if you pass an object to a function and modify it the caller will see those modifications. However also like Java, primitives are an exception to this and are “pass by value”. Meaning if you pass an integer to a function and it increments it. The caller will not see the change.</p>
<p>In Java this is just a hardcoded rule and only primitives are copied. In Rust you can define your own types that are treated this way by having them implement “Copy” which is what is called a “marker trait”. It is similar an interface with no methods in Java indicating something about a class. (Like ‘Cloneable’ or ‘Serializable’)</p>
<h1><a class="header" href="#todo" id="todo">TODO</a></h1>
<ul>
<li>String types (mutability, borrowing, assignment as move)
<ul>
<li>String concatenation
<ul>
<li>Format! In example</li>
</ul>
</li>
<li>Stringbuilder</li>
<li>In Java Strings are Immutable, and a primitive. You might not think about it too much but this is an essential language feature. If Java hadn’t provided a single standard String implementation in the standard library, or if they had chosen to make it mutable it would be very difficult to work in the language. Imagine if every time you passed a string into a method you had to make a defensive copy or carefully check the method’s Javadocs to make sure it doesn’t modify the string. So it might seem surprising that Rust went into a different direction. However there is a very simple reason for this, Rust’s methods always declare if they need to modify the value being passed. __. Similarly the caller has to explicitly pass either a mutable or immutable reference or slice of the string. So there is no ambiguity. A function can never pass a string somewhere and have it unexpectedly modified. </li>
</ul>
</li>
<li>Fixed size arrays</li>
<li>Byte array and ByteBuffer</li>
<li>Vec and arraylist
<ul>
<li>Strings are actually Vecs of UTF-8 characters/bytes</li>
</ul>
</li>
<li>Raw strings for multi line constants</li>
<li>Slices
<ul>
<li>Str is a slice of a String (get it?)</li>
<li>Should be after indexes and range traits are introduced (Operator overloading)</li>
<li>A slice of a vec is an array
<ul>
<li>Made possible by ownership</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#objects" id="objects">Objects</a></h1>
<ul>
<li>Members 
<ul>
<li>Constants</li>
</ul>
</li>
<li>Methods
<ul>
<li>Functions vs methods (implicit borrows)</li>
</ul>
</li>
<li>Visibility</li>
<li>Static methods</li>
<li>Constructors
<ul>
<li>Like Java, you can never have a partially constructed / uninitialized object</li>
<li>Can return a different object from “new” this is useful for having things like a builder.</li>
<li>From_ naming convention for constructors </li>
</ul>
</li>
<li>Traits vs Interfaces
<ul>
<li>Drop vs TryWith object vs finalizer</li>
</ul>
</li>
<li>Add methods outside</li>
<li>Difference between impl foo for bar vs impl&lt;t:bar&gt; foo for t
<ul>
<li>Impl foo is a trait it just doesn't have a name.</li>
</ul>
</li>
<li>Traits and emulate overloading but in an extensible way</li>
<li>Use types to provide static distinctions (because types have no overhead)</li>
<li>Common traits
<ul>
<li>convert</li>
<li>copy</li>
<li>AsRef / asMut</li>
<li>From / tryfrom  /  Into / tryInto
<ul>
<li>Major advantage is don’t need to actually know type.</li>
<li>Automatically mirror one another so don’t need to specify in two locations.</li>
<li>Types automatically convert to themselves.</li>
<li>Great example of generic implementations as your code can benefit from methods you did not write.</li>
<li>Orphan rules mean you can only implement one.</li>
<li>Notice that into() can just be invoked and it figures out which method to call based on what the return type is.
<ul>
<li>This is much more powerful than Java’s method overloading because you cannot have identical signatures do different things. </li>
</ul>
</li>
</ul>
</li>
<li>fromString</li>
<li>Debug (always implement) </li>
<li>Partial order</li>
<li>Hash</li>
<li>Display</li>
<li>Error</li>
<li>Default</li>
<li>Autotraits: sync, send, sized, ?sized</li>
</ul>
</li>
<li>Almost all of these are written in standard rust. Including thing like iterator which will be covered in the next chapter. These automatically add a LOT of premade functions for your custom made types that you don’t have to write. For the traits supporting #derive this is even easier, because you don’t even have to do anything besides type the name. Even more importantly because everything is just standard rust, and there are no special hooks in the compiler for any of these types. This means in your own code you can build abstractions that are just as powerful. <Even better this is all done at compile time so there is no overhead></li>
</ul>
<p>The in Java methods have access to an implicit variable ‘this’ which is the object on which the method was invoked. 
In Rust ‘this’ is called ‘self’ and is explicetly declared. </p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Dummy {
</span>fn run(self: Self);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><code>self</code> is always of the type <code>Self</code> which is an alias for the name of the object's type. However because <code>self</code> cannot have any other type
this can be abriviated as:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Dummy {
</span>fn run(self);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>In Java there are methods declared with the keyword ‘static’ which do not have access to ‘this’ because they are not associated with any 
particular instance. In Rust the ‘self’ parameter is explicitly declared as the first argument to a method. 
Leaving it out is analogous to declaring a method ‘static’ in Java. 
Similar to Java such a method is invoked from the type itself. The following functions are equivalent </p>
<pre><code class="language-java">    public static void println(String s) { /*...*/ }
</code></pre>
<p>and</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    pub fn println(s: &amp;String) { /*...*/ }
<span class="boring">}
</span></code></pre></pre>
<p>Rust is an Object Oriented language, but it is not a class oriented language. So unlike in Java not all of the methods on an object are located in the same block of code.</p>
<h1><a class="header" href="#traits" id="traits">Traits</a></h1>
<ul>
<li>Default methods</li>
<li>Traits can inherit</li>
<li>Associated types
<ul>
<li>Needs an example. (Specs does this)</li>
<li>Associated constants</li>
</ul>
</li>
<li>Marker traits. Like serializable in Java. Can be used to enforce certain semantics like that a particular behaviour / handling is desirable. 
<ul>
<li>Copy trait</li>
<li>Can also be made mutually exclusive which is useful for making the compiler enforce invariants. </li>
</ul>
</li>
</ul>
<p>Traits allow can have implementation methods on them like Java interfaces. For example __ is the same as __. Where the trait is defining the method _ but leaving the methods _ and _ up to the implementer of the trait.</p>
<p>Traits are a concept in Rust that are very similar to an interface in Java. The main difference being that by convention Traits tend to have very few methods, usually just one or two each. As such APIs tend to be a bit finer grained but you may deal with more of them.</p>
<h2><a class="header" href="#implementing-traits" id="implementing-traits">Implementing traits</a></h2>
<p>In Rust the implementation of traits is declared in a separate block from the declaration of the member variables. While this might seem strange coming from Java, it is actually a very important feature. Because methods are not located in the object itself the language doesn't need to distinguish between 'primitives’ and 'objects’ like Java. This is why Java needs Integer and int, Long and long, and Double and double. </p>
<p>So in Rust an i32 can be a key in a map without needing to be wrapped. This is also useful because they don't have to be in the same file. So you can for example declare a trait and the supply an implementation for an existing type. For example here is a trait for objects that can be doubled:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Doubleable {
  fn double(self : Self) -&gt; Self;
}

// And we can implement this for i32:

impl Doubleable for i32 {
  fn double(self : i32) -&gt; i32 {
    2 * self
  }
}

// And now we can invoke this like any other method:
assert_eq!(10, 5.double());
<span class="boring">}
</span></code></pre></pre>
<p>It's worth noting that there is never any ambiguity about where the implementation of a particular trait is. This is because it is only allowed to be in one of two places, where the trait is defined or where the type is defined. Because circular dependencies are not allowed and the definition will need to depend on both, the one that depends on the other must contain the implementation. This is referred to as “the orphan rule”. It appears in couple of places, aside from making method calls unambiguous, it also ensures things work as you might intuitively expect and means that unlike some languages (<em>ahem</em> Scalla) the behavior of code can't be altered simply by adding an import statement.</p>
<h2><a class="header" href="#overloading" id="overloading">Overloading</a></h2>
<p>Java has method overloading which works like this:</p>
<pre><code class="language-java">class Processor {
  public void process(Foo item) {
    //...
  }
  public void process(Bar item) {
    //...
  }
}
</code></pre>
<p>in Rust the equivlent would be:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod processor {
<span class="boring">struct Foo; struct Bar;
</span>  struct Processor;
  trait Process&lt;Item&gt; {
    fn process(&amp;self, item : Item);  
  }
  impl Process&lt;Foo&gt; for Processor {
    fn process(&amp;self, item : Foo) {
     //...
    }
  }
  impl Process&lt;Bar&gt; for Processor {
    fn process(&amp;self, item : Bar) {
      //...
   }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>In Rust the methods are defined on the impl of the traits. This might seem a bit verbose, but traits are more powerful than simple overloading that you can do in Java. It also has the advantage that the implementations don't need to be located where <code>Processor</code> is declared. A new type can add it's own overload and implement it by for example by delegating to an existing implementation. Additionally in Rust you can overload functions with identical signatures or that differ by only a generic or a return type. each of those is associated with a trait. In Java you can never implement the same interface for two different generic types. For example:</p>
<pre><code class="language-java">class Processor {
  void processList(List&lt;Foo&gt; items);
  void processList(List&lt;Bar&gt; items); //Ooops..
}
</code></pre>
<p>Where as rust can just add:</p>
<pre><code class="language-rust ignore">impl Process&lt;Vec&lt;Bar&gt; for Processor {
  fn process(&amp;self, item : Vec&lt;Bar&gt;) {
    //...
  }
}
impl Process&lt;Vec&lt;Foo&gt; for Processor {
  fn process(&amp;self, item : Vec&lt;Foo&gt;) {
    //...
  }
}
</code></pre>
<p>Instead you have to overload the methods. This means the same class cannot implement an interface for multiple types.</p>
<pre><code class="language-java">class FastProcessor implements Processor&lt;Foo&gt;, Processor&lt;Bar&gt; { //Oops not allowed...
  //...
}
</code></pre>
<p>This of course destroys code reusability and prevents you from using interfaces as a means of abstraction because you are always coding to the impl. In Rust the interface is mandatory, which makes it easy to extend in the future and forces you think about the generalization. For example here is some code I wrote in Java __. Notice the overloaded method. In Rust I would have to create an interface that defines what I want. In this case _. This is already a common pattern so I can just use _. Then I can generalize my implementation by writing __. Now not only can I overload this method by adding more implementations, but my callers can too! All they have to do is implement _ like so __.</p>
<h2><a class="header" href="#the-visitor-pattern-is-a-hack" id="the-visitor-pattern-is-a-hack">The visitor pattern is a hack</a></h2>
<p>Java uses overloading to have a single method that can work for multiple different types. However Java also has what is called “single dispatch”. This means if you want a function to work generically for all implementations of a given interface but a different function for each one, you need to use the Visitor pattern:</p>
<pre><code class="language-java">class Processor {
  public void process(Foo item) {
    //...
  }
  public void process(Bar item) {
    //...
  }
}
interface Processable {
  public void process(Processor processor);
}
class Foo implements Processable {
  public void process(Processor processor) {
    processor.process(this);
  }
}
class Bar implements Processable {
  public void process(Processor processor) {
    processor.process(this);
  }
}

Processor processor = //...
List&lt;? extends Processable&gt; items = //...
for (Processable item : items) {
  // This will invoke the overloaded Processor.process(item) with the correct type.
  item.process(processor); 
}
</code></pre>
<p>You’ve probably written code like that a few times, and it generally works. It's certainly better than a single function with a large switch statement. But it still involves a lot of boilerplate code because each impl needs to write the visit function.
This is even more problematic if you don't own they types that need to implement visit() because then you can't write such a method. So your back to either writing a lot of conditional logic in a large function to sort them out, or you have to wrap the types with your own type.</p>
<p>In Rust none of that would be needed. You can add an implementation of an trait that is type specific. </p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>mod processor {
<span class="boring">pub struct Foo; pub struct Bar;
</span>  pub struct Processor {
    //...
  }
  pub trait Processable {
    fn process(&amp;self, processor : &amp;Processor);  
  }
  impl Processable for Foo {
    fn process(&amp;self, processor : &amp;Processor) {
      //...
    }
  }
  impl Processable for Bar {
    fn process(&amp;self, processor : &amp;Processor) {
      //...
    }
  }
}
//...
use crate::processor::*;
pub fn main() {
  let p : Processor = //...
<span class="boring">Processor {};
</span>  let items : Vec&lt;Box&lt;dyn Processable&gt;&gt; = //...
<span class="boring">vec![];
</span>  for item in items {
    item.process(&amp;p);
  }
}
</code></pre></pre>
<p>In the above example notice the <code>Box&lt;dyn Processable&gt;</code>. <code>dyn</code> is equivlent to the <code>? extends</code> in Java example above. It indicates there is more than one implementation. IE: the type is dynamic and the actual implementation won't be known until runtime. The box is actige as a 'fixed size container' so that the itmes in <code>Vec</code> can all be the same size. </p>
<p>In Java this &quot;boxing&quot; is done for all collections all the time, which is why primitives can't be placed in them. There is syntatic sugar for this called &quot;autoboxing&quot; which converts <code>int</code> into <code>Integer</code>. In Rust boxing is explicet.</p>
<h1><a class="header" href="#an-example" id="an-example">An example</a></h1>
<p>Often classes are implemented with multiple traits. For example, Java's UUID class would be in a file named UUID.java and look like this:</p>
<pre><code class="language-java">import java.util.Random;

public final class UUID implements Serializable, Comparable&lt;UUID&gt; {}
  private static final long serialVersionUID = -4856846361193249489L;

  private long mostSigBits;

  private long leastSigBits;

  public UUID(long mostSigBits, long leastSigBits) {
    this.mostSigBits = mostSigBits;
    this.leastSigBits = leastSigBits;
  }
  
  public int compareTo(UUID o) {
    //...
  }
  public boolean equals(Object obj) {
    //...
  }
  public int hashCode() {
    //...
  }
  public String toString() {
    //...
  }
  public static UUID fromString(String name) {
    //...
  }
  public static UUID randomUUID() {
    //...
  }
}
</code></pre>
<p>In Rust the equivalent would be in a file named UUID.rs and look like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::u64; 
use std::str::FromStr;
use serde_derive::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]
struct UUID {
  most_sig_bits: u64,
  least_sig_bits: u64,
}
impl UUID {
  fn new(most_sig_bits: u64, least_sig_bits: u64) -&gt; UUID {
    UUID{ most_sig_bits: most_sig_bits, least_sig_bits: least_sig_bits }
  }
  fn random() -&gt; UUID {
    UUID{ most_sig_bits: rand::random(), least_sig_bits: rand::random() }
  }
}

impl FromStr for UUID {
    type Err = String;
    fn from_str(as_string: &amp;str) -&gt; Result&lt;UUID, String&gt; {
        unimplemented!(&quot;Todo: implement this&quot;) 
    }
}
impl ToString for UUID {
    fn to_string(&amp;self) -&gt; String {
      &quot;Todo: implement this&quot;.to_string()
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>The major difference between the Java version and the Rust version is that instead of being in a single <code>class</code> block where as the Rust implementation is split into three a <code>struct</code> block which contains the fields, an <code>impl</code> block which contains all of the class speffic methods, and separate <code>impl</code> blocks for each of the different traits that are implemented. </p>
<p>In the Java case, there are two interfaces implemented <code>Serializable</code> and <code>Comparable</code>, where as <code>equals</code>, <code>hashCode</code>, and <code>toString</code> aren't interfaces, but rather are inherited from Object. Rust breaks things down a little more finely. Some of the <code>Serialize</code> and <code>Deserialize</code> are split into separate traits. In this case they appear in the <code>derive</code> &quot;attribute&quot;. An attribute is like a Java annotation. <code>derive</code> Automatically generates boilerplate implementations of common traits. In addition to these <code>Eq</code> is the analogous trait for <code>equals</code>, <code>hash</code> provides <code>hashCode</code>. In addition to these <code>PartialEq</code> and <code>PartialOrd</code> provide the equivlent of <code>equals</code> and <code>Comparable</code> without the requirement that all instances be differentiated. IE: Unlike <code>eq</code> if two instances can have member variable that is different but they are still considered the same for the purposes of equality, or in the case of <code>PartialOrd</code> unlike <code>Ord</code> there can be instances that can't be compared such as a floating point NaN. <code>Debug</code> is a trait to print a string representation for the purposes for debugging much like Java's <code>toString</code>. The traits <code>From</code> and <code>Into</code> are common traits for converting between different types. In this case if fills the same role as <code>fromString</code> implementatation in Java.</p>
<h2><a class="header" href="#patterns" id="patterns">Patterns</a></h2>
<p>Because traits tend to be small and only have a few methods it's more common in Rust to have a parameter that implements multiple of them. To pick a simple class to see how this works in practice let's compare Java's <code>AtomicBoolean</code> to Rust's <code>AtomicBool</code></p>
<table><thead><tr><th>Attribute</th><th align="right">          Java's AtomicBoolean</th><th align="right">             Rust's AtomicBool</th></tr></thead><tbody>
<tr><td>Total lines</td><td align="right">359</td><td align="right">532</td></tr>
<tr><td>Lines of docs</td><td align="right">172</td><td align="right">361</td></tr>
<tr><td>Lines of code</td><td align="right">72</td><td align="right">63</td></tr>
<tr><td>Public methods</td><td align="right">20</td><td align="right">14</td></tr>
<tr><td>Interfaces/traits implemented</td><td align="right">1</td><td align="right">5</td></tr>
<tr><td>Additional traits automatically implemented because they were defined elsewhere</td><td align="right">n/a</td><td align="right">8</td></tr>
<tr><td>Total methods invokable</td><td align="right">20</td><td align="right">32</td></tr>
</tbody></table>
<p>So while the actual implementations are very similar (There are only so may ways to implement an atomic boolean and only so many things you can do with it), a large chunk of the Rust implementation came 'for free' to the author of <code>AtomicBool</code> bacause 18 of the 32 methods were implemented Automatically by virtue of other traits/methods that were defined. In addition to this other developers can add their own interfaces and implementations. For example, the one interface Java's <code>AtomicBoolean</code> implements is <code>Serializeable</code>. In Rust, the dependency goes in other direction. <code>AtomicBool</code> is a basic type and the author of the serialization can provide their implementation for serializing it. So any code that depends on both serialization and on atomicBoolean will see even more methods (those implemneted by the author of serialization, as well as any further traits it gets 'for free' because of the ones it now implementes).</p>
<p>As a result, it really pays to keep your own traits small and focused, and aggressivly implement common traits for your types.</p>
<h2><a class="header" href="#common-traits" id="common-traits">Common Traits</a></h2>
<p>This fine grained declaration of traits allows for greater code reuse. For example below is a table of common traits</p>
<table><thead><tr><th align="left">Trait</th><th>Similar Java method</th><th>Description</th></tr></thead><tbody>
<tr><td align="left">PartialEq</td><td>Object.equals</td><td>Defines if two instaces are semantically equal.</td></tr>
<tr><td align="left">Eq</td><td>Object.equals</td><td>Defines if two instance are equal and can differentiate between all instances</td></tr>
<tr><td align="left">PartialOrd</td><td>Comparable.compareTo</td><td>Defines &gt;, &gt;=, &lt;, and &lt;= operators</td></tr>
<tr><td align="left">Ord</td><td>Comparable.compareTo</td><td>Defines ordering, and can order all unique instances</td></tr>
<tr><td align="left">Index</td><td>List.get or [x] operators</td><td>Defines indexing IE: [x] much like a Java array</td></tr>
<tr><td align="left">IntoIterator</td><td>Iterable.iterator</td><td>Defines a method to construct an iterator</td></tr>
<tr><td align="left">Iterator</td><td>Iterator</td><td>Allows iterating over a collection</td></tr>
<tr><td align="left">Debug</td><td>Object.toString</td><td>Creates a string representation of an object for debugging</td></tr>
<tr><td align="left">Display</td><td>Object.toString</td><td>Creates a human readable representation of an object</td></tr>
<tr><td align="left">From</td><td>N/A</td><td>A generic conversion function to instantiate one type from another</td></tr>
<tr><td align="left">Into</td><td>N/A</td><td>A generic conversion function to convert one type into another</td></tr>
<tr><td align="left">Copy</td><td>Java primitives</td><td>A type that is &quot;passed by value&quot; meaning it is copied each time it is assigned to a new value</td></tr>
<tr><td align="left">Clone</td><td>Cloneable.clone</td><td>A function that makes a copy of an object</td></tr>
<tr><td align="left">FromStr</td><td>N/A</td><td>Constructs an object from a string</td></tr>
<tr><td align="left">ToString</td><td>Object.toString</td><td>Converts an object into a string</td></tr>
<tr><td align="left">Default</td><td>A zero argument constructor</td><td>Instantiates a default version of an object</td></tr>
<tr><td align="left">Error</td><td>Exception</td><td>An exeption</td></tr>
<tr><td align="left">Hash</td><td>Object.hashCode</td><td>Used when storing an item in a HashMap or HashSet</td></tr>
<tr><td align="left">Optional</td><td>Optional</td><td>Either an item or <code>none</code> indicating its absence</td></tr>
</tbody></table>
<p>Each of these is small and easy to implement. Each one appears on a lot of types and is accepted in a lot of common functions. So each one a class can implement unlocks a lot of flexibility. See __ or __ or __ as there is a lot of functions built around iterators. This pattern holds generally in Rust. Classes are not monolithic. Instead they have many small components that hook into each other to provide greater code reuse. </p>
<h1><a class="header" href="#generics-aka-type-parameters" id="generics-aka-type-parameters">Generics (aka Type parameters)</a></h1>
<p>Non-trivial example to show assignment + use</p>
<ul>
<li>Strongly Prefer associated types on traits
<ul>
<li>Better declaration syntax with multiple values</li>
<li>Real name for type</li>
<li>Named when used so more clear what is what vs order</li>
<li>No call site turbofish</li>
<li>Allows certain patterns, like continuation token. (Doesn't go up the stack)</li>
<li>Makes faster code (one impl, static dispatch)</li>
<li>It avoids “generics hell”</li>
<li>If you are the one implementing the trait, you can add new types without breaking users</li>
<li>Can also have default.</li>
<li>Does not work for things like Add where you want many impls depending on both Lhs and rhs</li>
<li>Only case for normal generic is for overloading</li>
</ul>
</li>
<li>Conditional trait implementation</li>
<li>Traits with methods contingent of a generic implementing a specific trait.
<ul>
<li>IE: cell has take if T is default or get if T is copy. Or a wrapper implements order if the thing it wraps does.</li>
</ul>
</li>
<li>Syntax for ‘where’ vs ‘:’ (also ‘+’)</li>
<li>Generics + Builders</li>
<li>Self type 
<ul>
<li>Can return an newly created instance of a generic type. (collect on iterator)</li>
</ul>
</li>
<li>Generics and dyn</li>
<li>static vs dynamic dispatch
<ul>
<li>Dyn keyword</li>
</ul>
</li>
</ul>
<p>Rust generics look a lot like Javas. When declared on a type:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::marker::PhantomData;
</span>pub struct LinkedList&lt;T&gt; {
  //...
<span class="boring">not_implemented : PhantomData&lt;T&gt;,
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>When instantiated:</p>
<pre><code class="language-rust ignore">let connection : HashMap&lt;String, TcpStream&gt; = //...
</code></pre>
<p>When in a function signature:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
pub fn lookup_emojis(characters : Vec&lt;&amp;str&gt;) -&gt; HashMap&lt;&amp;str, &amp;str&gt; {
  //...
<span class="boring">HashMap::new()
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>The biggest difference is that Rust calls them &quot;Type Parameters&quot;. <a href="https://bluejekyll.github.io/blog/rust/2017/08/06/type-parameters.html">Just as a function may take various parameters, it can
also take a parameter which is a type.</a></p>
<p>Below are some additional examples:
TODO:</p>
<ul>
<li>Functions</li>
<li>In structs</li>
<li>In traits</li>
<li>Defaults</li>
<li>Associated types - FromStr provides a good example. </li>
</ul>
<h2><a class="header" href="#type-inference" id="type-inference">Type Inference</a></h2>
<p>Rust also has some shortcuts to make things easier. For example a type can be declared like this:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn get_items() -&gt; Vec&lt;String&gt; {
  vec![&quot;Hello&quot;.to_string()] 
}
let to_print : Vec&lt;_&gt; = get_items();
<span class="boring">}
</span></code></pre></pre>
<p>Here the character ‘_’ tells the compiler “You figure out what's supposed to go here, I'm not going to bother to type it.”. This allows you to specify a type, while still allowing the generics to be infered. This works and can be used any place where the compiler has enough content to work out the generic value.</p>
<h2><a class="header" href="#bounds" id="bounds">Bounds</a></h2>
<p>In java you might write a function that looks like this:</p>
<pre><code class="language-java">public static void &lt;T extends Comparable&lt;T&gt;&gt; sort(List&lt;T&gt; toSort) {
  //...
}
</code></pre>
<p>Here the <code>entends</code> keyword is used to specify that the geric type <code>T</code> is must satisfy the &quot;bounds&quot; of Implementing <code>Comparable&lt;T&gt;</code>.
The same function in Rust would look like this:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn sort&lt;T : Ord&gt;(to_sort : &amp;mut Vec&lt;T&gt;) {
  //...
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>:</code> takes the place of &quot;extends&quot;. <code>Ord</code> is a trait that allows items to be ordered similar to <code>Comparable</code> in Java.</p>
<p>You may be wondering, &quot;Why doesn't Ord take a generic parameter?&quot;. After all <code>Comparable</code> in Java needs one because the interface is not specific to one implementation, and needs to refer to the same type. This is due to another feature, the &quot;Self&quot; type. </p>
<p>If you'll recall, when we define a method on an object we write:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Foo;
impl Foo {
  fn bar(&amp;self) {
    //...
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Where the 'self' variable is a way to pass the equivlent of &quot;this&quot; in Java. Well that's actually just shorthand for:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Foo;
impl Foo {
  fn bar(self : &amp;Self) {
    //...
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>Where <code>Self</code> is the type of the object. This isn't useful on an impl because you know the type, but on an interface it can be. For example you can define something like this:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Doubleable {
  fn double(self) -&gt; Self;
}
impl Doubleable for i32 {
  fn double(self) -&gt; Self {
    self * 2
  }
}
//then this method can be invoked
assert_eq!(4, 2.double());
<span class="boring">}
</span></code></pre></pre>
<p>So the <code>Self</code> type allows the trait to refer to whatever is implementing the interface without actually knowing what that is or having to have a generic itself.</p>
<h2><a class="header" href="#features-unique-to-rust" id="features-unique-to-rust">Features unique to Rust</a></h2>
<p>Rust also has a few other features that help avoid so called &quot;generics hell&quot; that sometimes crops up in Java. </p>
<ul>
<li>Rust avoids generics hell
<ul>
<li>Ownership and borrowing save the day</li>
<li>https://doc.rust-lang.org/nomicon/subtyping.html </li>
</ul>
</li>
</ul>
<h3><a class="header" href="#where-clauses" id="where-clauses">Where clauses</a></h3>
<p>A simple one is &quot;where&quot; clauses. Suppose you had an interface like this:</p>
<pre><code class="language-java">public &lt;T extends Comparable&lt;T&gt;, ProcT extends Serializable, Processor&lt;T&gt;&gt; byte[] serializeMaximumValue(List&lt;T&gt;, ProcT processor);
</code></pre>
<p>You could just do the same thing in Rust:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">//Normally Serialize is imported as: use serde::Serialize;
</span><span class="boring">pub trait Serialize {}
</span>pub fn serialize_max_value&lt;T : Ord, ProcT : Proc&lt;T&gt; + Serialize&gt;(items : Vec&lt;T&gt;, processor : ProcT) -&gt; Vec&lt;u8&gt; {
  //...
<span class="boring">vec![]
</span>}
<span class="boring">pub trait Proc&lt;T&gt; {
</span><span class="boring"> fn do_something(item : T);
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>The problem with this in both Rust and java is the generics really get in the way and make the function signature hard to read. So it's easier to use the <code>where</code> keyword to move these bounds over to the right, so they can be wrapped onto the following lines:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">//Normally Serialize is imported as: use serde::Serialize;
</span><span class="boring">pub trait Serialize {}
</span>pub fn serialize_max_value&lt;T, ProcT&gt;(items : Vec&lt;T&gt;, processor : ProcT) -&gt; Vec&lt;u8&gt; where
 T : Ord,
 ProcT : Proc&lt;T&gt; + Serialize {
  //...
<span class="boring">vec![]
</span>}
<span class="boring">pub trait Proc&lt;T&gt; {
</span><span class="boring"> fn do_something(item : T);
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>This is strictly equivlent, but hopefully easier to read.</p>
<h3><a class="header" href="#impl-keyword" id="impl-keyword">Impl keyword</a></h3>
<p>In the case of a single trait/interface. In Java you might write __ where 'T extends’ is used to indicate there is some type T but the function doesn't care about the exact type of the object, provided it implements the specified interface. In Rust there is a shorthand for this using the 'impl’ keyword. __. This is most commonly used for return values for example __ specifies that this function is returning a _ but without providing the exact type. This is especially common when a function is returning a function. (Like a callback for example) __ here the function is specifying that it is returning a function with a particular signature but without specifying exactly which function it is returning. So you can think of impl as meaning “some implementation of this trait”. (It doesn't matter which) ‘impl’ only can refer to one trait. So if you need to use multiple, you'll have to use a where clause _ or an alias _.</p>
<table width="100%">
<tr>
<td>
<p><img src="images/professor.png" alt="Optimizer" /></p>
</td>
<td width="80%">
<blockquote>
<p><em>I can actually make methods invoked on an ‘impl’ parameter a lot faster. So take advantage of that.</em></p>
</td>
</blockquote>
</tr>
</table>
<h3><a class="header" href="#associated-types" id="associated-types">Associated Types</a></h3>
<p>Finally there is one feature that cuts down on the burdon of generics a lot: &quot;Associated types&quot;. In Java the Supplier interface is defined as:</p>
<pre><code class="language-java">interface Supplier&lt;T&gt; {
  public T get();
}
</code></pre>
<p>To do the same thing in Rust, you could write:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Supplier&lt;T&gt; {
  fn get(&amp;self) -&gt; T;
}
<span class="boring">}
</span></code></pre></pre>
<p>Or you could instead write:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Supplier {
  type Item;
  fn get(&amp;self) -&gt; Self::Item;
}
<span class="boring">}
</span></code></pre></pre>
<p>Here <code>type</code> is a keyword, and <code>Item</code> is the name of the generic type rather than <code>T</code>.
This has a few advantages. First it allows the generics to be specified by name, rather than relying on order: </p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Supplier {
</span><span class="boring">type Item;
</span><span class="boring">fn get(&amp;self) -&gt; Self::Item;
</span><span class="boring">}
</span>struct StringWrapper(String);
impl Supplier for StringWrapper {
  type Item = String;

  fn get(&amp;self) -&gt; String {
    self.0.clone()
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>This can segnifigantly improve readability when there are multiple types. It also allows the type to be refered to without specifying the type. For example:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Countable {
    fn count(self) -&gt; i32;
}
impl&lt;T&gt; Countable for T where T:Iterator {
    fn count(self) -&gt; i32 {
        let mut count = 0;
        for value in self {
            count += 1;
        }
        count
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here <code>Iterator</code> is refered to without needing to specify the generic associated with Iterator. This means that Countable does not itself have to be generic even though it operates on things that are. In the above code, they type of <code>value</code> is <code>T::Item</code>. A similar example using the supplier interface defined above would look like:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Supplier {
  type Item;
  fn get(&amp;self) -&gt; Self::Item;
}
//...
fn vec_of_value&lt;S:Supplier&gt;(supplier : &amp;S) -&gt; Vec&lt;S::Item&gt; {
  vec![supplier.get()]
}
<span class="boring">}
</span></code></pre></pre>
<p>In general the major difference between associated types and generics, is that for an associated type each implementation is tied to a speffic type. (For the language geeks this is called &quot;unicity&quot;.) For example If you were to define a concrete class <code>LinkedList</code> it should use generics because any sort of item should be able to go into one. However when defining a more general trait for example <code>Iterator</code> in that case it should use an associated type, because each implementation of iterator is only going to have one perticular type associated with it. Usually this is the type of whatever collection is implementing it, which of course itself is likely a generic. For example:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Storage {
  type Item;
  //...
  fn insert(&amp;self, item: Self::Item);
}
struct Message {/*...*/}
struct MessageStore {
  //...
}
impl Storage for MessageStore {
    type Item = Message;
    fn insert(&amp;self, item: Message) {
      //...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we have a <code>MessageStore</code> is tied to the type <code>Message</code> so it uses an associated type.</p>
<h1><a class="header" href="#collections" id="collections">Collections</a></h1>
<ul>
<li>Statically constructed collection</li>
<li>Collections of primitives
<ul>
<li>optimizer</li>
</ul>
</li>
<li>Box
<ul>
<li>Add to vec or hashmap to make heterogeneous</li>
<li>Dyn</li>
<li>Cheaper to move than a struct if the struct is large. So anything large should be heap allocated. (Most collections including String, Vec, HashMap etc already are, so usually not a big deal)</li>
</ul>
</li>
<li>Structs containing traits -&gt; box.
<ul>
<li>How ownership prevents generics hell</li>
</ul>
</li>
<li>Arc / Rc</li>
</ul>
<h2><a class="header" href="#common-collections-and-their-equivlents" id="common-collections-and-their-equivlents">Common collections and their equivlents</a></h2>
<table><thead><tr><th>Java Type</th><th>Rust Type</th><th>Notes</th></tr></thead><tbody>
<tr><td>ArrayDeque</td><td>VecDeque</td><td></td></tr>
<tr><td>ArrayList</td><td>Vec</td><td></td></tr>
<tr><td>BitSet</td><td>FixedBitSet</td><td>External crate. (Not in std lib)</td></tr>
<tr><td>HashMap / HashSet</td><td>HashMap / HashSet</td><td></td></tr>
<tr><td>LinkedHashMap / LinkedHashSet</td><td>IndexMap / IndexSet</td><td>External crate. (Not in std lib)</td></tr>
<tr><td>LinkedList</td><td>LinkedList</td><td>Use discoruaged</td></tr>
<tr><td>PriorityQueue</td><td>BinaryHeap</td><td></td></tr>
<tr><td>TreeMap</td><td>BTreeMap</td><td>Uses BTreee rather than Binary tree (Much faster)</td></tr>
<tr><td>TreeSet</td><td>BTreeSet</td><td>Uses BTreee rather than Binary tree (Much faster)</td></tr>
</tbody></table>
<h2><a class="header" href="#iterators" id="iterators">Iterators</a></h2>
<p>Rust's iterators are a bit different from Java's:</p>
<pre><code class="language-java">public interface Iterator&lt;E&gt; {
      /**
        * Returns {@code true} if the iteration has more elements.
        * (In other words, returns {@code true} if {@link #next} would
        * return an element rather than throwing an exception.)
        *
        * @return {@code true} if the iteration has more elements
        */
       boolean hasNext();
   
       /**
        * Returns the next element in the iteration.
        *
        * @return the next element in the iteration
        * @throws NoSuchElementException if the iteration has no more elements
        */
        E next();
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;
    /// Advances the iterator and returns the next value.
    ///
    /// Returns [`None`] when iteration is finished. Individual iterator
    /// implementations may choose to resume iteration, and so calling `next()`
    /// again may or may not eventually start returning [`Some(Item)`] again at some
    /// point.
    ///
    /// [`None`]: ../../std/option/enum.Option.html#variant.None
    /// [`Some(Item)`]: ../../std/option/enum.Option.html#variant.Some
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>This is both more continent for to implement, because the implementation does not need to know in advance if there is another item.
<code>Iterator</code> is also a very good example of the power of Rust's trait system. Implementing <code>Iterator</code> only requires writing one method
but it provides callers with over 60. This allows you to do things like:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashMap;
</span><span class="boring">use std::vec;
</span>let vec = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let map: HashMap&lt;i32, i32&gt; = (0..8).filter(|&amp;x| x%2 == 0).map(|x| (x, x * x)).collect();
<span class="boring">}
</span></code></pre></pre>
<p>(The <code>&amp;</code> in front of the <code>x</code> in the closure is an example of <a href="./enums.html#match">destructuring</a>, which is covered in the next chapter.)</p>
<p>In Java Streams and Iterators are different concepts defined by different interfaces. In the case of a stream the data is consumed
and it can not be re-read once it has been iterated over. Where as an iterator can always be re-created so the data can be read many times.
In Rust both of these concepts are unified into Iterator, with a different generic type. (Owned vs borrowed vales)</p>
<p>If the values being iterated over are borrowed then iterator works just like a java iterator. And the collection the was used to create
iterators over and over. However if instead of invoking <code>iter()</code> the method <code>into_iter()</code> is called, it will then return 
an iterator over owned values. </p>
<p>Because ownership is being transferred by definition the caller cannot hold onto to the collection or the values.
This means by in the iteration the collection will be consumed and there will be no way to iterator over the items again.</p>
<p>TODO:</p>
<ul>
<li>Adding close to iterators (not possible in Java) (can pass around in Rust)</li>
<li>Fail fast iterators vs compiler
<ul>
<li>Map.entry() example</li>
</ul>
</li>
<li>Splitting lists ranges</li>
<li>Java streams vs generators
<ul>
<li>Zip pair etc.</li>
<li>Composition syntax</li>
<li>Things like sum and such that are always on Java’s interface even when they don’t apply. It has mapToInt etc. Because traits can be implemented based on the generic type, in Rust these methods are there when they apply and gone when they don’t. This means they don’t all need weird names based on the type. They can have a single uniform name. What’s more they aren’t tied to concrete types like ‘int’ and ‘long’ they can be tied to “anything implementing add” etc. </li>
</ul>
</li>
<li>For( line : file) example</li>
<li>Collect on Java streams vs Rust inferring type from result
<ul>
<li>Single impl of collect as opposed to having a separate one for each type.</li>
<li>Collect invers return type or via turbofish</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#closures" id="closures">Closures</a></h2>
<p>TODO:</p>
<ul>
<li>syntax</li>
<li>Map on iterator / option</li>
<li>foreach</li>
<li>Move</li>
<li>Pass functions directly</li>
<li>Alias allows equivalent of functional interface in Java.</li>
</ul>
<h1><a class="header" href="#enums-tuples-and-aliases" id="enums-tuples-and-aliases">Enums, Tuples, and Aliases</a></h1>
<p>TODO:</p>
<ul>
<li>Range operator. Range on struct to destructure.</li>
<li>Enums in Java are way better than constants in other languages like C or Go. - You know they won’t get misassigned as numbers and you can use switch statements</li>
<li>Enums give more meaningful names to concepts without overhead, so you can name possible outcomes to improve API quality and reduce the chances of Error.</li>
<li>Enums can implement traits</li>
<li>bitflags</li>
</ul>
<h2><a class="header" href="#aliases" id="aliases">Aliases</a></h2>
<p>Rust supports the concept of 'Aliasing’ this just allows you to refer to one type by a different name. This can be useful to add clearity for example:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type Time = i64;
<span class="boring">}
</span></code></pre></pre>
<p>This will allow an i64 to be referred to as ‘Time’ like so:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Message{timestamp:i64};
</span><span class="boring">let message = Message{timestamp:0};
</span>type Time = i64;
let timestamp : Time = message.timestamp;
<span class="boring">}
</span></code></pre></pre>
<p>Note that Time is not a separate type. So a i64 can be passed to the function. This will not allow adding any special methods to the type, but it also means all the methods of the existing type are there. Because of these limitations, aliasing is generally not used for public interfaces, but to improve readability of code. It does have another important use: renaming an imported type. In Java if you have two types with the same name you have to refer to one by its fully qualified name. </p>
<pre><code class="language-java">import java.awt.List;
//...
class Example {
  private List awtList;
  //..
  void method () {
    //This is awkward...
    java.util.List&lt;String&gt; items = Arrays.asList(awtList.getItems());
  }
}
</code></pre>
<p>In Rust you could just rename one of types.</p>
<pre><code class="language-rust ignore">use some::value as other_value;
</code></pre>
<h2><a class="header" href="#enums" id="enums">Enums</a></h2>
<p>Enums in Rust are different from enums in Java. They aren't just constants, they can have fields and multiple instances can be instantiated. Additionally different values can have different member variables. So in Java you can do __ but in Rust you can do __. Notice the _ parameter on the _. This can be different for different instances.</p>
<p>This is useful as it allows you to enumerate different possible return values. For example __. This would require a very awkward construction in Java.</p>
<h2><a class="header" href="#option-vs-null" id="option-vs-null">Option vs null</a></h2>
<ul>
<li>Option implements traits
<ul>
<li>Take method</li>
</ul>
</li>
</ul>
<p>In Java and variable can be assigned to null. (In fact there is no <code>null</code> in Rust) Rust uses an explicit Option type to convey when an object can be null. This was added in later versions of Java but it's not as helpful as it could be because it doesn't actually prevent assigning things to null, it just documents times when you expect that they can be null. As such it doesn't catch any NullPointerExceptions at compile time because these occur precisely when you don't expect things to be null. You might think the lack of nulls would result is very verbose code. But it's not much of a problem in Rust. Compare this __ to the equivalent Java __. The real advantage of making option explicit is not that it prevents null pointers but that it makes interfaces better. Take a look at Java's iterators. They need to have a hasNext() method because it cannot use null to differentiate “there are no more values” from a value that is null. Anyone who has implemented their own iterator will immediately recognize how annoying this can be.</p>
<p>Rust also supports <code>destructuring</code>. This allows assignment statements to extract values from structures. For example you could write __ to split apart a structure. Here the struct is being split up and assigned to individual variables. There is an even fancier version of this where it can be used in a conditional. Here is an example of “if let” this is extracting and assigning the value ‘x’ but does so only if the surrounding pattern matches. So in this case if the option is ‘None’ this will not match, the condition will be false and the ‘if’ will execute the code in the else block. You can do the same thing with a “while let”. __ As you can see this is useful when there is a </p>
<h2><a class="header" href="#tuples" id="tuples">Tuples</a></h2>
<p>Rust supports Tupples. Tupples are just like 'Pair’ in <code>apache lang</code> in Java or Map.Entry. They are a simple wrapper of multiple objects. The syntax looks like:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let pair : (i32, String) = (5, &quot;Hello&quot;.to_string()); 
<span class="boring">}
</span></code></pre></pre>
<p>which is a tuple of a integer and a String. Tupples aren't full blown classes so the fields don't even have names. They are accessed by number. </p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let pair = (10, 20);
let ten = pair.0;
let twenty = pair.1;
//Tupples can also be named
struct Position(f64, f64);
let pos = Position(1.4, 3.2);
<span class="boring">}
</span></code></pre></pre>
<p>Tupples should only be used when it is very clear what the represent, because without accessor methods or named fields their meaning can be ambiguous to someone who doesn't fully understand the context.</p>
<p>Tupples can have 0 or more values. An empty tuple is just <code>()</code> this litterly contains nothing and has no methods. An empty tuple is actually the return type of a “void” method. (This is sometimes called “the unit type”) </p>
<p>Tuples with two parameters are the most common. IE . But 3 or more is possible. </p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let tripple = (1, 1.0, &quot;one&quot;);
let quad = (2, 2.0, &quot;two&quot;, true);
<span class="boring">}
</span></code></pre></pre>
<p>A single element tuple might seem pointless but it does provide a way to name something. IE: </p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Distance(f64);

let london_to_ny = Distance(3459.3,);
<span class="boring">}
</span></code></pre></pre>
<p>Which can sometimes help with clearity. (Note: the single element tuple must have the trailing ‘,’ to distinguish it from a normal expression in parenthsis.</p>
<ul>
<li>https://medium.com/@robertgrosse/ref-patterns-destructuring-and-invisible-borrows-2f8ae6902656</li>
</ul>
<h2><a class="header" href="#match" id="match">Match</a></h2>
<ul>
<li>Match guards / binding</li>
</ul>
<p>In the above example we introduced a new construct <code>match</code>. Match works like a souped up version of Java’s switch statement. It differs in a few important ways: It must be exhaustive, There is no fallthrough (and hence no break), it is an expression so it can return a value, It has pattern matching which lets you define what to match against, it can capture variables so the right hand side can use them. Here is a match statement that shows off all of these __ compared to the equivalent Java __. </p>
<p>Match works with destructuring __. It works on Options and Enums __. If all cases are covered, there does not need to be a default branch. It also works with ranges __. (The ‘_’ means “you figure it out” and is a default branch.) If the paths are not mutually exclusive for example __. The first one that applies will be taken. IE __.</p>
<p>Sometimes in a destructuring expression you will see the word 'ref’. This is equivalent to a ‘&amp;’ in the corresponding place on the other side. IE __ is equivalent to __.</p>
<h1><a class="header" href="#modules" id="modules">Modules</a></h1>
<ul>
<li>Rules of modules and files. (See the rust book)</li>
<li>Inline modules.</li>
<li>Testing modules.</li>
</ul>
<p>In Java code is distributed in <strong>Jars</strong>, there is a directory hierarchy which orginizes the code within them into multiple Java <strong>packages</strong>, within a package there are many files, each of which holds a corisponding <strong>class</strong> which intern holds member variables and has methods. </p>
<p>In Rust the situation is similar, code is distributed in <strong>crates</strong> inside of which there is a directory hierarchy which orginizes the code in them into multiple <strong>modules</strong>. In Rust modules are hierarchial, so a module could have a submodule that is a whole directory tree of sub modules, on just a single file which contains the module. Inside of the file, there can be member variables declared in a struct and methods defined to operate on them.</p>
<p>As an example a crate might have the following structure:</p>
<pre><code class="language-markdown">src/lib.rs
src/image_processor.rs
src/image_processor/jpeg_decoder.rs
src/image_processor/png_decoder.rs
src/analyzer.rs
</code></pre>
<p>Here <code>lib.rs</code> is the entrypoint for the crate, meaning it is a library that other crates depend on. If the crate was a program intended to be executed directly, there would instead be a <code>main.rs</code> in the <code>src</code> directory. All of the source files to be included go under the <code>src</code> directory where as tests go under a <code>tests</code> directory. </p>
<p>Inside of <code>lib.rs</code> the code might import the image processor module by:
<code>use image_processor::*</code>
This uses a relitive path to resolve items. It is also possible to provide an absolute one by:
<code>use crate::image_processor::*</code>
Here the keyword <code>crate</code> refers to the root from anywhere within the crate. Similarly there are keywords for <code>self</code> to refer to the current module and <code>super</code> to refer to the parent module.</p>
<p>Modules affect visability. By default methods are visable within a module and any submodule. (Note this this is different from Java's default visibility which is not hierarchical) So functions in <code>lib.rs</code> (assuming they are not in a sub-module) can be seen by any code in the crate. Where as those in <code>image_processor.rs</code> can be seen by <code>jpeg_decoder.rs</code> and <code>png_decoder.rs</code> but not <code>analyzer.rs</code> and items in <code>analyzer.rs</code> cannot be seen from any other module. To increase this visability one can add the the keyword <code>pub</code> in front of a function definition. This works just like <code>public</code> in Java. It means that the function can be invoked from anywhere. Additionally it is possible to add <code>pub(crate)</code> which makes the item visiable to everything within the crate, but not outside of it. It's also possible to be more explicet and write <code>pub(in test_module)</code> to make the module visiable to code in <code>test_module</code>.</p>
<p>These rules are quite flexable, as they allow for very clean separation of 'internal' and 'external' concepts. The one thing that is a little supprising at first is that there is no equivlent of Java's <code>private</code>. However this is obtained automatically by simply putting things into their own module. In the above example anything in <code>jpeg_decoder.rs</code> would be effectivly private unless it was explicetly declared <code>pub</code>. </p>
<p>It’s a good idea in Rust to follow the same design principle that a lot of Java code uses: The Single responsibility principle. Any given chunk of code should have one and only one responsibility. All the code with that responsibility should be located in single file and almost always, that corresponds with a single public structure. (Though there may be several private ones). Java formalizes this by having one (outer) class per file. In Rust you should do the same thing with modules. Each module should be in it’s own file, and have a single, clearly defined responsibility, which means in all likelihood a single public structure (and any subspecies).</p>
<h1><a class="header" href="#cargo" id="cargo">Cargo</a></h1>
<p><strong>Cargo</strong> is rust's build and dependency management system. It is similar to <code>gradle</code> and <code>maven</code> in Java.
However in comparison to them Cargo is much simpler. For example Cargo uses the
<a href="https://github.com/toml-lang/toml">TOML</a> file format for it's config, which is written in a declaritive style.</p>
<p>For example you might write:</p>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
snafu = &quot;0.6.8&quot;
serde = &quot;1.0&quot;
# This is a comment ...
</code></pre>
<p>You can find more information about cargo in the <a href="https://doc.rust-lang.org/cargo/index.html">cargo book</a></p>
<p>Some common commands are listed below:</p>
<table><thead><tr><th>Command</th><th>Effect</th></tr></thead><tbody>
<tr><td><code>cargo new --bin foo</code></td><td>Create a new program named &quot;foo&quot;</td></tr>
<tr><td><code>cargo new --lib foo</code></td><td>Create a new library named &quot;foo&quot;</td></tr>
<tr><td><code>cargo build</code></td><td>Build the current project</td></tr>
<tr><td><code>cargo clean</code></td><td>Cleans the build directory</td></tr>
<tr><td><code>cargo check</code></td><td>Checks for complication errors</td></tr>
<tr><td><code>cargo doc</code></td><td>Builds <a href="./method_signatures.html#Rustdocs">Rustdocs</a></td></tr>
<tr><td><code>cargo test</code></td><td>Runs tests (Like Junit, but built into the language)</td></tr>
<tr><td><code>cargo publish</code></td><td>Publish the crate to <a href="https://crates.io">Crates.io</a></td></tr>
</tbody></table>
<ul>
<li>https://blog.rust-lang.org/2016/05/05/cargo-pillars.html</li>
<li>Toml format</li>
<li>Dependencies
<ul>
<li>Dev-Dependencies</li>
</ul>
</li>
<li>Cargo tools
<ul>
<li>Audit</li>
<li>Doc test</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#versions" id="versions">Versions</a></h2>
<ul>
<li>Depreciation warning</li>
</ul>
<p>One old idea that Rust embraces is versioning. Unlike Java (or most other programming languages) in Rust when creating a new project you explicitly specify which edition of the language you wish use. This Book is written to the <a href="https://hacks.mozilla.org/2018/12/rust-2018-is-here/">2018 edition of the language</a>. This edition has different syntax than the 2015 edition, and future editions will change things as well. But backwards compatibility is maintained because the compiler can check which edition is being used and compile to that standard. Because regardless of which edition is being used the code is compiled to native code, code written in any edition can depend on code written in any other edition. This frees the language to evolve and change overtime without being tied down to legacy.</p>
<p>Similarly in Rust all projects are expected to use semantic versioning of the form Major.Minor.Patch where a change to the patch version means no publicly visible changes have occurred, a change to the minor version means changes have occurred but existing code should still work, and a change to the major version means dependant code needs to be re-written. Changes that break backwards compatibility are also OK prior to a 1.0.0 version. </p>
<p>The Rust language itself also versioned in this way. This is actually how Java was originally versioned. They released 1.2, 1.3, 1.4, and 1.5. But then they decided that they could drop the leading 1 because they were not going to break compatibility. Just looking at the version number you can see that Rust releases a lot faster than Java. The Language is on a six-week release cycle so it's constantly improving. </p>
<p>This rapid release cycle is made possible because it is well factored in well tested. Most of what would be considered the standard library in another language is packaged and released separately. The developers even have a tool which will build all publicly available code against a new version of the language before it is released.</p>
<p>Unlike Java, Rust has a very small standard library. Instead it provides powerful and flexible primitives, that allow many features you wouldn’t expect to be developed as libraries. This works because Rust has a built in dependency management system called Cargo. </p>
<h2><a class="header" href="#dependencies" id="dependencies">Dependencies</a></h2>
<p>Dependencies can be added to your project by simply addin the approprate line in Cargo.toml. 
To find crates you can depend on and the line to add them to your config file go to <a href="https://crates.io/">crates.io</a>.</p>
<p>Unlike Java, you don't need to worry about transitive dependencies, it is not possible to endup accedently directly using their code,
and &quot;version conflicts&quot; are not an issue, because multiple versions can be in the same application at the same time without ambiguity. </p>
<p>Below is a list of common dependencies and their function.</p>
<table><thead><tr><th>Crate</th><th>Function</th></tr></thead><tbody>
<tr><td><a href="https://serde.rs/">Serde</a></td><td>Serialization and Deserialization</td></tr>
<tr><td><a href="https://clap.rs/">Clap</a></td><td>Command line argument parsing. (See also <a href="https://crates.io/crates/structopt">structopt</a> which automates even more</td></tr>
<tr><td><a href="https://crates.io/crates/simple-signal">Simple-signal</a></td><td>Unix signal handling</td></tr>
<tr><td><a href="https://rust-lang.github.io/rust-bindgen/">Bindgen</a></td><td>Automatically generates Rust FFI bindings to C</td></tr>
<tr><td><a href="https://crates.io/crates/itertools">Itertools</a></td><td>Extra iterator adaptors and methods</td></tr>
<tr><td><a href="https://crates.io/crates/rayon">Rayon</a></td><td>Simple lightweight data-parallelism library</td></tr>
<tr><td><a href="https://crates.io/crates/faster">Faster</a></td><td>SMID made safe and simple using iterators</td></tr>
<tr><td><a href="https://rust-lang-nursery.github.io/packed_simd/packed_simd/">Packed-simd</a></td><td>Architecture independent SIMD</td></tr>
<tr><td><a href="https://github.com/crossbeam-rs/crossbeam">Crossbeam</a></td><td>Tools for concurrent programming</td></tr>
<tr><td><a href="https://tokio.rs/">Tokio</a></td><td>A non-blocking IO framework</td></tr>
<tr><td><a href="https://diesel.rs/">Diesel</a></td><td>A compile time validated ORM query buider</td></tr>
<tr><td><a href="https://rocket.rs/">Rocket</a></td><td>A web server that uses compile time checks to prevent vunribilites (directory traversal, SQL injection, csrf, css, remote code execution, misconfiguration) and verifies authentication, authorization, and input validation logic.</td></tr>
<tr><td><a href="https://maud.lambda.xyz/">Maud</a></td><td>Compile time validated HTML templates</td></tr>
<tr><td><a href="https://crates.io/crates/rand">Rand</a></td><td>Random number generators</td></tr>
<tr><td><a href="https://crates.io/crates/quickcheck">Quickcheck</a></td><td>Randomized unit testing</td></tr>
</tbody></table>
<ul>
<li>
<p>Logging of events for metrics</p>
</li>
<li>
<p>Rtfm for embedded systems. Also Singleton. And svd2rust</p>
</li>
<li>
<p>Instead of rolling your own graph: Petgraph or an ECS </p>
</li>
<li>
<p>Rustfmt/racer/rustfix</p>
</li>
<li>
<p>Rustup</p>
</li>
<li>
<p>Cargo</p>
</li>
<li>
<p>Rr</p>
</li>
<li>
<p>Fuzzers</p>
<ul>
<li>Cargo fuzz uses an address checker to verify uninitialized memory is not being read.</li>
<li>Angora - Still a work in progress, but should eventually be the best fuzzer.</li>
</ul>
</li>
<li>
<p>Habitat</p>
</li>
<li>
<p>Servo</p>
</li>
<li>
<p>redox</p>
</li>
<li>
<p>Ripgrep</p>
</li>
</ul>
<p>Below are some common dependencies and a brief description of what they do:
High precision math and units
IoUtils
Builder equals, hash, and serializable
Log
slog
Similar to Junit
Benchmark / criterion
Example testing
Quick check / propcheck
Checksyle
Findbugs
Lint (clippy)
Fuzzers: afl / hongfuzz / cargo fuzz</p>
<h2><a class="header" href="#rustc" id="rustc">Rustc</a></h2>
<p>If you've been programming in Java for a long time you're probably used to compiler-errors that you just look at to get the line number and then go to the that line and see what's wrong. IDEs have mostly even obsoleted this by just underlining the problem, which is usually sufficient to work out the problem. Rust goes well above and beyond this. It has very clear and detailed error messages explaining exactly what the problem is some of which even suggest Solutions what's more each error message has a number associated with it but you can look up online and see if full documentation as to why that error message occurs examples of it occurring how to avoid it and how to structure code so is to prevent it from being a problem.</p>
<h1><a class="header" href="#equivalent-frameworks" id="equivalent-frameworks">Equivalent frameworks</a></h1>
<ul>
<li>
<p>Licence compatibility - Just fix it.</p>
</li>
<li>
<p>Licence auditing for everyone: like Rat. But automatically through all transitive deps.</p>
</li>
<li>
<p>Integrate https://github.com/onur/cargo-license to automatically check</p>
</li>
<li>
<p>Security audit - add to environment recommendations</p>
</li>
<li>
<p>Security notifications for everyone: any and all security vulnerabilities should propagate a fix as quickly as possible. Issue warn on build so the new dep can be pulled.</p>
</li>
<li>
<p>rustsec should be integrated and on by default in Cargoz</p>
</li>
<li>
<p>Localization with fluent</p>
</li>
<li>
<p>Rocket web service</p>
</li>
</ul>
<h1><a class="header" href="#error-handling" id="error-handling">Error handling</a></h1>
<p>Java has both checked and unchecked exceptions. This is been criticized a lot of people both inside and outside Java community, however the original idea is sound. Checked exceptions make sense where the exception is expected to be handled by the immediate caller. Unchecked exceptions make more sense were the exception just isn't anticipated at all, for example because it results from a situation that would require a programming error. This leads to a pattern that's rather elegant in theory: known failure modes must be handled explicitly, while unknown ones propagate up the stack as far as necessary until there's some general catch-all block that deals with them.</p>
<p>Java's implementation of this however isn't ideal because it defined things is a very awkward way. For example that InputStream's and OutputStream's close method throws, or that InterruptedException is both checked and catching it resets interrupted status. Additionally in earlier versions of Java if an interface that declared an exception then implementations of the interface had to declare that the exception. While this is no longer the case, it is the reason why ByteArrayOutputStream still throws IOException.</p>
<p>Finally and more subjectivity, RuntimeExceptions and checked exceptions FEEL too similar. It's too easy to think of them as part of the same thing, and not realize the massive difference between ordinary errors and cases that truly cannot be handled, because they arise from bugs in the program itself.</p>
<p>All of this combined with a lack of a concise way to rethrow one exception as another lead to a large backlash against checked exceptions. This is somewhat unfortunate, because similar to how the backlash against some annoying corner cases with types resulted in the popularity of dynamic typed languages, the backlash against the inconveniences of checked exceptions directly lead to C# removing them and using a strictly runtime exception model. Which while more convenient than Java's model was a step back in terms of ensuring correctness.</p>
<p>Fortunately Rust has found a way to resolve these issues. Rust's solution is quite different from Java's. But it is similar in that there are two types of error handling. The “normal” way, which is used for expected errors provides strong guarantees that the error will be handled. Rust's error handling syntax is very lightweight. It doesn't require writing try/catch blocks all over the place, and provides a seamless way of converting between different exception types and converting to the “unrecoverable” type (analogous to Java's runtime exceptions) allowing a way to “bail out” instead of handling the error, if there isn't a way to do so. Below is an example __. (See Joe Duffy's “The error model” and use table)</p>
<p>In Java it is common to use Preconditions. The pattern in Rust is to use assertions. So the following are idiomatically equivalent</p>
<pre><code class="language-java">class Decoder {
  //...
  public Message decode(String message) {
    Preconditions.checkNotNull(message);
    Preconditions.checkArgument(!message.isEmpty(), &quot;Cannot decode an empty message.&quot;);
    //...
  }
}
</code></pre>
<p>and</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Message();
</span>struct Decoder {
  //...
}
impl Decoder {
  //...
  pub fn decode(&amp;self, message : &amp;str) -&gt; Message {
    //No need for a null check because there are no NPEs in Rust.
    assert!(!message.is_empty());
    //...
<span class="boring">  Message()
</span>  }
}
<span class="boring">}
</span></code></pre></pre>
<p>If instead of panicking you just want to return an Error, use the 'ensure!’ macro from the Snafu crate.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use snafu::*;

struct Message {/* ... */}

struct Decoder {
  //...
}
#[derive(Debug, Snafu)]
enum DecodeError {
    EmptyMessage,
}

impl Decoder {
  //...
  pub fn decode(&amp;self, message: &amp;str) -&gt; Result&lt;Message, DecodeError&gt; {
    ensure!(!message.is_empty(), EmptyMessage);
    //...
    Ok(Message{/*...*/})
  }
}

<span class="boring">}
</span></code></pre></pre>
<p>One problem with Java's exceptions is they don't work with things like Futures or Java Streams very well. This is because these interfaces need to be generic so the type information in the exception is lost, and they are likely running from a callback or threadpool so the stacktrace is not helpful. This eliminates two of the main benefits of using exceptions. Fortunately Rust's model overcomes both of these problems. So where in Java you would have to write something like this __ and if it failed you would get a stack traces that looked like __, whereas in Rust you could just write __ and if it failed you would get a stacktrace that looked like __.</p>
<p>To add a new exception type on a public interface, in Java you would either have to make the new exception Runtime. (Which may or may not be desirable depending on the circumstances) Or you can subtype an existing exception. In Rust the pattern is to use an error Enum. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use snafu::*;

struct Message {/* ... */}

#[derive(Debug, Snafu)]
enum DecodeError {
  #[snafu(display(&quot;Error decoding message due to {}&quot;, error_message))]
  CorruptData {
    error_message: String,
  },
}

struct Decoder {
  //...
}
impl Decoder {
  //...
  pub fn decode(&amp;self, message: &amp;str) -&gt; Result&lt;Message, DecodeError&gt; {
    //...
    Ok(Message{/*...*/})
  }
}

<span class="boring">}
</span></code></pre></pre>
<p>This way all the errors are explicitly enumerated and they can either be handled all the same or individually by the caller. If you use a non-exhaustive Enum like</p>
<pre><code class="language-rust ignore">#[derive(Debug, Display, Snafu)]
#[non_exhaustive]
enum Unprocessable {
  MalformedInput,
  BackendUnavailable,
  UnknownException,
}
</code></pre>
<p>Then new types of errors can be added in the future without breaking compatibility. (Because in a matching on the Enum will require a default branch) Ie:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Unprocessable {
</span><span class="boring">  MalformedInput,
</span><span class="boring">  BackendUnavailable,
</span><span class="boring">  UnknownException,
</span><span class="boring">}
</span>fn failing_function() -&gt; Result&lt;(), Unprocessable&gt; {
  //...
  return Err(Unprocessable::MalformedInput);
  //...
}
if let Err(error) = failing_function() {
  match error {
    Unprocessable::MalformedInput =&gt; println!(&quot;Bad input.&quot;),
    _ =&gt; println!(&quot;Unexpected error&quot;),
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>In Java there are checked exceptions such as IOException and unchecked exceptions such as Error. Rust has analogous concepts. Panic is a similar to an Error in Java. It is assumed to be unrecoverable. It is sort of a controlled crash. In the event of a panic rust will gracefully unwind the stack similar to Java. It runs destructors (which works like a finalizer in Java). However it will not release locks, as this could mean that only a part of a critical section was executed and the data is left in an inconsistent state. (Other threads trying to acquire the mutex will get error when they call lock()).</p>
<p>In addition Rust has error types these work like a return value but with some special syntax surrounding them. This ends up working a bit like checked exceptions in Java.</p>
<p>Exceptions like many things in Rust are a crate that is imported, rather than built into the syntax itself. The preferred implementation is one called “Snafu”. much like Java it allows you to create your own exception types chain exceptions together when one causes another, and provides stack traces. However exceptions in Rust work differently than they do in Java. In fact the exceptions isn't really the right word they work somewhere between a return value at an exception. They do however have a very compact syntax which is helpful.</p>
<p>In Java you might write:</p>
<pre><code class="language-java">private String readToString(String filePath) throw IOException;
</code></pre>
<p>The equivalent Rust would be:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io;
</span><span class="boring">pub trait Example {
</span>fn read_to_string(path: String) -&gt; Result&lt;String, io::Error&gt;;
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Notice that the exception is actually part of the return value. Specifically the function either returns a <code>String</code> or an Exception. If that was all there was, it still would be a step up from languages like c or go in that you cannot forget to check the value. But having to manually unwrap each return value and usually re-throw the exception at every stack frame would be very tedious and seem down right primitive compared to Java. Fortunately this is not the case. You can use a special operator the question mark. If you have code like the following:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io;
</span><span class="boring">use std::io::Read;
</span><span class="boring">use std::fs::*;
</span><span class="boring">fn initial_buffer_size(file: &amp;File) -&gt; usize { 0 }
</span><span class="boring">pub trait Example {
</span>// Copied from std::fs
fn read_to_string(path: &amp;str) -&gt; io::Result&lt;String&gt; {
    let mut file = File::open(path)?;
    let mut string = String::with_capacity(initial_buffer_size(&amp;file));
    file.read_to_string(&amp;mut string)?;
    Ok(string)
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Notice the <code>?</code>. This will rethrow the exception. But that's not all, you can also convert between exception types automatically changing the new exception to the old one. For example you might write the following code in Java:</p>
<pre><code class="language-java">public class PublicException extends Exception {
  PublicException(String message) {
    super(message);
  }
  PublicException(Throwable t) {
    super(t);
  }
  PublicException(String message, Throwable t) {
    super(message, t);
  }
}
//Then elsewhere:
public void publicFunction() throws PublicException {
  String value;
  try {
    value = doSomeStuff();
  } catch (InternalException e) {
    throw new PublicException(e);
  }
  try {
    doSomeOtherStuff(value);
  } catch (OtherInternalException e)
    throw new PublicException(e);
  }
}
</code></pre>
<p>This is not only very verbose, it is not very clear in terms of its flow. However it is equivalent to the following Rest code:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use snafu::*;

#[derive(Debug, Snafu)]
pub struct PublicError(InternalError);

#[derive(Debug, Snafu)]
enum InternalError {
    #[snafu(display(&quot;Internal error message&quot;))]
    SomeInternalError,
    #[snafu(display(&quot;Other internal error message&quot;))]
    OtherInternalError,
}

//Then elsewhere:
pub fn public_function() -&gt; Result&lt;(), PublicError&gt; {
  let value: String = do_some_stuff()?;
  do_some_other_stuff(value)?;
  Ok(())
}

fn do_some_stuff() -&gt; Result&lt;String, InternalError&gt; {
  //Dummy logic
  Ok(&quot;Hello&quot;.to_string())
}
fn do_some_other_stuff(value: String) -&gt; Result&lt;(), InternalError&gt; {
  //...
  Ok(())
}

<span class="boring">}
</span></code></pre></pre>
<p>If you compare the two <code>publicFunction</code> methods, you can see this is both very explicit and compact it shows the flow control very nicely you can see the points where function can exit, and it does so without any extraneous indentation Constructors or unnecessary blocks. Just to show a more sophisticated example the following are equivalent: __ and __. The exception generated will look like __ and __. but notice the rest code didn't have nice line numbers in backtrace is for the intermediate functions. fortunately to enable this is quite simple you just set the environmental variable RUST_BAKTRACE=1. Then it will print the following __. Because this doesn't add any overhead in the non-failure case (and is fairly cheap even in the error case), and increases debuggability I simply leave this on all the time.</p>
<p>In Java a common approach is to have use multiple subclasses of a common exception. In Rust the pattern is to use an enum. So this Java function __(load config), would be written like this in Rust.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use snafu::*;
use std::fs;
use std::io;

struct Config;
fn parse_config(s: &amp;str) -&gt; Result&lt;Config, ConfigReadError&gt; {
  Ok(Config)
}

#[derive(Debug, Snafu)]
enum ConfigReadError {
  #[snafu(display(&quot;Invalid config in file {}&quot;, path))]
  FailedToReadFile {
    path: String,
    source: io::Error,
  },
  #[snafu(display(&quot;Unable to parese config because {}&quot;, msg))]
  InvalidConfig{
    msg: String,
  },
}
//...
fn load_config(path: String) -&gt; Result&lt;Config, ConfigReadError&gt; {
  let serialized_config = fs::read_to_string(&amp;path).context(FailedToReadFile{path})?;
  parse_config(&amp;serialized_config)
}

<span class="boring">}
</span></code></pre></pre>
<p>So in Java a caller handling these together would just catch _ or would handle them separately with multiple catch blocks __. In Rust they can be handled collectively __ or via a Match statement __. However this code is messy and verbose. So Rust allows you to instead write __. This is exactly the same as the above code. The <code>?</code> Operator unwraps the result object if the call was successful, otherwise it returns an error, and if the method’s error type is different it will automatically call __ to wrap or convert the error. This pattern is commonly used in conjunction with a crate called Snafu which automatically generates a lot of the boilerplate code for you and provides backtraces that can we accessed just like in Java 10. __. The advantage of Rust's backtraces as opposed to Java's is they automatically work across threads. __</p>
<p>Another common pattern in Rust that gets exceptions even further out of the way is to Alias error. For example __. Then all the methods can just have __ in their signature and not have to type the exception signature over and over.</p>
<h1><a class="header" href="#how-rust-makes-you-a-better-java-programmer" id="how-rust-makes-you-a-better-java-programmer">How Rust makes you a better Java programmer</a></h1>
<ul>
<li>“Data structures make it easy to add new functions without changing the structure. Where as objects allow adding new classes without changing the functions.” Oo makes it hard to add new functions, but traits allow this.</li>
<li>Shared mutable state is the source of most bugs.
<ul>
<li>Oo languages limit sharing by hiding an impl behind the interface of an object. This is vastly better than the alternative. But doesn't fully hide things because … 
<ul>
<li>Indirection allows hidden changes</li>
</ul>
</li>
<li>Functional languages remove mutable state. That prevents many problems, but it makes it much harder to do certain things. Which introduces its own bugs. Or you end up writing a lot of code to make immutable state look like mutable state. Which ends reintroducing some of the problems that were prevented.</li>
<li>Rust allows mutability without sharing, or sharing without mutation, but never both at the same time.</li>
</ul>
</li>
<li>The expression problem: The goal is to define a datatype by cases, where one can add new cases to the datatype and new functions over the datatype, without recompiling existing code, and while retaining static type safety (e.g., no casts)</li>
<li>How rust makes you better at Java
<ul>
<li>Ownership
<ul>
<li>Nested sync</li>
<li>Modifying an object after passing.</li>
<li>Graphs</li>
</ul>
</li>
<li>Composition over inheritance</li>
<li>Circular references
<ul>
<li>Are a problem, for c..</li>
<li>Are not needed most of the time. </li>
<li>Usually for a callback. That is better handled via 
<ul>
<li>FUtures </li>
<li>…</li>
</ul>
</li>
<li>Don’t fear copies. (10x java copy speed)
<ul>
<li>to_owned() from a ref </li>
</ul>
</li>
</ul>
</li>
<li>Solid principles</li>
</ul>
</li>
</ul>
<p>Rust’s strict enforcement of rules makes a lot of bad patterns particularly hard to write. This can be a good thing if you recognise when something is going wrong, because it stops you from making a design mistake. &lt;Insert don’t fight the borrow checker&gt;
For an example of this see the article “Too many linked lists” or the Rustconf 2018 closing keynote “__”.</p>
<h2><a class="header" href="#thread-safety-provided-by-ownership" id="thread-safety-provided-by-ownership">Thread safety provided by ownership</a></h2>
<ul>
<li>Race conditions and ownership.
<ul>
<li>Race by releasing lock</li>
<li>Compare java and rust</li>
</ul>
</li>
<li>Deadlock
<ul>
<li>In one class (obvious)</li>
<li>Cyclic dependency
<ul>
<li>Final initialization prevents
<ul>
<li>Not always practiced in Java</li>
<li>Often people do realize memory model implications</li>
<li>Rust pattern is really akward and discouraged.</li>
<li>Rust compiler correctly identifies memory model problem and forces you to grapple with it.</li>
</ul>
</li>
</ul>
</li>
<li>Object passed in during call
<ul>
<li>Java rules should prevent
<ul>
<li>Often not practiced.</li>
<li>Not as easy to spot because you can't tell at the call site. If code not always following rules and classes are mixed.</li>
</ul>
</li>
<li>In Rust still possible. Example: a owns b, c. B holds c. A passes B to C by reference. B and C both have inner objects guarded by a mutex. The scope of the guard extends over calls to each other.
<ul>
<li>Could be prevented by the old fashioned advice to keep the scope of locks small.</li>
<li>Should be aware of such cycles. Not always obvious. Rule of thumb is not to invoke methods on some other argument while holding a lock. For example __</li>
<li>In general in Rust if you are using a mutex over two objects you are doing it wrong. It is reasonable to make updates atomic, but the lock is in the wrong place. It should just wrap the thing that needs to be made atomic. So instead just hold onto the inner objects directly and make the method take a &amp;mut self. Then wrap the object in mutex one level up.</li>
</ul>
</li>
</ul>
</li>
<li>Call back
<ul>
<li>Never invoke a callback or complete a future while holding a lock. (In any language)
<ul>
<li>Really blatant violation of invoking a method on a passed object while holding a lock.</li>
</ul>
</li>
<li>This is the ultimate narrow the scope of a lock. Who knows what a callback includes!</li>
<li>In Rust this is not a problem for futures as, unlike Java's they don't work as a callback. They get run by the executor. It's like if in Java you invoked __ every time instead of __. This is a safe way to avoid holding a lock in Java. Unfortunately it does have some overhead, so most codebases can't afford to simply have the rule that it should be used every time. Fortunately Rust have found a way to use their ownership model to make their futures Radically more efficient. For example <strong>benchmark</strong>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>How to write thread safe code in Java….</p>
<p>These concurrency rules help deal with cases where you have multiple independent tasks running in parallel, or where you have a shared state the needs to be coordinated between two tasks. 
Another pattern is message passing. This is also often used in Java using Queues such as the ArrayBlockingQueue or the LinkedBlockingQueue or the synchronunsQuntne. These are totally compatible with the model, they should just be considered an…..</p>
<p>When I was first learning Rust, after reading the Rust book, I started reading the trust-dns codebase to make sure I understood things. I remember being shocked when I saw this: https://github.com/bluejekyll/trust-dns/blob/master/https/src/https_client_stream.rs#L38 I saw and Arc around the String and was immediately afraid. Coming from many years of managing thread safety in Java, the idea that a mutable class (String) was being shared across threads (why else would it be wrapped in an Arc), and this object was wrapped in a struct that was going to be returned from a function (Implied by the #must_use annotation) nearly sent me into cardiac arrest! (And if it didn’t deeply frighten you, let me assure you, your code is riddled with thread safety errors).</p>
<p>In just 7 lines of a struct definition, it is violating every possible tenet of writing thread safe code at the same time. And yet… it’s ok. String is itself mutable, Arc won’t allow any mutable borrows of the value unless there is only one reference to it. And the string is owned by the Arc, so there can’t be code anywhere that could have a direct reference to the string. So even though String can be modified, and is shared, and the struct is shared across threads, and is returned out of a public method, any code using that string can treat it as immutable. It will never change out from underneath it.</p>
<p>After spent years working strictly following the discipline above, teaching it to all of my co-workers and carefully reviewing code for compliance, I always thought having the compiler enforce thread safety was just a matter of automating this work. It would be just like writing code in Java, but the conventiones would be formalized, and the review would be done by the compiler. What I didn’t anticipate was that having safety enforced by the compiler would open up new possibilities. A pattern like the one in the trust-dns client would never be allowed, because no sane person would ever want to use it in Java, because it would be hopeless to ever get right. But in Rust, it was just nonchalantly written by someone who didn’t even think about it because they <em>knew</em> the compiler would keep things safe. I think that’s pretty cool.</p>
<h1><a class="header" href="#concurrency" id="concurrency">Concurrency</a></h1>
<ul>
<li>Futures_cpupool
<ul>
<li>Futures chaining</li>
<li>Async / await.</li>
<li>Futex</li>
</ul>
</li>
<li>Async example w/ futures
<ul>
<li>Select and join compared to and and or in Java </li>
<li>Futures with streams (.buffered)</li>
<li>Performance</li>
</ul>
</li>
<li>Async! Macro</li>
<li>Arc</li>
<li>Queue example / channels
<ul>
<li>Send attribute</li>
<li>Select</li>
<li>using channels doesn't prevent race conditions because Go lacks immutability. In Java the same problem exists. In Rust it ownership is explicit so it’s safe</li>
</ul>
</li>
<li>Turn a sync API into an async one</li>
</ul>
<p>In Java you would synchronize the code like this.__ In Rust you synchronize it like this.__  In both cases the lock is guaranteed to be released at the end of the scope. In Java’s case it is because a special scope is being introduced. In the case of Rust, there is no special language feature it just uses the normal destructor to release the lock. This means a new scope does not need to be introduced. Of course you can add one line this __ if you want to reduce the scope a lock is held. (This could also be done with a private method). Another common pattern is to use a loop conditional expression __ as this has a very small scope.</p>
<p>Locks in both languages work the same way, if one thread holds the lock, another thread attempting to acquire the same lock will block. </p>
<p>The mutex object returns a MutexGard object which works like a RefCell. It allows for mutablity borrowing the data but does not allow for taking ownership.</p>
<table width="100%">
<tr>
<td> 
<p><img src="images/borrow.png" alt="Safety monitor" /></p>
</td>
<td width="80%">
<blockquote>
<p><em>Notice that the type perfectly reflects the guarantees. The mutex is guaranteeing only a single thread can hold the lock at any given time, and hence follows the contract of mut. And the value is borrowed so it can't be accidentally stored into some other object which would allow it to be accessed outside the scope of the lock.</em></p>
</blockquote>
</td>
</tr>
</table>
<p>In Java the pattern is that locks should live inside of the class and it is the responsibility of the implementation to implement the locking. This makes sense as the code is relatively compact and all located in a single file which makes it easier to validate. In Rust the pattern is to do synchronization outside. This has a few advantages: it allows callers to make multiple calls under the same lock, so two or more calls in order can be done atomically together without using a second lock. It also means the class can be written once without thinking about thread safety and added by the caller if needed. Applying this pattern to Java would be a bad idea because it would be very hard to verify the lock is held everywhere the data is being accessed. By putting all of the places you need to check into a single file, you can verify it is correct. This is not a problem with Rust because the correctness will be enforced by the compiler. Applying the Java pattern to Rust is also a bad idea. Because other someone else in another module can add methods to your objects neither the compiler nor any of the standard tools will allow a pattern where all of the methods on a particular object are expected to do something.</p>
<p>In Java it is important to encapsulate state for ownership and in turn thread safety. In many functional programming languages the pattern is to do the reverse and have the state passed into the function. The advantage of this is it makes the program very easy to test. Example:</p>
<hr />
<p>In Rust because the ownership contract is explicit it becomes easier to write more testable code around state transitions. Example:
__
This retains the strong ownership and safety guarantees of the Java version while improving the testability.
This can be made explicit using types. If we write it like this the compiler will enforce the correct pattern on callers.
__
Notice that as far as the caller is concerned they are dealing with a single class, but internally we have made it such that only the valid sequence transitions can occur.</p>
<p>Here is an example of how to make a thread safe version of a Map in both Java and Rust. __ In Java we use Collections.synchronizedMap(). The implementation of this looks like __. There are a few things to notice. First, this is very specific to Map. It can't even deal with a nested data structure. So the standard library needs a different one of these for every collection and have to write your own class like this for every data structure you create. Not great in terms of code duplication. Additionally it does not solve the whole problem. The method iterator() and stream() note this in their Javadocs. The caller is expected to grab the lock like this __. This is not ideal because it breaks the abstraction and it's not safe because there is nothing to check and make sure the caller actually does this. Finally the caller itself could modify the map when iterating over it. This would result in incorrect behavior even in a single thread. None of these sort of mistakes are possible in the Rust version as they would all be compile errors. (The iterator method borrows the collection, so it cannot be modified elsewhere before the iterator is dropped.) __</p>
<p>There is a popular crate called Rayon that takes this one level further. If you import Rayon it adds a concept of a parrallel iterator, to automatically provide data-parallel operations on most data structures. For example if you have __ you can just change ‘.iter’ to ‘.par_iter’ like so __. Then the code will run in parallel on multiple threads. All the needed synchronization and coordination is managed by Rayon, and all safety guraentees remain in place. So if you accidentally tried to modify an outside variable without synchronization like this __ the compiler will catch it and produce and error _.</p>
<p>Another elegant albeit rarely used pattern in Rust is Cow. COW stands for copy on write. Cow is similar to Java’s CopyOnWriteArrayList or CopyOnWriteArraySet but it isn't specific to a single data structure. It is generic and can wrap any cloneable object. It will clone the object if it gets modified while there is another reference outstanding. Which means if cow is wrapping a list that is modified in a loop, the list will be copied at most once.</p>
<p>There are two important traits 'send’ which indicates a type can be sent from one thread to another. And ‘sync’ which indicates a type can be accessed by multiple threads at the same time. These are Auto traits. So the compiler will automatically work out for each type if it is one or both of those. So while you normally don't need to think about them, they can be useful if you want to declare this requirement on an interface. For example __. Here the interface explicitly requires that the Type passed in be sendable between threads.</p>
<p>In Java if you had an application where you were dealing with users and users are allowed to perform certain operations once they have been authenticated. Then you might define two different classes _ and _. Then your method signature could like _ and AuthenticatedUser could look like this _. The advantage of this approach is there is not an “isAuthenticated” boolean that you could forget to check, or that could be accidentally set through some other code path. Here the only way to invoke the sensitive method is to have an AuthenticatedUser and the only way to get one is to call Authenticate. This is in effect using Java’s type system to enforce an invariant in your code. These sort of techniques allow Java code to offer stronger security guarantees than more dynamic languages like Ruby or Python. It Rust this pattern is even more common because in addition to types, Rust's stronger notion or generics, Traits, Lifetimes, and ownership allow many different types of guarantees to be enforced. This is worth thinking about when you are designing interfaces. A great example of this is the “mpsc” class in Rust's standard library.</p>
<p>In CS theory there is a really clever and very low overhead lock-free algorithm for transferring data between threads. However it only works if there is only a single thread that is receiving the data. This is still handy because it is common to have many worker threads reporting their results back to some master thread. This algorithm was actually well known at the time that Java was designing its concurrent collections. But it wasn't used. It wasn't because it would be very awkward to explain. Imagine reading the docs to a class like LinkedBlockingQueue and seeing a long explanation of which threads were allowed to call which methods. Because this would simply be too error-prone Java only provided a less efficient but more general algorithm. The crux of the problem was that Java just couldn't represent the restrictions on the object within the language itself. This isn't true in Rust. You can see an implementation of this in std::sync::mpsc (mpsc is an acronym for multiple producer single consumer). FOOTNOTE:(This isn't the only or best way to send data between threads. If you are looking for a more flexible alternative check out crossbeam-channel)</p>
<p>(While the implementation of mpsc isn't a big deal, it is a useful example to show how complicated restrictions can be modeled). To create sure a channel you call _ and it returns two objects a sender and a receiver, where items sent to the sender go to the receiver. The sender implements clone which means you are free to make multiple copies of it. (The copies are similarly connected to the receiver) Both sender and receiver implement the trait Send but not the trait Sync. This means they can be passed to another thread but not used by multiple threads at the same time. (This is enforced by the compiler) The channel is closed automatically when all the producers or the consumer are dropped. While this pattern looks a little odd, it creates an interface that is impossible to use incorrectly. So even though the requirements for this algorithm are oddly specific, Rust allows it to be implemented in a way where any bug in the way it is used will be a compilation error. This is the Rustacean ideal. </p>
<h1><a class="header" href="#testing" id="testing">Testing</a></h1>
<ul>
<li>Assert and derived macros (dbc and hoare)
<ul>
<li>Used as preconditions and for tests</li>
</ul>
</li>
</ul>
<p>Rust has a strong culture of testing. Testing is built into cargo. They are run by invoking 'cargo test’. Tests are declared like this __. This is very similar to Junit in Java. Assertions can be made like __ or __.</p>
<p>The way interfaces work in Rust make it easy to mock out components. For example __.</p>
<p>Cargo can also generate code coverage reports via the __ command. These are compatible with _ and so you can visualize them in __.</p>
<p>Rust also supports randomized testing. Two popular libraries for this are _ and _. They work as follows __ or __ <need to pick one></p>
<p>Cargo also has built in support for microbenchmarking. This is done by writing a test like __. The _ does all the timing for you. All you have to do is implement the function to be benchmarked. You can run benchmarks via _. This shows output and allows you to track changes across versions by __.</p>
<ul>
<li>Tools for profiling: perf
Visible for testing and Mocks</li>
<li>Mocking example</li>
<li>Yup-hyper-mock</li>
</ul>
<h1><a class="header" href="#debugging--profiling" id="debugging--profiling">Debugging &amp; Profiling</a></h1>
<p>For debugging all the standard tooling for native languages can be used.</p>
<p>This includeds things like <a href="https://rr-project.org/">rr</a>. Which is a handy tool for rewinding execution to see how a problem occurs.</p>
<p>Also things like <a href="https://github.com/plasma-umass/coz">coz</a> and <a href="https://github.com/ferrous-systems/flamegraph">flame graphs</a> can be used to help identify performance problem.</p>
<h1><a class="header" href="#operator-overloading" id="operator-overloading">Operator Overloading</a></h1>
<ul>
<li>Size() length, get(), []</li>
</ul>
<p>Traits are also used to what in other languages is called “operator overloading”. For each operator like ‘+’ for example there is an associated trait, which has a method that can be implemented. If an object has an implementation of the trait, you can use the operator as a shorthand for invoking that method. For example in Java it is very common to implement Compairable. However only primitive types can use the ‘&lt;’ and ‘&gt;’ operators. So you have to write:</p>
<pre><code class="language-java">if (a.compareTo(b) &lt; 0) {
    //...
}
</code></pre>
<p>Where as in rust if your type implements the <code>Ord</code> or <code>PartialOrd</code> traits you can just write:</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let a = 1; let b = 2;
</span>if a &lt; b {
    //...
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that <code>Ord</code> compares the object against others of the same type so unlike Java you don't have to worry about a class cast exception at runtime.</p>
<p>Unlike C++ or Scala all of the operators that can be overloaded and the signature of their corresponding methods is pre-defined by the language. Because implementing a trait is only allowed in the package that defined either the trait or the type you can add support for operators to your own types, but you can't add or alter their behavior on someone else's types. So you can't add you own “pope operator” that looks like “&lt;+|:-)”. And operators can't be used to do anything crazy or surprising.</p>
<p>Operators are just syntactic sugar for the method call, so they are still statically checked at compile time. So using them your code is every bit as safe if you simply called the corresponding methods yourself.</p>
<p>Below is a table of operators and the corresponding trait that allows you to implement support for them.</p>
<table><thead><tr><th>Operator</th><th>Example</th><th>Explanation</th><th>Trait</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>Bitwise or logical complement</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>var != expr</code></td><td>Nonequality comparison</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Arithmetic remainder</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Arithmetic remainder and assignment</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>Bitwise AND</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>Bitwise AND and assignment</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Arithmetic multiplication</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Arithmetic multiplication and assignment</td><td><code>MulAssign</code></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Arithmetic addition</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Arithmetic addition and assignment</td><td><code>AddAssign</code></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>Arithmetic negation</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Arithmetic subtraction</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>Arithmetic subtraction and assignment</td><td><code>SubAssign</code></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Arithmetic division</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Arithmetic division and assignment</td><td><code>DivAssign</code></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>Left-shift</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>Left-shift and assignment</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>Less than comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>Less than or equal to comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Equality comparison</td><td><code>PartialEq</code></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>Greater than comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>Greater than or equal to comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>Right-shift</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>Right-shift and assignment</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>Bitwise exclusive OR</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>Bitwise exclusive OR and assignment</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>Bitwise OR</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>Bitwise OR and assignment</td><td><code>BitOrAssign</code></td></tr>
</tbody></table>
<h2><a class="header" href="#deref" id="deref">deref</a></h2>
<p>One common operator is known as the “deref” operator. It's trait is defined as:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Deref {
    /// The resulting type after dereferencing.]
    type Target;
    /// Dereferences the value.
    fn deref(&amp;self) -&gt; &amp;Self::Target;
}
<span class="boring">}
</span></code></pre></pre>
<p>The idea of deref is to allow access to a wrapped inner object. You may have heard invoking a method on a member variable is: “this.foo.bar()” refered to as “dereferencing” the member variable. This is where the name comes from. ‘Box’ implements 'deref’. This allows you to write</p>
<pre><pre class="playpen"><code class="language-rust skt-main">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo();
</span>let b : Box&lt;Foo&gt; = //...
<span class="boring">Box::new(Foo());
</span>let f : Foo = *b;
<span class="boring">}
</span></code></pre></pre>
<p>or even more simply:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">#![allow(unused)]
</span>struct Foo {
    a : u32,
}
fn function(foo: &amp;Foo) {
    //...
}
pub fn main () {
    let b = Box::new(Foo {a: 4});
    function(&amp;b);
}
</code></pre></pre>
<p>This allows you to treat a 'Box<T>’ as though it was a T most of the time, which makes working with Box a lot more convenient.</p>
<p>Similarly <code>MutexGuard</code> implements deref. So you can just write an method like:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;

struct MyObject {
    data : Mutex&lt;Vec&lt;i32&gt;&gt;,
}
impl MyObject {
    fn add_data(&amp;self, new_item: i32) {
        let mut data = self.data.lock().unwrap();
        data.push(new_item);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here <code>data</code> is a <code>MutexGuard</code>, and it will automatically release the lock when it goes out of scope, but <code>data</code> can use the methods on the guarded object directly without having to unwrap it.</p>
<p>Deref can be used with assignment. So with MutexGard you could write:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::sync::Mutex;

struct MyObject {
    data : Mutex&lt;Vec&lt;i32&gt;&gt;,
}
impl MyObject {
    fn add_data(&amp;self, replacement: Vec&lt;i32&gt;) {
        let mut data = self.data.lock().unwrap();
        *data = replacement;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Suppose you want to add some functionality to a type, the easiest way is to wrap it and add the functionality to your wrapper. For example to make an existing type sortable, in Java it would look like.
__
In Rust it would look like __. Of course you probably want to get the original object out of your wrapper so you can actually use it. In Java you might use a getter. In Rust you would use Deref. Deref is the trait the corresponds with the ‘*’ prefix operator. So you can do this __.</p>
<p>The deref method will automatically be invoked by the compiler any time an object is passed to a method expecting a type that it can deref into. This means for example you could pass an object like this __ because the method is implemented for _ and the wrapper will automatically have its deref method called and the result passed to the function.</p>
<p>A good example of this is String. Strings much like arrays support slicing. So you can take a view of a subset of a string. This is similar to the way in Java you can have a ByteBuffer which provides a view of a subset of a byte array. String implements Deref for str. Given a borrowed string it returns a borrowed slice containing the whole string. So you invoke deref explicitly or just pass a String anywhere a string slice is expected, the conversion is done for you automatically. This is even true when invoking methods on the object. Say you have a borrowed String. You can call ‘.chars()’ and get the characters in the string. Even though the ‘chars’ method was actually defined for the string slice.</p>
<p>Now imagine that for your own wrapper types, it means they be generic to what they contain an still allow the caller to invoke whatever methods they need on the wrapped object with no syntactic overhead safely without any ambiguity. (Cool right?) It should be noted that because Deref is automatic, it is not meant for costly conversions. For that you should use the ‘From’ or ‘Into’ traits. Where the conversion is more explicit.</p>
<h2><a class="header" href="#drop" id="drop">Drop</a></h2>
<p>There is one more common operation that can be overloaded, but it does not have any explicit syntax. That is <code>Drop</code>.
Because Rust's memory management is deterministic it is possible to have a method run right before a object is dropped.</p>
<p>This can be done by implementing the <code>Drop</code> trait, which is defined as:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Drop {
    fn drop(&amp;mut self);
}
<span class="boring">}
</span></code></pre></pre>
<p>This is implemented on Sockets and Files. Drop is in some ways similar to Java's <code>AutoClosable</code> which can is used to make
&quot;try-with&quot; resources that have their close method called at the end of a try block.</p>
<p>Drop is different in that the that the cleanup method <code>drop</code> is always called when the object goes out of scope.
So there is no need for a special block or syntax required. It also makes it impossible to forget to use the method/syntax.
This is why they say <a href="https://blog.skylight.io/rust-means-never-having-to-close-a-socket/">Rust Means Never Having to Close a Socket</a>.</p>
<p>Implementations of Drop cannot fail and shouldn’t block. So sometimes is there are still <code>close()</code> methods in case for
example an RPC needs to be made.</p>
<p>A good example of where this is used is <code>Mutex</code>, these are used for synchronization and will be discussed more in the next chapter. The mutex returns a mutexguard object. This is a wrapper object that holds the lock while it is in scope. The mutexguard locks the mutex when it is created and unlocks it when it goes out of scope. IE:__ Because he only to access the value is though the mutexguard it is impossible to misuse the interface. If you have access to the variable you must be holding a lock. There is no way to forget to either acquire or release the lock.</p>
<p>If in Java an exception is thrown from inside of a synchronized block, (assuming it is not caught inside) the lock will be released and the exception will propagate up the stack. Certainly this is desirable in the case where the exception is being deliberately thrown. But in the event of an Error this might be undesirable. The lock will be released and other threads will proceed to use it even though it only completed half of the critical section. This might be harmless or it might leave the object in a bad state and trigger weird problems in other threads. This is an example of why treating unexpected and expected errors in the same way is not a great idea.</p>
<p>Rust resolves this by distinguishing between an panic and a normal error. It is expected that critical sections may return errors. If they do, the lock is released normally and other threads can use the guarded resource. Critical section however are not expected to panic. If one does, in the destructor of the mutexguard it will detect the panic and “poison” the lock. This will mean any thread attempting to acquire the lock will receive an error and won’t be able to access the guarded resource. This acts as a safety check against the data being left in an inconsistent state.</p>
<h1><a class="header" href="#lifetimes" id="lifetimes">Lifetimes</a></h1>
<p>Lifetimes are a way to specify additional information about borrows in order to convince the compiler that what you are
attempting to do makes sense. They will only effect whether or not code can compiler and have no effect on at runtime.</p>
<p>Consider the following code:</p>
<pre><pre class="playpen"><code class="language-rust">fn print_str_twice(string: &amp;str) {
    println!(&quot;{}  {}&quot;, string, string);
}
fn main() {
    let mut greeting = &quot;Hello&quot;.to_string();
    print_str_twice(&amp;greeting);
    greeting += &quot; world&quot;;
    println!(&quot;{}&quot;, greeting);
}
</code></pre></pre>
<p>Here the function <code>print_str_twice</code> borrows the argument <code>string</code>. Because the borrowed value cannot be held after the
function returns, and there is no return value from the function the compiler is able to work out that it's ok to modify
<code>greeting</code> on the next line.
But if the code looked like this:</p>
<pre><code class="language-rust ignore">fn get_tail_of_string(string: &amp;str) -&gt; &amp;str {
    &amp;string[1..]
}
fn main() {
    let mut greeting = &quot;Hello&quot;.to_string();
    let bad = get_tail_of_string(&amp;greeting);
    greeting += &quot; world&quot;;
    println!(&quot;{}&quot;, greeting);
    println!(&quot;Oops {}&quot;, bad);
}
</code></pre>
<p>This will generate a compile error because <code>greeting</code> is borrowed in <code>get_tail_of_string</code> and part of it is returned and
assigned to <code>bad</code>. This is a problem because <code>greeting</code> is modified on the next line, but <code>bad</code> ends up getting used later.</p>
<p>So how was the compiler so smart? The answer is that it automatically generated some <code>lifetimes</code> and applied them to the
method signature of <code>get_tail_of_string</code>.</p>
<p>When a method borrows parameters the compiler needs to track how long those borrows live so it can determine if code should
compile. This process works similar to generics. For example the method signature:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Foo {
</span>  fn some_function&lt;T&gt;(arg1: &amp;T);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>is actually the same as:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Foo {
</span>  fn some_function&lt;'a, T&gt;(arg1: &amp;'a T);
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Which means that the parameter <code>arg1</code> is borrowed for however long the value passed into arg1 lasts. Of course this is
a completely unnecessary statement, and hence can be simply omitted. (The naming convention is to start with ‘a for the
first parameter and then ‘b, 'c' etc. Lowercase letters are used to distinguish lifetime from normal type parameters like <code>T</code>)</p>
<p>However in the more complex case:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo{a:str} struct Bar {}
</span>  fn some_function&lt;'a, 'b&gt;(arg1: &amp;'a Foo, arg2: &amp;'b Bar) -&gt; &amp;'a str
<span class="boring">{&amp;arg1.a}
</span><span class="boring">}
</span></code></pre></pre>
<p>Here the lifetime is meaningful and needs to be specified. Here the signature is providing the information that function
accepting two arguments <code>arg1</code> and <code>arg2</code> and these live however long the parameters passed as these values live, and the
return type lives as long as <code>arg1</code>. This means in this case that the return value is being derived from the first parameter
and not the second one. This will allow the compiler to check the calling code to make sure this is Ok.
(You don't need to know where the inputs came from or how long they will live. The compiler will just check everything.)</p>
<p>If the returned value were derived from the second parameter the function signature would look like:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo{} struct Bar {a:str}
</span>  fn some_function&lt;'a, 'b&gt;(arg1: &amp;'a Foo, arg2: &amp;'b Bar) -&gt; &amp;'b str
<span class="boring">{&amp;arg2.a}
</span><span class="boring">}
</span></code></pre></pre>
<p>What if the result could be derived from either parameter and which one won't be know until run-time?
For example a function that returns the longer of two string slices. That would look like:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>  fn get_longer&lt;'a&gt;(arg1: &amp;'a str, arg2: &amp;'a str) -&gt; &amp;'a str
<span class="boring">{arg1}
</span><span class="boring">}
</span></code></pre></pre>
<p>In this case the compiler will infer a lifetime for 'a that must work for both parameters, and use this lifetime when
reasoning about the returned value.</p>
<p>In general the compiler is able to automatically figure out the lifetimes, and nothing needs to be specified. For example
with methods that are being invoked on an object such as:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait CharTrimmer {
  fn trim_chars(&amp;self, chars_to_remove: &amp;str) -&gt; &amp;str;
}
<span class="boring">}
</span></code></pre></pre>
<p>It is by default assumed that the source of any returned parameter is from the <code>self</code> argument. So the lifetimes would
be automatically inferred as:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait CharTrimmer {
  fn trim_chars&lt;'a&gt;(&amp;'a self, chars_to_remove: &amp;str) -&gt; &amp;'a str;
}
<span class="boring">}
</span></code></pre></pre>
<p>However if this is not the case, it can be clarified by specifying a different lifetime.</p>
<p>Lifetimes, only really come up when dealing with items that are being borrowed and parts are being passed out of the original called
either by a return value or embedding them in a struct, and never with owned items. So they tend to be a nitch feature.</p>
<p>For a much more complete exploration of the exotic cases of lifetimes see the post <a href="http://cglab.ca/%7Eabeinges/blah/too-many-lists/book/second-iter.html">&quot;Too many lists&quot;</a>.</p>
<table width="100%">
<tr>
<td> 
<p><img src="images/borrow.png" alt="Safety monitor" /></p>
</td>
<td width="80%">
<blockquote>
<p><em>Don't worry about making a mistake with lifetimes. If you declare lifetime to be too short or to long, I'll catch your mistake and show you the code path where it goes wrong. If it compiles it will do the right thing at runtime.</em></p>
</blockquote>
</td>
</tr>
</table>
<h2><a class="header" href="#static" id="static">'static</a></h2>
<p>There is one special lifetime: <code>'static</code>. This is used to indicate the reference can live for as long as the program is
running. For example when a constant string is defined:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let greeting = &quot;Hello world!&quot;;
  //...
}
</code></pre></pre>
<p>the type of greeting is actually: <code>&amp;'static str</code>. Meaning that it is valid to hold onto <code>greeting</code> forever because the
string constant <code>&quot;Hello world!&quot;</code> will always be available. (Because string constants are part of the program itself
and hence by definition exist for the lifetime of the program. You can of course borrow them, and when you do they
have a static lifetime.) This is also be used as the lifetime for for statics and constants.</p>
<p>So if a function takes a 'static string such as:</p>
<pre><pre class="playpen"><code class="language-rust skt-default">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn only_const_strings(arg: &amp;'static str)
<span class="boring">{}
</span><span class="boring">}
</span></code></pre></pre>
<p>This would restrict the values that can be passed into the method to only be string constants, or their derivatives.</p>
<h1><a class="header" href="#cool-rust-tricks" id="cool-rust-tricks">Cool Rust Tricks</a></h1>
<p>Rust is built on the idea of &quot;Zero Cost Abstractions&quot;.
This means that unlike in Java, <a href="https://www.youtube.com/watch?v=Sn3JklPAVLk">if you add a wrapping layer or extra traits, this won't add any overhead</a></p>
<p>So you can define:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#![allow(dead_code)]
</span><span class="boring">#![allow(unused)]
</span>struct AppendOnlyVec&lt;T&gt; {
    inner: Vec&lt;T&gt;,
}
impl&lt;T&gt; AppendOnlyVec&lt;T&gt; {
    fn new(v: Vec&lt;T&gt;) -&gt; AppendOnlyVec&lt;T&gt; {
        AppendOnlyVec{ inner: v }
    }
    fn push(&amp;mut self, new_element: T) {
        self.inner.push(new_element);
    }
    fn into_vec(self) -&gt; Vec&lt;T&gt; {
        self.inner
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>This type wraps a vec (by taking ownership of it so that it cannot be modified elsewhere).
At compile time this struct will get inlined, as will all of the method implementations.
After complication the only thing left is primitives and gotos. Exactly as though everything were written in hand optimized assembly.</p>
<p>So the above example and other similar abstraction can be added to clarify code without any overhead.</p>
<p>Compared to Java this model allows Rust to have very low memory use.
For example when <a href="https://www.rust-lang.org/static/pdfs/Rust-Tilde-Whitepaper.pdf">Tilde started using Rust</a>
their memory use decreased by 99%.</p>
<h2><a class="header" href="#unsafe" id="unsafe">Unsafe</a></h2>
<h3><a class="header" href="#todo-1" id="todo-1">TODO</a></h3>
<ul>
<li>Unsafe Rust is still saver than C.
<ul>
<li>Ownership, borrowing, and types are all still enforced.</li>
<li>You can perform casts, write to raw memory, call CPU instructions, and call C code.</li>
</ul>
</li>
<li>Normal pattern is to isolate unsafe code and wrap it in a safe interface.
<ul>
<li>Add lots of tests to validate what the compiler cannot.</li>
</ul>
</li>
<li>Example: <code>split_at_mut()</code></li>
</ul>
<h1><a class="header" href="#writing-mactos" id="writing-mactos">Writing Mactos</a></h1>
<ul>
<li>Vs reflection</li>
</ul>
<p>Because Rust compiles into a static binary and doesn't have a runtime, it cannot have a feature similar to Java's reflection. However that doesn't mean metaprogramming is impossible. Instead Rust has <em>Macros</em>. These are functions that run at compliation time which transform one chunk of code into another. In Rust macros can be used to implement things that fill the same role as things like: Javassist, Lombok, Spring, and AspectJ. Which is to say a normal program will almost never use  directly, but it is quite common to used some library or framework that uses macros.</p>
<p>The most common use for Macros is to reduce boiler plate code. Some examples of this are </p>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/trait/derive.html">derive</a> which elimates the need to manually write: <code>Eq</code>, <code>Ord</code>, <code>Clone</code>, <code>Copy</code>, <code>Hash</code>, <code>Default</code>, and <code>Debug</code>. </li>
<li><a href="https://mcarton.github.io/rust-derivative/">derivative</a> whaich adds additional configuration to customize code generated by derive.</li>
<li><a href="https://jeltef.github.io/derive_more/derive_more/index.html">derive-more</a> which automates <code>From</code>, <code>Into</code>, <code>FromStr</code>, <code>Display</code>, <code>Index</code>, <code>Not</code>, <code>Add</code>, and <code>Mul</code>.</li>
<li><a href="https://crates.io/crates/derive-new">derive-new</a> which automates generating constructors.</li>
<li><a href="https://crates.io/crates/derive_builder">derive-builder</a> which automates generating builders.</li>
<li><a href="https://serde.rs/">serde</a> which automatis writing serialization and deserialization code.</li>
<li><a href="https://crates.io/crates/structopt">structopt</a> which automates writing code to parse command line flags.</li>
</ul>
<p>The other common use for Macros is to validate things at compile time. We've already seen examples of this in macros like <code>println!</code> and <code>format!</code>, but it also includes more complex validation and templating. This is a great way to prevent all sorts of security vunraibilites some examples include:</p>
<ul>
<li><a href="https://rocket.rs/">rocket</a> uses macros to validate the configuration of an HTTP server at compile time.</li>
<li><a href="http://diesel.rs/">diesel</a> uses macros to validate SQL queries at compile time.</li>
<li><a href="https://maud.lambda.xyz/">maud</a> validates html templates at compile time.
A side benifit to doing work at compile time rather than at runtime, is a <a href="https://lambda.xyz/blog/maud-is-fast/">boot to perfromance</a>.</li>
</ul>
<p>Macros work by running code at compilation time. The code that is run is pure Rust code, which means that it can also use Macros. So macros can even be used to write other macros. One example of this which is useful for very simple macros is <a href="https://crates.io/crates/defmac">defmac</a> which is a macro, that allows you to write what looks like an anonymous function but the parameters can be anything, like a function name for example. This is useful for reducing repitition in unit tests. The more general way to write a macro is to define a function for example:</p>
<pre><code class="language-rust ignore">use proc_macro;
use proc_macro::TokenStream;

/// Macro for HTML templating ...
#[proc_macro]
pub fn html(input: TokenStream) -&gt; TokenStream {
    //Read input TokenStream to parse provided arguments
    //Output a TokenStream of Rust code to replace the input with
<span class="boring">input
</span>}
</code></pre>
<p>Similarly to define an attribute that is associated with a function: </p>
<pre><code class="language-rust ignore">use proc_macro;
use proc_macro::TokenStream;

/// Macro for logging all calls to a function.
#[log_calls]
pub fn implementation_of_log_calls(input: TokenStream) -&gt; TokenStream {
    //Read a TokenStream and return a modified TokenStream that logs the parameters
<span class="boring">input
</span>}
</code></pre>
<p>Or you can have a function extend <code>derive</code>:</p>
<pre><code class="language-rust ignore">use proc_macro;
use proc_macro::TokenStream;

/// Automatically generate the implementation of `SomeTrait` for your type.
#[proc_macro_derive(SomeTrait)]
pub fn some_trait_derive(input: TokenStream) -&gt; TokenStream {
    //...
<span class="boring">input
</span>}
</code></pre>
<p>In each case the implementation needs to deal with a <code>TokenStream</code>. Fortunatly there are libraries to help with this. Two of the most important are:</p>
<ul>
<li><a href="https://crates.io/crates/syn">syn</a> which parses a Rust <code>TokenStream</code> into an abstract syntax tree and allows you to operate on structs. </li>
<li><a href="https://crates.io/crates/quote">quote</a> which takes a code template, and inserts values into it from variables. 
Most macro implmentations use these two libraries. </li>
</ul>
<h1><a class="header" href="#command-line-programs" id="command-line-programs">Command line programs</a></h1>
<ul>
<li>Signals (os)</li>
<li>DSL</li>
<li>Builder pattern works the same way in both langs, but ownership sometimes helps</li>
<li>Clap and glob</li>
</ul>
<p>Command line applications is another area where rust shines. Normally you might write things in bash but it quickly becomes unreadable after a couple hundred lines of code. Pearl and Python are commonly used and work reasonably well but they have some serious drawbacks in both performance and compatibility. (IE if you wrote and tested you code on version 2.3 on Linux, it might or might not work running in version 2.2 on Windows) You could use Java, Go, or C++ but they involve writing a fair amount of boilerplate and they never really feel very natural for command line application. Where as Rust has high level features and ability to run on Windows, Mac, and Linux without any special work. It can do this by compiling into a single binary file that has no dependencies on any vm, interpreter, or library already being installed on the system. Additionally libraries like <code>clap</code> or <code>quicli</code> make parsing args easy.</p>
<h1><a class="header" href="#example-program" id="example-program">Example program</a></h1>
<p>TODO:
Web server example (mio, surdie, tokio, rotor, hyper)</p>
<ul>
<li>Writing a parser</li>
<li>Performance</li>
</ul>
<h1><a class="header" href="#webasm" id="webasm">Webasm</a></h1>
<p>these days almost everyone uses JavaScript and not job in the browser. You could use a tool kit like GWT to do cross compilation but this comes with some significant downsides. So generally speaking if you're using Java and your back and you usually use JavaScript in your front end. in practice this eliminates shared code which is often necessary to do things like validation. it is often difficult to have two copies of the same code written in different languages, and in practice probably by different people, maintained identical functionality as changes are made over time. so this gives rise not only to wasted time and effort but also potentially to security vulnerabilities, an area where JavaScript is already not great.</p>
<p>Rust can execute through something called Web assembly. This means programs written in Rust can safely run in the browser without any special plugin. This allows you to use Rust for both your front-end and back-end code. It also provides your in-browser code with the safety of Rust and the performance of native code. This is a huge win for productivity because it means you can have a single code base with a much higher degree of validation testing.</p>
<h1><a class="header" href="#using-rust-with-java" id="using-rust-with-java">Using Rust with Java</a></h1>
<ul>
<li>Crossbeam</li>
<li>Jni crate</li>
<li>Unsafe
<ul>
<li>Don’t do it.</li>
<li>Not faster</li>
<li>Really unsafe.</li>
<li>Better to have tiny parts like split at mut</li>
<li>Just because you can doesn't mean you should.</li>
<li>Use sanitizers and prop/quickcheck or fuzzer</li>
<li>Rust-san
<ul>
<li>Note that rust has __ enabled by default. (As opposed to go)</li>
</ul>
</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
