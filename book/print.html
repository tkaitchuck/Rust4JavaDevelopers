<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust for Java developers</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guiide to learning Rust for developers familiar with Java">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="why_rust.html"><strong aria-hidden="true">1.</strong> Why Rust</a></li><li><a href="history_of_rust.html"><strong aria-hidden="true">2.</strong> History of Rust</a></li><li><a href="rust_community.html"><strong aria-hidden="true">3.</strong> The Rust Community</a></li><li><a href="variable_declaration.html"><strong aria-hidden="true">4.</strong> Variable declaration</a></li><li><a href="method_signatures.html"><strong aria-hidden="true">5.</strong> Method Signatures</a></li><li><a href="flowcontrol.html"><strong aria-hidden="true">6.</strong> Flowcontrol</a></li><li><a href="ownership.html"><strong aria-hidden="true">7.</strong> Ownership</a></li><li><a href="objects.html"><strong aria-hidden="true">8.</strong> Objects</a></li><li><a href="traits.html"><strong aria-hidden="true">9.</strong> Traits</a></li><li><a href="generics.html"><strong aria-hidden="true">10.</strong> Generics</a></li><li><a href="collections.html"><strong aria-hidden="true">11.</strong> Collections</a></li><li><a href="enums.html"><strong aria-hidden="true">12.</strong> Enums, tuples, and aliases</a></li><li><a href="modules.html"><strong aria-hidden="true">13.</strong> Modules</a></li><li><a href="cargo.html"><strong aria-hidden="true">14.</strong> Cargo</a></li><li><a href="equivalent_frameworks.html"><strong aria-hidden="true">15.</strong> Equivalent frameworks</a></li><li><a href="error_handling.html"><strong aria-hidden="true">16.</strong> Error handling</a></li><li><a href="rust_makes_you_better_at_java.html"><strong aria-hidden="true">17.</strong> How Rust makes you a better Java programmer</a></li><li><a href="concurrency.html"><strong aria-hidden="true">18.</strong> Concurrency</a></li><li><a href="testing.html"><strong aria-hidden="true">19.</strong> Testing</a></li><li><a href="debugging.html"><strong aria-hidden="true">20.</strong> Debugging</a></li><li><a href="operator_overloading.html"><strong aria-hidden="true">21.</strong> Operator Overloading</a></li><li><a href="lifetimes.html"><strong aria-hidden="true">22.</strong> Lifetimes</a></li><li><a href="cool_rust_tricks.html"><strong aria-hidden="true">23.</strong> Cool Rust Tricks</a></li><li><a href="writing_macros.html"><strong aria-hidden="true">24.</strong> Writing Mactos</a></li><li><a href="command_line_programs.html"><strong aria-hidden="true">25.</strong> Command line programs</a></li><li><a href="example_program.html"><strong aria-hidden="true">26.</strong> Example program</a></li><li><a href="webasm.html"><strong aria-hidden="true">27.</strong> Webasm</a></li><li><a href="rust_with_java.html"><strong aria-hidden="true">28.</strong> Using Rust with Java</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust for Java developers</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#why-rust" id="why-rust"><h1>Why Rust</h1></a>
<ul>
<li>Rust’s goals: Safe, Performant, productive, general purpose</li>
<li>A lot of competition.</li>
<li>No language has really been able to fully win over the general purpose space since C.</li>
<li>To succeed languages need to be not just a little better but a lot better.</li>
<li>Rust is a lot better.</li>
</ul>
<p>Rust is designed to be a safe, productive, and performant general-purpose programming language.</p>
<p>In that space there is a lot of competition. New language since c has ever really taken over that space. C++, Python, Java, and C# have each, carved off a piece of that space. But none of them have ever really been able to be the best in all of the different niches.</p>
<p>To even carve off a portion of this space is quite a challenge because any new language has to be better than the best language out there for a given usecase. It can't be just a little bit better either. It has to be a lot better, because there are huge switching costs. Libraries need to be rewritten. People need to be retrained. To gain traction a new language needs to be a lot better.</p>
<p>Rust is a lot better.</p>
<p>Rust is still very young but it's starting to compete with other languages on their own terms. Some have argued that may soon be better for web development than Javascript. And in many ways it is already a better C++ than C++. But, as I will argue in this book: Rust is a better Java than Java.</p>
<p>I decided to write this book because a lot of the Rust documentation was written in a way that was geared towards people coming from C++. If you know about pointers, memory layout, and RIIA are second nature to you, then these explanations make sense. I wanted to go in a different direction describe Rust from the perspective of Java. As such, this book won’t mention any of those things, and will describe and define how Rust work from the perspective of a Java developer. This book is first and foremost targeted at developers who already know and have experience in Java and are looking to learn Rust. If this is not your situation you might still get a fair amount out of this book but it is not my goal.</p>
<p>Throughout, the book will provide side-by-side comparisons of Java and Rust code that is identical in functionality. Because the goal is to facilitate comparison between the languages sometimes the examples are not idiomatic Rust or idiomatic Java. Rather they are written to make the comparison clear and direct.</p>
<p>Throughout the book we’ll have running commentary from two characters:
The Safety Monitor: “Hi, I make sure your program is correct, and won’t fail at runtime. A lot of people call me ‘the borrow checker’ because that’s a big part of my job. But I do more than that. I enforce style guidelines, memory safety, thread safety, type safety and more. I’ll act as a guide and alert you if you do anything that could go wrong.”
The optimizer: “Hi, I focus on making everything you write go as fast as possible. My goal is to allow you to write code in the safest, most readable, way possible so you don’t make mistakes. Then once she has approved it, I’ll take over and remove all of those abstractions so they don’t cost you a thing. Then I fine tune everything to be as fast as if you had written it all in assembler by hand.”</p>
<a class="header" href="#history-of-rust" id="history-of-rust"><h1>History of Rust</h1></a>
<blockquote>
<p><strong>“The Beast adopted new raiment and studied the ways of Time and Space and Light and the Flow of energy through the Universe. From its studies, the Beast fashioned new structures from oxidised metal and proclaimed their glories. And the Beast's followers rejoiced, finding renewed purpose in these teachings.”</strong><br />
-- The Book of Mozilla, 11:14</p>
</blockquote>
<p>In the early days of computer programming, all programs were what today we would call proceederal. Which gave rise to various ways to organize code. However it was quickly realized that mutable shared state was the root of most bugs.</p>
<p>So two divergent sets of practices arose. Functional programming which sought to remove the mutability, and write code using only immutable data. And object oriented programming which sought to use encapsulation to prevent state from being shared.</p>
<p>Both approaches have been developed over the course of decades. Now they both work quite well. However they usually don't work together. This is because it is very easy to combine ideas from the two and end up with shared mutable state, which loses the benefit of both approaches. So while there have been many ideas that have crossed over from OO languages to Functional languages and vice versa, the have been limited and adapted to the language they are in, and in general don't achieve the same effect they do in the language they came from.</p>
<p>The most important idea in Rust is to go beyond this dichotomy. By allowing state to be mutable and shared, but not at the same time Rust can bring the full power of Object Orientation and Functional programming to bare in the same language at the same time. It also opens the door to future paradigms that just aren't practical in other languages.</p>
<p>Work on Rust began in earnest in 2009 at Mozilla based on a prototype that Graydon Hoare had been working on for a few years previously. After three years of development the first pre-alpha version of the compiler was released in 2012.</p>
<p>Shortly after the first release Graydon stepped back from the project. This change was a hugely important milestone, because it allowed other people step up. This allowed the project to move to a open governance model, with many people providing different perspectives. Over the next three years the language changed, a lot. New features were added and more importantly several features were removed or moved into third party libraries. These changes dramatically improved the language, because it turns out a lot of ideas that sound great don’t turn out so well in practice.</p>
<p>Rust’s evolution because changes were always anchored in very practical concerns as the core team spent most of their time working on Firefox. (a 4.4 million line C++ code base.) Eventually, in 2015 Rust 1.0 was released. This marked the first point where code could be written and still compile later. This marked a major change from pre-1.0 where if code that was more than 6 months old, you might as well rewrite it because the language was changing so quickly.</p>
<p>Since 2015 many features were added or modified, or moved out into libraries, but compatibility was always maintained. However overtime, things arose that would be better if compatibility could be broken. So to maintain their release frequency, and to avoid getting stuck in the compatibility trap that a lot of languages find themselves in, the Rust project team settled on a release system, where compatibility would with old versions would be maintained, but every three years a backwards incompatible changes would be introduced in a new ‘epoch’. The ‘epoch’ is specified explicitly and multiple different ones can co-exist in the same program. So the language can be stable, but without stagnating.</p>
<p>As of this writing the latest version is the 2018 release which contains a lot of improvements over Rust 1.0. It has been a rare pleasure to watch Rust continue to make rapid and significant improvements even as it’s usage grows. I believe this is a big part of why it was voted the “Most Loved Language” in the StackOverflow developer survey in 2016, 2017, and 2018. The percent of developers who have used it has grown each year, and the percentage of those who ‘love it’ has grown each year also.</p>
<ul>
<li>Genealogy of rust
<ul>
<li>Add Haskell ocammel and cyclone</li>
<li>Add a note about newsqueek</li>
</ul>
</li>
<li>Rust community</li>
<li>Rust rfc process
<ul>
<li>Pluralism and positive sum game (multiple sources of authority working together)</li>
<li>DIfferent perspectives reach a better solution
<ul>
<li>Yelling lowder and ‘thicker skin’ is bad because it does not bring new insight</li>
<li>https://aturon.github.io/2018/06/02/listening-part-2/</li>
<li>Humility, empathy, and introspection</li>
</ul>
</li>
</ul>
</li>
<li>https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html</li>
</ul>
<p>As the name implies Rust isn’t about new ideas. It’s about taking well established and vetted ideas, and putting them together in a coherent way. Almost nothing in Rust is completely original. So in this guide you will see lots of familiar concepts, but they fit together very well..</p>
<p>While it might not be immediately obvious from looking at the language, you can see in the genealogy ___ that Rust and Java are actually closely related. Rust draws heavily from Java's immediate parent C++ as well as C# which was very heavily influenced by Java. Java's philosophy is also present throughout Rust.
Goals of Rust
Safety
Java was the first popular language to embrace the idea of safety. Unlike lower level languages Java prohibits users from directly manipulating memory or doing other dangerous operations, and unlike a lot of other high-level language is it has a strong type system which ensures that you don't get errors at runtime that could be caught earlier. Rust takes this idea of safety and really runs with it. It aims to prevent as many bugs as possible from reaching production by making incorrect code impossible to write. It not only has a strong type system that integrates generics, it expands on this idea and prevents null pointers and thread safety issues at compile time.</p>
<p>Rust’s primary goal is to prevent errors. If it is possible errors should be prevented at compile time.</p>
<p>Safety monitory: “The safest program is the program that doesn't compile”</p>
<p>Like Java, Rust prevents use of uninitialized memory, dangling pointers, use after free, memory leaks, type errors, and provides exception safety. But Rust goes further and also prevents iterator invalidation / ConcurrentModificationExceptions, null pointers, resource leaks, ordering bugs due to static initialization, partial initialization and data races in multi threaded code.
Portability
Java has a goal that you should build your code once and be able to run anywhere Rust doesn't quite have the same goal: it has the goal that you should be able to write your code once, compiler it many times, and have it run almost anywhere. Rust compiles to native code on each platform it supports which as of today is _ CPU architectures, Windows, MacOS, Linux, Bsd, all major web browsers, Android, iOS, and even _ different micro controllers. Part of the reason that Rust is able to be ond so many architectures is that it is self-hosting. The Rust compiler is written in Rust. The standard library is also written in Rust and it depends on very little native code. Rust even brings its own memory allocator. Because Rust compiles using llvm, as long as there is an llvm target available for a system, Rust can target it.
Performance
Usability</p>
<ul>
<li>Be a Good language
<ul>
<li>Safe, concurrent, practical</li>
<li>We can have nice things</li>
</ul>
</li>
<li>Be usable
<ul>
<li>Many platforms</li>
<li>Package management</li>
<li>Build system and test harness</li>
<li>Fast enough that you won't need anything else.</li>
</ul>
</li>
<li>Pillars of rust
<ul>
<li>Speed without wizardry
<ul>
<li>http://fitzgeraldnick.com/2018/02/26/speed-without-wizardry.html</li>
</ul>
</li>
<li>Memory safety without garbage collection</li>
<li>Concurrency without data races</li>
<li>Abstraction without overhead</li>
<li>Stability without stagnation
<ul>
<li>No unexpected changes to language and functionality
<ul>
<li>Across versions</li>
<li>By depending on something</li>
</ul>
</li>
</ul>
</li>
<li>Hack without fear.
<ul>
<li>Confident systems programming</li>
</ul>
</li>
<li>Rust: fast, reliable, productive—pick three.</li>
<li>Zero cost abstractions
<ul>
<li>4 compiler optimization phases.</li>
<li>Normal code is just as fast as unsafe if you can explain to the compiler why it is safe</li>
<li>Zero size types mean hashMap&lt;k,()&gt; == set&lt;&gt; with not overhead.</li>
</ul>
</li>
</ul>
</li>
<li>API guidelines https://rust-lang-nursery.github.io/api-guidelines/
<ul>
<li>https://deterministic.space/elegant-apis-in-rust.html</li>
<li>Don't use booleans in API use named enums. It is more readable at the call site.</li>
</ul>
</li>
<li>Rust is implemented in Rust.
<ul>
<li>Look at String, or Vec, or Exceptions, or Channels or anything else, it’s written in pure rust.</li>
<li>THere are a number of primitives but all of the standard library is built on just these primitives. It doesn’t break out into some other language or ‘native’ code.</li>
<li>For example, you can perform a lot of fancy operations on Strings. But a lot of those actually just come from iterator, which automatically provides a lot of functionality for types that implement it. But Strings implementation of iterator isn’t some special native code, in fact String itself is just a Vec of UTF-8 characters. Vec is itself is a struct.</li>
<li>This allows Rust to be compiled and built in Rust, but more importantly it has forced those primitives on which the language is build to be sufficiently robust and flexible to support everything above them. And when one of those basic building blocks improves, everything above them benefits.</li>
</ul>
</li>
<li>Rust itself if a somewhat complicated language. It has a lot of features, more than Java (Though not as many a c++). But this is everything. The standard library is built using just these primitives, and compared to most languages (Especially Java) it’s standard library is small. Most of the features are developed externally to the language itself. Even things you wouldn’t necessarily expect, like Non-blocking IO, Concurrency support, and even Exceptions.
<ul>
<li>This allows these components to be versioned independently and evolve more quickly than the language itself. It also allows competing libraries to replace them when they have a superior design.</li>
<li>Key to making this work is a built in dependency management system: Cargo. There will be a full chapter on it later.</li>
<li>….</li>
</ul>
</li>
<li>Culture of documentation</li>
<li>Culture of testing</li>
<li>Culture of inclusivity</li>
<li>Clippy</li>
</ul>
<a class="header" href="#what-makes-a-good-language" id="what-makes-a-good-language"><h2>What makes a good language?</h2></a>
<ul>
<li>Code can be imagined as shapes
<ul>
<li>Width is interface complexity</li>
<li>Depth is complexity of problem</li>
<li>Volume is proportional to code volume
<ul>
<li>Some languages are more concise and others more verbose, but this doesn't matter</li>
</ul>
</li>
<li>Narrow and Deep is better</li>
<li>Too shallow is worse than useless</li>
</ul>
</li>
<li>The best language is the one in which you write the best code.
<ul>
<li>Code can have problems:</li>
<li>Redundant</li>
<li>Interface covers things the impl doesn't</li>
<li>Interface is complicated</li>
<li>Poorly factored</li>
</ul>
</li>
<li>It is better if a language allows you to make three transformations
<ul>
<li>Factor out code</li>
<li>Generalize</li>
<li>Refine interface (eliminate unsupported features)</li>
<li>Shrink width (reducing impl)</li>
<li>Shrink interface preserving volume.</li>
</ul>
</li>
<li>A language feature is good if it let's you do these things.
<ul>
<li>It is bad if it causes the reverse
<ul>
<li>Example: exceptions and futures together.</li>
</ul>
</li>
</ul>
</li>
<li>Some languages enable all the things, others say none of them</li>
<li>To decide which are good think in terms of a standard library.
<ul>
<li>Where to draw the line?</li>
<li>To the left slows discourages improvement by impeding replacement and slowing development</li>
<li>To the right causes distribution issues.</li>
<li>For Java including a large stdlib was great… at first</li>
<li>Today we have deps management tools. So j2ee and similar things are now out. If this were the norm in 1995 java would be different.</li>
<li>This refactoring visualized
<ul>
<li>From the perspective of any given developer</li>
</ul>
</li>
</ul>
</li>
<li>Language features and the stdlib and the languages interface.</li>
<li>A language is just like any other program, it's just more important to get right.
<ul>
<li>It is bad if It has coupling with other features, causing the interface of the language, or worse application code to expand. (For this reason it is important that features be orthogonal and well factored) this is true of all interfaces but for a language it is more important because they have a lot of dependant code.</li>
<li>Causes ambiguity about what something does</li>
<li>Is easily confused with another feature/behaviour in the same language</li>
<li>Introduces inconsistency: An internal library can do something but a user library can’t copy that code and have it work</li>
<li>Forces additional complexity anywhere it isn’t used</li>
<li>Introduces a source of potential bugs</li>
<li>Causes a runtime failure, in the event that the user’s code is using it incorrectly</li>
<li>Makes errors go undetected</li>
<li>Forces repetition that can’t be factored out</li>
</ul>
</li>
<li>So a feature is good in a language if adding it:
<ul>
<li>Hide a lot of complexity behind a simple interface (ie: is just good code)</li>
<li>If it can't be implemented in application code and be effective. (Note this may be a red flag, as we want the minimal set)</li>
<li>Shrinks the overall interface by allowing code to be moved out. (As in the above example)</li>
<li>If it allows external code to shrink their interfaces</li>
<li>If it allows for external code to refine their interfaces</li>
<li>Serves can’t be met by normal library or application code</li>
<li>Moves bugs from latent to explicit, or from runtime to compile time</li>
</ul>
</li>
<li>Great features:
<ul>
<li>Interfaces and polymorphism</li>
<li>Generics
<ul>
<li>Constraint Based Generics and Parametric Polymorphism</li>
</ul>
</li>
<li>Symbols for complex but well defined tasks that can be plugged into
<ul>
<li>enhanced for loop</li>
<li>Try / with resources</li>
<li>Functional interfaces</li>
</ul>
</li>
<li>Exceptions
<ul>
<li>Algebraic Types and Type-safe Failure Modes</li>
</ul>
</li>
<li>Rust feature: Algebraic Types and Type-safe Failure Modes (more on this later)</li>
<li>Type Inference
<ul>
<li>Rust uses the Hindley-Milner type system, which is considered the best at this.</li>
</ul>
</li>
<li>Immutability
<ul>
<li>Better: Immutable by default.</li>
<li>Even better: Marking when data is modified.</li>
</ul>
</li>
<li>Pattern Matching and Compound Expressions</li>
<li>Isolating dangerous / low level operations</li>
<li>https://yager.io/programming/go.html</li>
</ul>
</li>
</ul>
<a class="header" href="#the-rust-community" id="the-rust-community"><h1>The Rust Community</h1></a>
<p>Rust is known for having a very helpful community. You can see dozens of links different community spaces prominently featured on the Rust homepage. This is a pretty big contrast to a lot of programming communities. In many languages there either isn’t a recognisable community, or there is one, but it can be unwelcoming or outright hostile to beginners.</p>
<p>A big part of this is that Rust was born out of Mozilla, which has a lot of experience managing open source communities. They established a code of conduct, a moderation team, user groups, forms, and open source development teams.</p>
<p>Another aspect it the language itself. Rust’s learning curve is both initially steep and long. Fortunately this process isn’t painful because the difficulty does not come from ‘magic’. Rust is very explicit and almost everything works exactly the way you’d expect. Rather it comes from learning to work within the safety rules. It is sometimes complicated and isn’t similar to other languages. But this has a way of keeping people humble. In a lot of other languages, it’s easy to forget that things that seem second nature now used to be confusing.</p>
<p>So in some languages, you might be mocked for asking for help, or be unable to find it, or write what you think is right only to have things break at Runtime. With Rust, you might have to ask for help more or work harder to get things to compiler. But you’ll find lots of people will be happy to help. And once your code does compile, you can be fairly confident it is correct.</p>
<a class="header" href="#rfc-process" id="rfc-process"><h2>RFC process</h2></a>
<p>• Discuss
• Pre-rfc
• RFC
• Impl
• Nightly
• Crater to rebuild to world
• Beta - through release
• No new reasoning
• Committees and many perspectives.</p>
<a class="header" href="#variable-declaration" id="variable-declaration"><h1>Variable declaration</h1></a>
<p>Below is an example of a variable being declared in Java and the equivalent expression in rust.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo : i32 = 5;
#}</code></pre></pre>
<pre><code class="language-java">int foo = 5;
</code></pre>
<p>The keyword ‘let’ is used to indicate you are declaring a variable. This is followed by the variable name, then a colon and then the type.
The reason Rust puts the type one the right is because the type is optional anytime it can be inferred by the compiler. Which means that most of the time we can just write:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo = 5;
#}</code></pre></pre>
<p>The equals sign for assignment works the same way it does in Java. Primitives also work the same way but they have different names. Below is a table to help:</p>
<table><thead><tr><th> Java  </th><th> Rust  </th></tr></thead><tbody>
<tr><td> long  </td><td> i64   </td></tr>
<tr><td> int   </td><td> i32   </td></tr>
<tr><td> short </td><td> i16   </td></tr>
<tr><td> byte  </td><td> i8    </td></tr>
<tr><td> double</td><td> f64   </td></tr>
<tr><td> float </td><td> f32   </td></tr>
</tbody></table>
<p>Rust also supports unsigned integers these cannot be negative and use their highest order bit to represent higher numbers just like any other bit. The range of values that can be represented in each is listed in the table below.</p>
<table><thead><tr><th> Type </th><th> Min </th><th> Max   </th></tr></thead><tbody>
<tr><td> u8   </td><td> 0   </td><td>2^8-1  </td></tr>
<tr><td> u16  </td><td> 0   </td><td>2^16-1 </td></tr>
<tr><td> u32  </td><td> 0   </td><td>2^32-1 </td></tr>
<tr><td> u64  </td><td> 0   </td><td>2^64-1 </td></tr>
<tr><td> u128 </td><td> 0   </td><td>2^128-1</td></tr>
</tbody></table>
<p>Constants can also explicitly specify their type. (Similar to Java) The examples below are equivalent.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const secondsPerMinute : i64 = 60;
#}</code></pre></pre>
<pre><code class="language-java">static final long secondsPerMinute = 60;
</code></pre>
<p>By default all variables in Rust are final. So instead of a final keyword there is the <code>mut</code> keyword to indicate the variable is mutable (non-final). For example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut counter = 0;
#}</code></pre></pre>
<p>The advantage of using <code>mut</code> rather than <code>final</code> (besides being fewer characters) is it makes the declaration is far more likely to be accurate. In Java it very common to simply omit the final keyword even when a variable is final. As a result when reading Java you often don’t know if a variable is final or not.</p>
<p>Safety monitor: Rust's default declaration actually provides an even stronger guarantee than Java's final, because we not only enforce that the variable won't be reassigned, but also that it's contents won't be changed.</p>
<p>A ‘final-by-default’ policy makes reasoning about code a lot easier, because you know if something is going to change. This makes writing multi-threaded code easier, because if something is immutable can always be shared safely between threads. (We’ll come back to this in a later chapter).</p>
<a class="header" href="#vec" id="vec"><h2>Vec</h2></a>
<p>Rust has a built in type called <code>vec</code> which is short for &quot;Vector&quot;. It is equivlent to Java's <code>ArrayList</code>. However because Rust does not have &quot;primitive wrapper&quot; types like Java's &quot;Integer&quot; and &quot;Byte&quot; (as opposed to &quot;int&quot; and &quot;byte&quot;) and is capable of putting primitives in collections directly without any overhead <code>Vec</code> receives a lot more use in Rust than <code>ArrayList</code> does in Java. It is often used in places where in Java you would use an array or a generic 'Collection'.</p>
<a class="header" href="#string" id="string"><h3>String</h3></a>
<a class="header" href="#method-signatures" id="method-signatures"><h1>Method Signatures</h1></a>
<p>Below is a Java method signature and the equivalent rust signature.</p>
<pre><code class="language-java">void printNum(int num);
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait Example {
fn printNum(num: i32);
# }
#}</code></pre></pre>
<p>Things to notice:
The Rust method starts with the keyword “fn” this simply indicates that a function is being declared. This is followed by the method name and each of the parameters to the method in parentheses. Unlike Java where the type appears on the left followed by the argument name, in Rust the name comes first followed by a ':’ followed by the type. (Similar to how variables are declared)</p>
<p>If the function had a return value it would be declared on the right hand side like this:</p>
<pre><code class="language-java">int add(int a, int b);
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait Example {
fn add(a: i32, b: i32) -&gt; i32;
# }
#}</code></pre></pre>
<p>There is no “void” in Rust. If there isn't a return value, just don't provide one.</p>
<p>Just as in Java the method body is in between the curly braces.</p>
<pre><code class="language-java">int add(int a, int b) {
    return a + b;
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn add(a: i32, b: i32) -&gt; i32 {
    return a + b;
}
#}</code></pre></pre>
<a class="header" href="#borrowing" id="borrowing"><h2>Borrowing</h2></a>
<p>Besides being mutable or not, in Rust a variable can also be “borrowed”. When the parameter to a method is borrowed, it means the method promises not keep the parameter after the method has returned. Or anything it obtained from the parameter.</p>
<p>A method that takes a borrowed parameter cannot assign the parameter to a member variable. Also it can only pass that parameter to other methods which also borrow it. (Otherwise it would be able violate its contract indirectly.)</p>
<p>Safety monitor: “I will act as the borrow checker to make sure you don't make a mistake.”</p>
<p>To indicate a parameter is borrowed, in the method signature, place a “&amp;” in front of the type.</p>
<p>As an example, in Java you might define a method 'isSorted’ like this</p>
<pre><code class="language-java">boolean isSorted(List&lt;Integer&gt; values);
</code></pre>
<p>that returns a boolean indicating if a list is sorted. In Rust you would add an ‘&amp;’ in front of the type in the method signature to indicate that it will not retain any references to the list or it's contents when the method returns.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait Example {
fn isSorted(values: &amp; Vec&lt;i32&gt;) -&gt; bool;
# }
#}</code></pre></pre>
<p>It is helpful to think of 'borrowed’ as being part of the type. IE “The method takes a borrowed list.”</p>
<p>This declaration provides a strong and useful guarantee to the callers of a method. But it would be worthless if in a newer version, the method just deleted the ‘&amp;’ from it's signature and removed the guarantee. To prevent this, and to make the guarantee explicit in the caller's code, when a method is being invoked; When a method that borrows a parameter is invoked, the caller puts an ‘&amp;’ in front of the variable name being passed in. For example</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn isSorted(values: &amp; Vec&lt;i32&gt;) -&gt; bool { true }
# let values = vec![1, 2, 3];
if (isSorted(&amp;values)) {
    //...
}
#}</code></pre></pre>
<p>This is only needed if the variable being passed isn't itself borrowed. (Otherwise it would be redundant, because it can only pass it to methods which borrow it.)</p>
<p>Passing a parameter to a method that borrows is sometimes referred to a the parameter being “lent” to the method.</p>
<a class="header" href="#mutability" id="mutability"><h3>Mutability</h3></a>
<p>Similar to variable declaration, if you want to modify a borrowed parameter, you use the 'mut’ keyword. This goes right in front of the type.</p>
<pre><code class="language-java">void populateCounts(HashMap&lt;String, int&gt; itemCounts);
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::collections::HashMap;
# trait Example {
fn populateCounts(itemCounts: &amp;mut HashMap&lt;String, i32&gt;);
# }
#}</code></pre></pre>
<p><code>mut</code> can be thought of a part of the type. IE “a borrowed mutable Hashmap” as opposed to “a Hashmap&quot;.</p>
<p>When 'Borrowed’ is combined with 'mut’ the ‘&amp;’ goes first. If you wanted to write a method to sort a list, it would take a borrowed mutable list.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait Example { 
fn sort(names: &amp;mut Vec&lt;String&gt;);
# }
#}</code></pre></pre>
<p>This signature means <code>sort()</code> may change the list, but only during the invocation of the method and will retain no references to the list or its contents once the method returns.</p>
<a class="header" href="#javadocs" id="javadocs"><h2>Javadocs</h2></a>
<p>Documentation is an area where Rust and Java are very similar. In Java you might add a javdoc like this</p>
<pre><code class="language-java">/**
 * Computes an approximation of {@code 1/sqrt(a)} segnifigantly faster. 
 * However compared to using {@link java.lang.Math.sqrt()} the result is much less accurate.
 * @param   a   the value to compute the inverse square root of.
 * @return an approximate inverse square root of the passed parameter.
 */
public double fastInvSqrt(double a);
</code></pre>
<p>which can be automatically translated into HTML documentation. Rust has rustdocs which work similarly. You could write the following:</p>
<pre><code class="language-rust ignore">/**
 * Computes an approximation of `1/a.sqrt()` segnifigantly faster.
 * However compared to using [`sqrt`] the result is much less accurate.
 * # Examples
 * ```
 * let a = 7.0_f64;
 * let exact = 1.0 / a.sqrt();
 * let approx = a.fast_inv_sqrt();
 * assert!((approx-exact).abs() &lt; 1e-5);
 * ```
 */
</code></pre>
<p>Or instead of “/**” and a block comment, you can use “///” and line comments. So the following is equivalent:</p>
<pre><code class="language-rust ignore">/// Computes an approximation of `1/a.sqrt()` segnifigantly faster.
/// However compared to using [`sqrt`] the result is much less accurate.
/// # Examples
/// ```
/// let a = 7.0_f64;
/// let exact = 1.0 / a.sqrt();
/// let approx = a.fast_inv_sqrt();
/// assert!((approx-exact).abs() &lt; 1e-5);
/// ```
</code></pre>
<p>(This helps with small comments as it doesn't require an extra line at the top and bottom.)</p>
<p>Javadocs have a number of common tags such as “@param” and “{@link }”. Below are some common ones and their Rust equivalents.</p>
<table><thead><tr><th> Type         </th><th> Java           </th><th> Rust        </th></tr></thead><tbody>
<tr><td>Link to method</td><td><code>{@link Foo#bar() }</code></td><td><code>[`Foo::bar()`]</code></td></tr>
<tr><td>Link to URL   </td><td><code>&lt;a href=&quot;https://google.com&quot;&gt; google&lt;/a&gt;</code></td><td><code>[google](https://google.com)</code></td></tr>
<tr><td>Code snippit  </td><td><code>{@code foo.bar()}</code></td><td><code>`foo.bar()`</code><br/>or<br/><code>```</code><br/>  <code>foo.bar();</code><br/><code>```</code></td></tr>
<tr><td>Parameter     </td><td><code>{@param foo bla bla}</code></td><td> N/A Documented through examples and code snippits</td></tr>
<tr><td>Return        </td><td><code>@return bla bla</code></td><td> N/A Documented through examples and code snippits</td></tr>
<tr><td>Examples      </td><td><code>&lt;pre&gt;</code> <br/> <code>{@code</code>  <br/>  <code>//...</code> <br/> <code>}</code> <br/> <code>&lt;/pre&gt;</code></td><td> <code># Examples</code> <br/> <code>```</code> <br/>  <code>//...</code><br/> <code>```</code></td></tr>
<tr><td>See also      </td><td><code>{@see &quot;Bla bla&quot;}</code></td><td><code># See Also</code> <br/> <code>Bla bla</code></td></tr>
<tr><td>Custom tag    </td><td> Requires custom javac args </td><td> <code># My custom section</code> <br/> <code>//...</code></td></tr>
<tr><td>Bulleted list </td><td><code>&lt;ul&gt;</code><br/><code>&lt;li&gt;one&lt;/li&gt;</code><br/><code>&lt;ul&gt; &lt;li&gt;one point one&lt;/li&gt; &lt;/ul&gt;</code><br/><code>&lt;/ul&gt;</code></td><td><code>* one</code><br/><code>** one point one</code></td></tr>
</tbody></table>
<p>Difference between Javadocs and Rustdocs is that to do formatting, in Java you would inject HTML tags, where as in Rust you use Markdown syntax. So the following Javadoc and Rustdoc are equivalent __ vs __. As you can see this improves readability a lot.</p>
<p>To generate an view your docs you can run _. Which will put the documentation in _. When you publish your code to Crates.io (Rust’s main package repo, the docs will be published automatically.) There will be more on Crates.io and the Cargo command in chapter _.</p>
<p>Additional information for the doc can also be placed inside of the method, if for some reason that makes more sense from an organization point of view. So the following are equivalent __ and __.</p>
<p>Docs can also be hidden (If for example a feature is still being tested) like this __. Similarly you can use the _ annotation to mark them as being platform specific. For example __.</p>
<p>It is common practice in Rust to write a small example for how to use each function rather than documenting all of the input and output parameters like you would in Java. So instead of __ you might write __ in Rust. These examples aren’t just for show, they also get automatically turned into unit tests. For example __. This makes sure your documentation stays up to date with the code. If you want to hide a few lines of setup at the top of an example you can use _. For example __.</p>
<a class="header" href="#macros-basic" id="macros-basic"><h2>Macros (basic)</h2></a>
<p>Ok, let’s finally get around to writing HelloWorld:</p>
<pre><pre class="playpen"><code class="language-rust">/// Prints &quot;Hello world!&quot;.
fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p>You may be wondering: “What is that exclamation point doing at the end of that function name?” The answer is 'println!’ is not a normal function it is what is called a “Macro”. (Don't worry these aren't the horrifyingly unsafe macros of C and C++. Like most things in Rust they are designed to be safe.)</p>
<p>You can think of macros as a function that does things that functions can't normally do. In this case ‘println’ supports string templates.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let name = &quot;Ferris&quot;;
    println!(&quot;Hello {}!&quot;, name);
}
</code></pre></pre>
<p>The template is validated at compile time. So if you were to type</p>
<pre><code class="language-rust ignore">println!(&quot;Hello {}!&quot;);
</code></pre>
<p>or</p>
<pre><code class="language-rust ignore"># let name = &quot;a&quot;; let name = &quot;b&quot;
println!(&quot;Hello {}!&quot;, name1, name2);
</code></pre>
<p>the mistake would actually be a compile error. (BorrowChecker: Which is great because it means you can't write incorrect code. Optimizer: and has the added bonus of not spending any CPU at runtime parsing and verifying the template.) This kind of verification is something a normal function couldn't possibly do. Will get into how this implemented in a later chapter. But for now you should think of an elimination mark, as an alert that there's something unusual about that function and you should read its documentation.</p>
<a class="header" href="#flowcontrol" id="flowcontrol"><h1>Flowcontrol</h1></a>
<p>Similar to Java in Rust variables are defined to exist in the scope where they are declared. So you can do this</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut i = 0;
while i &lt; 10 {
    println!(&quot;Counter: {} &quot;, i);
    i += 1;
}
#}</code></pre></pre>
<p>but not this</p>
<pre><code class="language-rust ignore">for i in 1..10 {
    let x = i;
}
println!(&quot;You can't do this: {}&quot;, x);
</code></pre>
<p>(SafetyMonitor: This is a bug, don’t do that.)</p>
<p>Rust has <code>return</code> keyword, which works exactly like java:</p>
<pre><code class="language-java">int square(int x) {
    return x * x;
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn square(x: i32) -&gt; i32 {
    return x * x;
}
#}</code></pre></pre>
<p>However in Rust expressions will return the last value in them if it is not followed by a <code>;</code> so you can just write:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn square(x: i32) -&gt; i32 {
   x * x
}
#}</code></pre></pre>
<p>This also holds true for things like if statements</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn something() -&gt; bool {true};
let x = if something() { 1 } else { 0 };
#}</code></pre></pre>
<p>is equivalent to</p>
<pre><code class="language-java">int x;
if (something()) {
    x = 1;
} else {
    x = 0;
}
</code></pre>
<p>or</p>
<pre><code class="language-java">int x = something() ? 1 : 0;
</code></pre>
<p>in Java.</p>
<p>Note that the parenthesis around an <code>if</code> or <code>while</code> conditional are totally optional. Because in Rust the conditional is just an expression in Rust, just like any other.</p>
<p>Below are examples of If, for, and while loops compared to their java equivalents. __ and __.</p>
<table><thead><tr><th>Rust                   </th><th>Java   </th></tr></thead><tbody>
<tr><td><code>if _ { _ } else { _ }</code></td><td><code>if (_) { _ } else { _ }</code></td></tr>
<tr><td><code>match _ { _ =&gt; _ }</code></td><td><code>switch (_) { case _ : _ break; }</code></td></tr>
<tr><td><code>while _ { _ }</code></td><td><code>while (_) { _ }</code></td></tr>
<tr><td><code>loop { _ }</code></td><td><code>while (true) { _ }</code></td></tr>
<tr><td><code>for i in _ { _ }</code></td><td><code>for (X i : _) { _ }</code></td></tr>
<tr><td><code>for i in 0..n { _ }</code></td><td><code>for (int i = 0; i &lt; n; i++) { _ }</code></td></tr>
<tr><td><code>break</code> / <code>break 'label</code>   </td><td><code>break</code> / <code>break label</code> </td></tr>
<tr><td><code>continue</code> / <code>continue 'label</code></td><td><code>continue</code> / <code>continue label</code></td></tr>
<tr><td><code>return _;</code></td><td><code>return _;</code></td></tr>
</tbody></table>
<p>There are a few differences: Rust does not have <code>do/while</code> loops. In Rust the <code>match</code> statement can use pattern matching and the cases do not &quot;fallthrough&quot; like <code>switch</code> in Java, so there is no need for a <code>break</code>.</p>
<p>The Rust <code>for</code> loop works like java’s “new” for loop, and doesn’t have the C style 3 part condition version.</p>
<pre><code class="language-java">for (String item : collection) {
    //...
}

</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let collection = vec![1,2,3];
for item in collection { //Item's type is infered
    //...
}
#}</code></pre></pre>
<p>If you want to write a pattern like that, you can use a “range” operator instead.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for i in 0..10 {
    //...
}
#}</code></pre></pre>
<p>The &quot;..&quot; operator produces an iterator between the value on the left and the one on the right (inclusive and exclusive). Rust also has a “loop” loop which is equivalent to <code>while (true)</code> in Java. The keywords <code>break</code> and <code>continue</code> work the same way they do in Java.</p>
<pre><code class="language-java">while(true) {
    //...
    break;
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
loop {
    //...
    break;
}
#}</code></pre></pre>
<p>Notice that the if, while, and for conditional arguments are just normal expressions that return a boolean. (As opposed to Java where it is a special construct surrounded by parenthesis). And because anything surrounded by curly braces is an expression which returns the last expression inside of it, it is possible to write a loop like conditional like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut i = 1;
while { i = i*2; i &lt; 65536 } {
    //...
}
#}</code></pre></pre>
<p>here the code is iterating over the powers of 2, but the code to update the variable <code>i</code> has been put in the top as part of the loop conditional. (The purpose of showing this is not to encourage doing this all over the place, but rather to show how the compiler sees things)</p>
<a class="header" href="#functions-as-arguments" id="functions-as-arguments"><h2>Functions as arguments</h2></a>
<p>In Java sometimes you pass functions as arguments. With a named function this is doen like this <strong>. The Rust equivalent would be do this</strong>. (Very similar) You can also create an anonymous function and pass it like this __. In Rust the syntax is __. The <code>|</code> characters replace the parentheses and the curly braces are optional if there is only a single statement: __. These are sometimes referred to as “Anonymous functions” (Because they don’t have a name) or “Closures” because they can refer to local variables in the surrounding function. But it’s worth noting that you can just as easily pass normal functions too. IE __.</p>
<a class="header" href="#memory-safety-and-gc" id="memory-safety-and-gc"><h1>Memory safety and GC</h1></a>
<p>Like Java, Rust has automatic memory management so you never have to worry about explicitly allocating or deallocating objects. However unlike Java it does not have a garbage collector. This may sound like a contradiction but it's not.</p>
<p>It turns out, not coincidentally, the same static analysis that solves the problem of allowing sharing or mutability but never both, also solves the problem of perfect garbage collection.</p>
<p>One way to think about it is to think of Rust as having compile time garbage collection. The compiler works out where in your code objects are no longer used automatically generates the necessary code to deallocate them.</p>
<p>So like Java this means Rust does not suffer from memory leaks, use-after-free bugs, dangling pointer bugs, or buffer overflows that plague most compiled languages. At the same time Rust does not have the overhead of garbage collection or the associated runtime which has prevented languages like Java and C# from reaching the performance of C++ in “object heavy” applications.</p>
<a class="header" href="#ownership" id="ownership"><h1>Ownership</h1></a>
<p>To explain how Rust achieves automatic memory management without garbage collection and a number of other more advanced features we need to first explain Ownership.</p>
<p>Ownership is a common pattern in programming in any language even though it really isn’t a part of most languages themselves. It’s best to see this through example. In Java compare the method <code>addAll</code> on <code>TreeSet</code> to the static method <code>Collections.sort</code>. Both provide ways to sort a list of items by passing it into a method, but the contract of these methods is quite different. In the case of the <code>TreeSet.add</code> ownership of the values is being implicitly transferred to the TreeSet. The caller should not hold onto references to the items added to the Set. If they want to modify one of the items they should first remove it from the set. Otherwise the change could affect the of sort order and break the TreeSet resulting in undefined behavior. On the other hand <code>Collections.sort</code> does not have this restriction. In fact it is implicit in the contract of the method that the implementation won't hold onto references to the items passed after the method returns. If the implementation of sort were to modify the the list after it returned it would surely break the caller's code. <code>Collections.max</code> is similar but it has the additional implicit assumption that it won't modify the passed list.</p>
<p>In Rust these assumptions are explicitly declared as part of the method signature. So if in Java we were to declare integer speffic versions on each of these, it would look like this:</p>
<pre><code class="language-java">public interface IntegerSet {
  //...
  public void addAll(List&lt;Integer&gt; list);
}
public static Integer max(List&lt;Integer&gt; list) {
   // ...
}
public static void sort(List&lt;Integer&gt; list) {
   // ...
}
</code></pre>
<p>in Rust an equivlent method are declared as:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait MySet {
  //...
  fn add_all(list: Vec&lt;i32&gt;);
}
fn max(list: &amp;Vec&lt;i32&gt;) -&gt; Option&lt;i32&gt; { 
  //...
# list.iter().cloned().max()
}
fn sort(list: &amp;mut Vec&lt;i32&gt;) {
   //...
#   list.sort();
}
#}</code></pre></pre>
<p>Notice that the type of the argument changed. When it is just 'Vec<i32>’ the method is taking ownership of the value. But when it is ‘&amp;Vec<i32>’ it is a borrowed vector, meaning the caller still retains ownership. And a ‘&amp;mut Vec<i32>’ is a borrowed mutable vector meaning that even though the function is not taking ownership, it may modify the provided vector.</p>
<p>For any given object there is one owner. When that variable is reassigned or goes out of scope the value is dropped. This applies transitively. So for example in the function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn process(items: Vec&lt;String&gt;) {
  //...
}
#}</code></pre></pre>
<p>when the function returns, the vector <code>items</code> and all of the strings in it will be dropped from memory.</p>
<p>This might seems like it doesn’t allow cycles. There are ways to create cycles, but for the most part they aren’t needed. Why this is the case will be covered in “How Rust makes you a better Java programmer”.</p>
<p>However the main tool that used is borrowing.</p>
<a class="header" href="#borrows" id="borrows"><h1>Borrows</h1></a>
<p>• Output to be populated
• Sort example
• Also called reference (Not the same as a C++ ref, more like a smart pointer)
• Primitive (copy by value) vs pointer
• Copy vs move (is similar)</p>
<p>In addition to compile time memory management and guaranteed thread safety (more on this in the concurrency chapter), explicit ownership opens up a lot of useful patterns.</p>
<p>In Java a common pattern is to pass around a byte array with a offset and length to provide access to a part of an array without making a new copy. For example see <code>java.io.OutputStream.write(byte[] b, int off, int len)</code> or <code>java.io.FileInputStream.read(byte[] b, int off, int len)</code>. In Rust you can use slices. So you can write</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io;
# use std::io::prelude::*;
# let mut output = io::stdout();
let buffer = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
output.write(&amp;buffer[2 .. 8]);
#}</code></pre></pre>
<p>which passes a segment of a byte array to the <code>write</code> function. In addition to convince and performance, it allows you specify if the slice is being passed can be written to or just read from have this enforced by the compiler. So if you have a function that looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct MyConfig(i32);
pub fn applyConfig(config : &amp;MyConfig) {
  //...
}
#}</code></pre></pre>
<p>you can be sure that the <code>config</code> object won’t be changed by passing it to the function. No defensive copies required. Similarly, above the caller is guaranteed that <code>output.write(&amp;buffer)</code> won’t modify the contents of the buffer.</p>
<p>Borrowing also works with loops. When using a for loop to iterate over a collection, you can either pass the for loop the collection itself</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let strings = vec![&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;bat&quot;];
for value in strings {
  println!(&quot;Hello {}&quot;, value);
}
#}</code></pre></pre>
<p>consuming the collection in the process, much a like a stream in Java. Or you can let it borrow the collection</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let strings = vec![&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;bat&quot;];
for &amp;value in &amp;strings {
  println!(&quot;Hello {}&quot;, value);
}
#}</code></pre></pre>
<p>If the collection is borrowed then inside the loop each entry will itself be borrowed. This is actually a important feature. In Java a for-each loop can't take an iterator only an iterable. This is because if it did you could write</p>
<pre><code class="language-java">Iterator&lt;String&gt; iter = //...
for (value : iter) {
  //...
}
for (oops : iter) {
  //Can't get here...
}
</code></pre>
<p>the second loop wouldn’t make any sense because it can’t get any data because there is no way to invoke .iterator() again and reread the data. For this reason Java introduced a second concept ‘streams’ which don’t work with for loops. Because there was no way to convey to the compiler that the for loop will consume the values it's iterating over, Java had to create two separate concepts <code>stream</code> and <code>iterator</code> that don’t work together. You can either write</p>
<pre><code class="language-java">List&lt;Foo&gt; foos = //...
for (Foo f : foos) {
  if (meetsCriteria(f)) {
    process(f);
  }
}
</code></pre>
<p>or you could write</p>
<pre><code class="language-java">List&lt;Foo&gt; foos = //...
foos.stream().filter(f -&gt; meetsCriteria(f)).forEach(f-&gt;process(f));

</code></pre>
<p>but you can’t mix these ways of coding. In Rust this can be conveyed by either passing or lending the collection to the for loop. This allows the concepts of stream and iterator to be unified into a single simple interface and work with for loops without the risk of accidentally reusing the consumed stream allowing you to write:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Foo(i32);
# fn get_foos() -&gt; Vec&lt;Foo&gt; { vec![Foo(1), Foo(2)] }
# fn meets_criteria(f : &amp;Foo) -&gt; bool { true }
# fn process(f : Foo) {}
let foos : Vec&lt;Foo&gt; = get_foos();
for f in foos.into_iter().filter(|f| meets_criteria(f)) {
  process(f);
}
#}</code></pre></pre>
<p>In addition to these there are a bunch of other common patterns.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait Example {
fn read_from_buffer(&amp;self, buffer : &amp;[u8]);
# }
#}</code></pre></pre>
<p>Here a method is borrowing a parameter but it's not modifying it. When is the messages returned your guaranteed it is not still holding onto it.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::path::Path;
trait Config {
  //...
  fn get_storage_location(&amp;self) -&gt; &amp;Path;
  //...
}
#}</code></pre></pre>
<p>Here an accessor method is lending the caller some of the object's internal state (in a read only way) the calling code cannot invoke any further methods on the object until it drops the reference to the data that was returned from this method. This is a great pattern for simple accessors that would not be safe in Java because they would be exposing the internal state of the class and potentially violating it's invariants. While it may not always be a good idea to expose internal representation, this provides a way to do it safely that does not violate the integrity of class, and still allows the implementation to change in the future. (It can always construct the returned object if needed)</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

trait Config {
  //...
  fn set_attributes(&amp;mut self, attributes: HashMap&lt;String, String&gt;);
  //...
}
#}</code></pre></pre>
<p>here the <code>set_attributes</code> function is making explicit that when called it is now the owner of the provided <code>attributes</code> and the caller no longer has any references to it. In Java would be dangerous. Usually to prevent this a defensive copy is made. However this comes at a perfromace cost. To avoid this sometimes Java programs just skip it because the transfer of ownership is understood and users know not to do this. For example when inserting an object into a HashSet, it is understood that you should not modify the object afterwards. But nothing actually prevents this.</p>
<p>• Similar pattern getting an entry by key and doing .or_insert() += 1.</p>
<p>The rules for ownership and borrowing are straight forward: __</p>
<p>...</p>
<p>There are more exotic ways to handle objects then in general aren't really needed the overwhelming majority of the time. These include RC (which allows ambiguous ownership where the item is dropped when all references go away.) ARC which is similar, but thread safe. This is generally used for Top-level classes with business logic that may need to be referenced from multiple places and live for a long time.</p>
<p>All of these compile time rules can be broken by declaring code ‘unsafe’ but you shouldn’t go around do that, because it will mean the compiler won’t be able to protect you. Instead the pattern in Rust is to use ‘unsafe’ to build a small generic primitive which is itself safe but is for reasons that the compiler doesn’t understand. Then depend on that component where you need it. There are many such components publically available, and we’ll cover some of them in depth in this book. A short list of common ones is below __
• SplitAtMut
• Cell
• RefCell
• Rc/Arc</p>
<p>• Cell provides internal mutability. Ie you can change data when immutable, but only behind an interface.
◦ Can't violate normal immutability rules, because cell requires ownership.
◦ Can't violate normal borrowing rules either.
◦ Cell forbids references to its contents.
◦ Things containing cells are not allowed to cross thread boundaries
◦ When you see realize the field is mutable, and can change between times you use it.
• RefCell allows in stead or replacing a value to change it like cell the ability to borrow and mutable borrow the contents.
◦  like cell, can't use to violate normal parameter guarantees
◦ Can't cross thread boundaries.
◦ Still safe. Single writer of multiple readers enforced at runtime.</p>
<p>‘Cell’ is a class included in the standard library. It allows the value it is wrapping to be replaced. So you can write a struct like this __ and then modify that field it in a function that only has an immutable borrow like this __. This circumvents the normal mutability rules, and as such the compiler will not allow types using ‘Cells’ to cross thread boundaries. Similarly there a type ‘RefCell’ that allows the value to be modified (as opposed to replaced). __ Here a hashmap is being defined that can be updated by a function that only has a _. ‘RefCell’ does not actually abandon safety all together. While you can get a mutable reference out of an immutable object like so __ it actually just moves the safety check from compile time to runtime. So if your code actually does something bad, like attempts to get two mutable references at the same time, it will panic. <It is still correct if you have full unit test coverage>
• Ref and RefMut are returned. These act as a lifetime tracker which allows the enforcement of one writer at a time.</p>
<p>In general using ‘cell’ or ‘RefCell’ a lot is considered bad design. ‘Cell’ and ‘RefCell’ should be reserved for special cases that don’t impact the externally visible functionality. For example they provide a easy way to add things like counters, metrics, debugging information to an existing object without having to refactor all the code that is accessing it. Similarly they are frequently used when constructing Mock objects for test purposes. (The actual code may be accessing the object in a ‘read-only’ way, but the mock still may want to record what calls have occured)</p>
<p>Reference cycles and ambiguous ownership is an anti-pattern in Java, and a really really aggressively discouraged anti-pattern in Rust. But one place it tends to get asked about a lot is doing GUI programing. For example when rendering a window with many widgets it is easy to jump to the conclusion that links are needed between all sorts of objects as changes to one may involve changes to another. This generally arises from the false belief that objects in an object oriented system should be directly modeled after real life objects. often this is not the case because concerns are cross-cutting. If you're writing code in Rust this pattern will fail faster. While this might be frustrating to the author it's actually good because it prevents you from writing bad code. There are actually a lot of good talks on this subject, such as <em>ECS at rustconf</em> and <em>xi-GUI</em>. I'm not going to go into the details here because these problems are application specific. However if you find yourself fighting the borrow checker or tempted to use unsafe or RefCell all over the place, it’s probably worth taking a step back and re evaluating the broader design. …….. data oriented design.</p>
<a class="header" href="#returning-borrowed-values" id="returning-borrowed-values"><h1>Returning borrowed values</h1></a>
<p>Borrowing is not just for parameters, it is also for returned values. The simplest case is where the returned value is derived from an input parameter. For example __. Another case is where the value being returned comes from 'self’ and is being lent to the caller. For example __. In both these cases the caller is bound by the contract of borrowing, exactly the same as though it were provided as an input parameter. If it helps, imagine the rest of the function were factored out into a private method and had the result as a borrowed parameter. For example __.</p>
<p>When returning borrowed values it is occasionally ambiguous where the returned value came from. 99% of the time the compiler will work it out automatically. But sometimes there are cases that aren't so clear. For example __. Here the compiler won't be able to work it out, because it only looks at one method at a time.</p>
<p>In such a case you can label your inputs. Like so __ (Usually 'a, 'b, 'c, etc are used.) And the apply the same label to the output. __ Then it is clear which input you intend the output to have come from. (The compiler will still check to make sure the labels are correct.)</p>
<p>If somehow the result could come from multiple inputs, or it is ambiguous like __. You can simply give the the same label, and the compiler will be forced to make the conservative assumption that it could have come from either.</p>
<p>Because these labels are used by the compile time garbage collection to determine when data can be dropped, they are called “lifetimes”. As mentioned above today you rarely need them, because the compiler infers them. As the compiler has improved they are needed less. So you'll see labels more often in older code.</p>
<p>Safety monitor: don't worry about making a mistake with lifetimes. If you declare lifetime to be too short, I'll catch your mistake and show you the code path where it goes wrong. If you declare a lifetime to be too long, worst case scenario an object is kept around longer than is theoretically necessary, but it still won't be leaked.</p>
<a class="header" href="#pass-by-value-vs-pass-by-reference" id="pass-by-value-vs-pass-by-reference"><h1>Pass by value vs Pass by reference</h1></a>
<p>Similar to Java, Rust's function calls are normally “pass by reference” meaning that if you pass an object to a function and modify it the caller will see those modifications. However also like Java, primitives are an exception to this and are “pass by value”. Meaning if you pass an integer to a function and it increments it. The caller will not see the change.</p>
<p>In Java this is just a hardcoded rule and only primitives are copied. In Rust you can define your own types that are treated this way by having them implement “Copy” which is what is called a “marker trait”. It is similar an interface with no methods in Java indicating something about a class. (Like ‘Cloneable’ or ‘Serializable’)</p>
<a class="header" href="#todo" id="todo"><h1>TODO</h1></a>
<p>• String types (mutability, borrowing, assignment as move)
◦ String concatenation
▪ Format! In example
◦ Stringbuilder
◦ In Java Strings are Immutable, and a primitive. You might not think about it too much but this is an essential language feature. If Java hadn’t provided a single standard String implementation in the standard library, or if they had chosen to make it mutable it would be very difficult to work in the language. Imagine if every time you passed a string into a method you had to make a defensive copy or carefully check the method’s Javadocs to make sure it doesn’t modify the string. So it might seem surprising that Rust went into a different direction. However there is a very simple reason for this, Rust’s methods always declare if they need to modify the value being passed. __. Similarly the caller has to explicitly pass either a mutable or immutable reference or slice of the string. So there is no ambiguity. A function can never pass a string somewhere and have it unexpectedly modified.
• Fixed size arrays
• Byte array and ByteBuffer
• Vec and arraylist
◦ Strings are actually Vecs of UTF-8 characters/bytes
• Raw strings for multi line constants
• Slices
◦ Str is a slice of a String (get it?)
◦ Should be after indexes and range traits are introduced (Operator overloading)
◦ A slice of a vec is an array
▪ Made possible by ownership</p>
<a class="header" href="#objects" id="objects"><h1>Objects</h1></a>
<p>• Members
◦ Constants
• Methods
◦ Functions vs methods (implicit borrows)
• Visibility
• Static methods
• Constructors
◦ Like Java, you can never have a partially constructed / uninitialized object
◦ Can return a different object from “new” this is useful for having things like a builder.
◦ From_ naming convention for constructors
• Traits vs Interfaces
◦ Drop vs TryWith object vs finalizer
• Add methods outside
• Difference between impl foo for bar vs impl&lt;t:bar&gt; foo for t
◦ Impl foo is a trait it just doesn't have a name.
• Traits and emulate overloading but in an extensible way
• Use types to provide static distinctions (because types have no overhead)
• Common traits
◦ convert
◦ copy
◦ AsRef / asMut
◦ From / tryfrom  /  Into / tryInto
▪ Major advantage is don’t need to actually know type.
▪ Automatically mirror one another so don’t need to specify in two locations.
▪ Types automatically convert to themselves.
▪ Great example of generic implementations as your code can benefit from methods you did not write.
▪ Orphan rules mean you can only implement one.
▪ Notice that into() can just be invoked and it figures out which method to call based on what the return type is.
• This is much more powerful than Java’s method overloading because you cannot have identical signatures do different things.
◦ fromString
◦ Debug (always implement)
◦ Partial order
◦ Hash
◦ Display
◦ Error
◦ Default
◦ Autotraits: sync, send, sized, ?sized
• Almost all of these are written in standard rust. Including thing like iterator which will be covered in the next chapter. These automatically add a LOT of premade functions for your custom made types that you don’t have to write. For the traits supporting #derive this is even easier, because you don’t even have to do anything besides type the name. Even more importantly because everything is just standard rust, and there are no special hooks in the compiler for any of these types. This means in your own code you can build abstractions that are just as powerful. <Even better this is all done at compile time so there is no overhead></p>
<p>The in Java methods have access to an implicit variable ‘this’ which is the object on which the method was invoked. In Rust ‘this’ is called ‘self’. In Java there are methods declared with the keyword ‘static’ which do not have access to ‘this’ because they are not associated with any particular instance. In Rust the ‘self’ parameter is explicitly declared as the first argument to a method. So leaving it out is analogous to declaring a method ‘static’ in Java. Similar to Java such a method is invoked from the type itself. The following functions are equivalent __ and __.</p>
<p>Rust is an Object Oriented language, but it is not a class oriented language. So unlike in Java not all of the methods on an object are located in the same block of code. They are broken out across multiple traits. In many cases there are internal/related structs, enums, and traits which allow for greater code reuse. For example below is a table of common traits <strong>(ndex, intoiter, etc</strong>_. Each of these is small and easy to implement. Each one appears on a lot of types you wouldn't necessarily guess right away. For example _, and _. The advantage is each one unlocks a lot of flexibility because there is a lot of code that takes advantage of them. See __ or __ or __ as there is a lot of functions built around iterators. This pattern holds generally in Rust. Classes are not monolithic. Instead they have many small components that hook into each other to provide greater code reuse.</p>
<p>Traits allow can have implementation methods on them like Java interfaces. For example __ is the same as __. Where the trait is defining the method _ but leaving the methods _ and _ up to the implementer of the trait.</p>
<p>Traits are a concept in Rust that are very similar to an interface in Java. The main difference being that by convention Traits tend to have very few methods, usually just one or two each. As such APIs tend to be a bit finer grained but you may deal with more of them.</p>
<p>Below are some common interfaces in Java and their Rust equivalents:
__</p>
<a class="header" href="#traits" id="traits"><h1>Traits</h1></a>
<p>• Default methods
• Traits can inherit
• Associated types
◦ Needs an example. (Specs does this)
◦ Associated constants
• Marker traits. Like serializable in Java. Can be used to enforce certain semantics like that a particular behaviour / handling is desirable.
◦ Copy trait
◦ Can also be made mutually exclusive which is useful for making the compiler enforce invariants.
In Rust the implementation of traits is declared in a separate block from the declaration of the member variables. While this might seem strange coming from Java, it is actually a very important feature. Because methods are not located in the object itself the language doesn't need to distinguish between 'primitives’ and 'objects’ like Java. This is why Java needs Integer and int, Long and long, and Double and double.</p>
<p>So in Rust an i32 can be a key in a map without needing to be wrapped. This is also useful because they don't have to be in the same file. So you can for example declare a trait and the supply an implementation for an existing type. For example here is a trait for objects that can be doubled:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait doubleable {
  fn double(self : Self) -&gt; Self;
}

// And we can implement this for i32:

impl doubleable for i32 {
  fn double(self : i32) -&gt; i32 {
    2 * self
  }
}

// And now we can invoke this like any other method:

assert_eq!(10, 5.double());
#}</code></pre></pre>
<p>It's worth noting that there is never any ambiguity about where the implementation of a particular trait is. This is because it is only allowed to be in one of two places, where the trait is defined or where the type is defined. Because circular dependencies are not allowed and the definition will need to depend on both, the one that depends on the other must contain the implementation. This is referred to as “the orphan rule”. It appears in couple of places, aside from making method calls unambiguous, it also ensures things work as you might intuitively expect and means that unlike some languages (<em>ahem</em> Scalla) the behavior of code can't be altered simply by adding an import statement.</p>
<p>Java has method overloading which works like this:</p>
<pre><code class="language-java">class Processor {
  public void process(Foo item) {
    //...
  }
  public void process(Bar item) {
    //...
  }
}
</code></pre>
<p>in Rust the equivlent would be:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod processor {
# struct Foo; struct Bar;
  struct Processor;
  trait Process&lt;Item&gt; {
    fn process(&amp;self, item : Item);  
  }
  impl Process&lt;Foo&gt; for Processor {
    fn process(&amp;self, item : Foo) {
     //...
    }
  }
  impl Process&lt;Bar&gt; for Processor {
    fn process(&amp;self, item : Bar) {
      //...
   }
  }
}
#}</code></pre></pre>
<p>In Rust the methods are defined on the impl of the traits. This might seem a bit verbose, but traits are more powerful than simple overloading that you can do in Java. It also has the advantage that the implementations don't need to be located where <code>Processor</code> is declared. A new type can add it's own overload and implement it by for example by delegating to an existing implementation. Additionally in Rust you can overload functions with identical signatures or that differ by only a generic or a return type. each of those is associated with a trait. In Java you can never implement the same interface for two different generic types. For example:</p>
<pre><code class="language-java">class Processor {
  void processList(List&lt;Foo&gt; items);
  void processList(List&lt;Bar&gt; items); //Ooops..
}
</code></pre>
<p>Where as rust can just add:</p>
<pre><code class="language-rust ignore">impl Process&lt;Vec&lt;Bar&gt; for Processor {
  fn process(&amp;self, item : Vec&lt;Bar&gt;) {
    //...
  }
}
impl Process&lt;Vec&lt;Foo&gt; for Processor {
  fn process(&amp;self, item : Vec&lt;Foo&gt;) {
    //...
  }
}
</code></pre>
<p>Instead you have to overload the methods. This means the same class cannot implement an interface for multiple types.</p>
<pre><code class="language-java">class FastProcessor implements Processor&lt;Foo&gt;, Processor&lt;Bar&gt; { //Oops not allowed...
  //...
}
</code></pre>
<p>This of course destroys code reusability and prevents you from using interfaces as a means of abstraction because you are always coding to the impl. In Rust the interface is mandatory, which makes it easy to extend in the future and forces you think about the generalization. For example here is some code I wrote in Java __. Notice the overloaded method. In Rust I would have to create an interface that defines what I want. In this case _. This is already a common pattern so I can just use _. Then I can generalize my implementation by writing __. Now not only can I overload this method by adding more implementations, but my callers can too! All they have to do is implement _ like so __.</p>
<p>Java uses overloading to have a single method that can work for multiple different types. However Java also has what is called “single dispatch”. This means if you want a function to work generically for all implementations of a given interface but a different function for each one, you need to use the Visitor pattern:</p>
<pre><code class="language-java">class Processor {
  public void process(Foo item) {
    //...
  }
  public void process(Bar item) {
    //...
  }
}
interface Processable {
  public void process(Processor processor);
}
class Foo implements Processable {
  public void process(Processor processor) {
    processor.process(this);
  }
}
class Bar implements Processable {
  public void process(Processor processor) {
    processor.process(this);
  }
}

Processor processor = //...
List&lt;? extends Processable&gt; items = //...
for (Processable item : items) {
  // This will invoke the overloaded Processor.process(item) with the correct type.
  item.process(processor); 
}
</code></pre>
<p>You’ve probably written code like that a few times, and it generally works. It's certainly better than a single function with a large switch statement. But it still involves a lot of boilerplate code because each impl needs to write the visit function.
This is even more problematic if you don't own they types that need to implement visit() because then you can't write such a method. So your back to either writing a lot of conditional logic in a large function to sort them out, or you have to wrap the types with your own type.</p>
<p>In Rust none of that would be needed. You can add an implementation of an trait that is type specific.</p>
<pre><pre class="playpen"><code class="language-rust">mod processor {
# pub struct Foo; pub struct Bar;
  pub struct Processor {
    //...
  }
  pub trait Processable {
    fn process(&amp;self, processor : &amp;Processor);  
  }
  impl Processable for Foo {
    fn process(&amp;self, processor : &amp;Processor) {
      //...
    }
  }
  impl Processable for Bar {
    fn process(&amp;self, processor : &amp;Processor) {
      //...
    }
  }
}
//...
use crate::processor::*;
pub fn main() {
  let p : Processor = //...
# Processor {};
  let items : Vec&lt;Box&lt;dyn Processable&gt;&gt; = //...
# vec![];
  for item in items {
    item.process(&amp;p);
  }
}
</code></pre></pre>
<p>In the above example you may have noticed the 'dyn’ keyword. This is similar to <code>? extends</code> in Java. It indicates there is more than one implementation. IE: the type is dynamic and the actual implementation won't be known until runtime.</p>
<p>In Java you are probably also used to seeing things like:
__
Where the ‘? Extends’ indicates that the value could be any type as long as it implements the interface. This is different from 'T extends’ as there doesn't have to be a single type T.</p>
<p>So in Java to make a heterogeneous list you might do this:__ That would allow each member of the list to be a different type of _. In Rust you would write it like this __. The “dyn” keyword means that the type is dynamic and won't be available until runtime.</p>
<p>Notice here a Box is needed because “dyn” implies we don't actually know they type and hence the size which the compiler needs to correctly size the elements of vector.</p>
<p>While that might seem like a fair number of extra characters, it actually opens up a lot of flexibility. If we wanted to call a method appropriate for each member of the list, in Java we would have to implement the Visitor pattern mentioned above __. Where as in Rust we can just write __.</p>
<a class="header" href="#generics" id="generics"><h1>Generics</h1></a>
<p>• Basic syntax
◦ Functions
◦ In structs
◦ In traits
◦ Defaults
◦ Associated types
Non-trivial example to show assignment + use
• Strongly Prefer associated types on traits
◦ Better declaration syntax with multiple values
◦ Real name for type
◦ Named when used so more clear what is what vs order
◦ No call site turbofish
◦ Allows certain patterns, like continuation token. (Doesn't go up the stack)
◦ Makes faster code (one impl, static dispatch)
◦ It avoids “generics hell”
◦ If you are the one implementing the trait, you can add new types without breaking users
◦ Can also have default.
◦ Does not work for things like Add where you want many impls depending on both Lhs and rhs
◦ Only case for normal generic is for overloading
• In Rust Generics are called “Type Parameters” because that’s sortof what they are. They are parameters to the function that are types, as opposed to objects. Rust actually handles them this way as opposed to just using them to generate an error if type don’t match. For example in Rust you can define an interface with a ‘new’ method on it. __ Notice that this method does not take a ‘self’ parameter. This means you can’t invoke it on an object. It is what Java would call a static method. However unlike Java you can still invoke this function from inside of a static method. For example __. Here we have a struct that implemented out trait _ and then later when we invoked the generic method _. It used the Type Parameter to invoke the function on the correct type. In this case that parameter did not come from any of the input arguments because there weren’t any. It was inferred from the return type which the compiler obtained by looking at the type of the value we were assigning the call to.
◦ https://bluejekyll.github.io/blog/rust/2017/08/06/type-parameters.html
• Conditional trait implementation
• Traits with methods contingent of a generic implementing a specific trait.
◦ IE: cell has take if T is default or get if T is copy. Or a wrapper implements order if the thing it wraps does.
• Syntax for ‘where’ vs ‘:’ (also ‘+’)
• Generics + Builders
• Self type
◦ Can return an newly created instance of a generic type. (collect on iterator)
• Generics and dyn
• static vs dynamic dispatch
◦ Dyn keyword
• Rust avoids generics hell
◦ Ownership and borrowing save the day
◦ https://doc.rust-lang.org/nomicon/subtyping.html</p>
<a class="header" href="#type-inference" id="type-inference"><h2>Type Inference</h2></a>
<p>Rust generics look a lot like Javas. For example _ vs _.
But Rust also has some shortcuts to make things easier. For example a type can be declared like this <em>.
Here the character ‘</em>’ tells the compiler “You figure out what's supposed to go here, I'm not going to bother to type it.” obviously this only works in places where there is enough content to work that out.</p>
<p>• Declare on the right
• Where clause</p>
<p>Because traits tend to be small and only have a few methods it's more common in Rust to have a parameter that implements multiple of them. In Java you would write it like this __ the equivalent in rust is __.</p>
<p>In the case of a single trait/interface. In Java you might write __ where 'T extends’ is used to indicate there is some type T but the function doesn't care about the exact type of the object, provided it implements the specified interface. In Rust there is a shorthand for this using the 'impl’ keyword. __. This is most commonly used for return values for example __ specifies that this function is returning a _ but without providing the exact type. This is especially common when a function is returning a function. (Like a callback for example) __ here the function is specifying that it is returning a function with a particular signature but without specifying exactly which function it is returning. So you can think of impl as meaning “some implementation of this trait”. (It doesn't matter which) ‘impl’ only can refer to one trait. So if you need to use multiple, you'll have to use a where clause _ or an alias _.</p>
<p>Optimizer: I can actually make methods invoked on an ‘impl’ parameter a lot faster. So take advantage of that.</p>
<a class="header" href="#collections" id="collections"><h1>Collections</h1></a>
<p>• Vec
• HashMap
• Statically constructed collection
• Collections of primitives
◦ optimizer
• Box
◦ Add to vec or hashmap to make heterogeneous
◦ Dyn
◦ Cheaper to move than a struct if the struct is large. So anything large should be heap allocated. (Most collections including String, Vec, HashMap etc already are, so usually not a big deal)
• Structs containing traits -&gt; box.
◦ How ownership prevents generics hell
• Arc / Rc</p>
<a class="header" href="#iterators" id="iterators"><h2>Iterators</h2></a>
<p>• Adding close to iterators (not possible in Java) (can pass around in Rust)
• Fail fast iterators vs compiler
◦ Map.entry() example
• Splitting lists ranges
• Java streams vs generators
◦ Zip pair etc.
◦ Composition syntax
◦ Things like sum and such that are always on Java’s interface even when they don’t apply. It has mapToInt etc. Because traits can be implemented based on the generic type, in Rust these methods are there when they apply and gone when they don’t. This means they don’t all need weird names based on the type. They can have a single uniform name. What’s more they aren’t tied to concrete types like ‘int’ and ‘long’ they can be tied to “anything implementing add” etc.
• For( line : file) example
• Collect on Java streams vs Rust inferring type from result
◦ Single impl of collect as opposed to having a separate one for each type.
◦ Collect invers return type or via turbofish</p>
<a class="header" href="#closures" id="closures"><h2>Closures</h2></a>
<p>• syntax
• Map on iterator / option
• foreach
• Move
• Pass functions directly
• Alias allows equivalent of functional interface in Java.</p>
<a class="header" href="#enums-tuples-and-aliases" id="enums-tuples-and-aliases"><h1>Enums, tuples, and aliases</h1></a>
<p>• Range operator. Range on struct to destructure.
• Enums in Java are way better than constants in other languages like C or Go. - You know they won’t get misassigned as numbers and you can use switch statements
• Enums give more meaningful names to concepts without overhead, so you can name possible outcomes to improve API quality and reduce the chances of Error.
• Enums can implement traits
• bitflags</p>
<a class="header" href="#aliases" id="aliases"><h2>aliases</h2></a>
<p>Rust supports the concept of 'Aliasing’ this just allows you to refer to one type by a different name. This can be useful to add clearity for example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Time = i64;
#}</code></pre></pre>
<p>This will allow an i64 to be referred to as ‘Time’ like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Message{timestamp:i64};
# let message = Message{timestamp:0};
type Time = i64;
let timestamp : Time = message.timestamp;
#}</code></pre></pre>
<p>Note that Time is not a separate type. So a i64 can be passed to the function. This will not allow adding any special methods to the type, but it also means all the methods of the existing type are there. Because of these limitations, aliasing is generally not used for public interfaces, but to improve readability of code. It does have another important use: renaming an imported type. In Java if you have two types with the same name you have to refer to one by its fully qualified name.</p>
<pre><code class="language-java">import java.awt.List;
//...
class Example {
  private List awtList;
  //..
  void method () {
    //This is awkward...
    java.util.List&lt;String&gt; items = Arrays.asList(awtList.getItems());
  }
}
</code></pre>
<p>In Rust you could just rename one of types.</p>
<pre><code class="language-rust ignore">use some::value as other_value;
</code></pre>
<a class="header" href="#enums" id="enums"><h2>Enums</h2></a>
<p>Enums in Rust are different from enums in Java. They aren't just constants, they can have fields and multiple instances can be instantiated. Additionally different values can have different member variables. So in Java you can do __ but in Rust you can do __. Notice the _ parameter on the _. This can be different for different instances.</p>
<p>This is useful as it allows you to enumerate different possible return values. For example __. This would require a very awkward construction in Java.</p>
<a class="header" href="#option-vs-null" id="option-vs-null"><h2>Option vs null</h2></a>
<p>• Option implements traits
◦ Take method</p>
<p>In Java and variable can be assigned to null. (In fact there is no <code>null</code> in Rust) Rust uses an explicit Option type to convey when an object can be null. This was added in later versions of Java but it's not as helpful as it could be because it doesn't actually prevent assigning things to null, it just documents times when you expect that they can be null. As such it doesn't catch any NullPointerExceptions at compile time because these occur precisely when you don't expect things to be null. You might think the lack of nulls would result is very verbose code. But it's not much of a problem in Rust. Compare this __ to the equivalent Java __. The real advantage of making option explicit is not that it prevents null pointers but that it makes interfaces better. Take a look at Java's iterators. They need to have a hasNext() method because it cannot use null to differentiate “there are no more values” from a value that is null. Anyone who has implemented their own iterator will immediately recognize how annoying this can be.</p>
<p>Rust also supports <code>destructuring</code>. This allows assignment statements to extract values from structures. For example you could write __ to split apart a structure. Here the struct is being split up and assigned to individual variables. There is an even fancier version of this where it can be used in a conditional. Here is an example of “if let” this is extracting and assigning the value ‘x’ but does so only if the surrounding pattern matches. So in this case if the option is ‘None’ this will not match, the condition will be false and the ‘if’ will execute the code in the else block. You can do the same thing with a “while let”. __ As you can see this is useful when there is a</p>
<a class="header" href="#tuples" id="tuples"><h2>Tuples</h2></a>
<p>Rust supports Tupples. Tupples are just like 'Pair’ in <code>apache lang</code> in Java or Map.Entry. They are a simple wrapper of multiple objects. The syntax looks like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let pair : (i32, String) = (5, &quot;Hello&quot;.to_string()); 
#}</code></pre></pre>
<p>which is a tuple of a integer and a String. Tupples aren't full blown classes so the fields don't even have names. They are accessed by number.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let pair = (10, 20);
let ten = pair.0;
let twenty = pair.1;
//Tupples can also be named
struct Position(f64, f64);
let pos = Position(1.4, 3.2);
#}</code></pre></pre>
<p>Tupples should only be used when it is very clear what the represent, because without accessor methods or named fields their meaning can be ambiguous to someone who doesn't fully understand the context.</p>
<p>Tupples can have 0 or more values. An empty tuple is just <code>()</code> this litterly contains nothing and has no methods. An empty tuple is actually the return type of a “void” method. (This is sometimes called “the unit type”)</p>
<p>Tuples with two parameters are the most common. IE . But 3 or more is possible.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let tripple = (1, 1.0, &quot;one&quot;);
let quad = (2, 2.0, &quot;two&quot;, true);
#}</code></pre></pre>
<p>A single element tuple might seem pointless but it does provide a way to name something. IE:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Distance(f64);

let london_to_NY = Distance(3459.3,);
#}</code></pre></pre>
<p>Which can sometimes help with clearity. (Note: the single element tuple must have the trailing ‘,’ to distinguish it from a normal expression in parenthsis.
• https://medium.com/@robertgrosse/ref-patterns-destructuring-and-invisible-borrows-2f8ae6902656</p>
<a class="header" href="#match" id="match"><h2>Match</h2></a>
<p>• Match guards / binding</p>
<p>In the above example we introduced a new construct <code>match</code>. Match works like a souped up version of Java’s switch statement. It differs in a few important ways: It must be exhaustive, There is no fallthrough (and hence no break), it is an expression so it can return a value, It has pattern matching which lets you define what to match against, it can capture variables so the right hand side can use them. Here is a match statement that shows off all of these __ compared to the equivalent Java __.</p>
<p>Match works with destructuring __. It works on Options and Enums __. If all cases are covered, there does not need to be a default branch. It also works with ranges _<em>. (The ‘</em>’ means “you figure it out” and is a default branch.) If the paths are not mutually exclusive for example __. The first one that applies will be taken. IE __.</p>
<p>Sometimes in a destructuring expression you will see the word 'ref’. This is equivalent to a ‘&amp;’ in the corresponding place on the other side. IE __ is equivalent to __.</p>
<a class="header" href="#modules" id="modules"><h1>Modules</h1></a>
<p>• Rules of modules and files. (See the rust book)
• Inline modules.
• Testing modules.</p>
<p>It’s a good idea in Rust to follow the same design principle that a lot of Java code uses: The Single responsibility principle. Any given chunk of code should have one and only one responsibility. All the code with that responsibility should be located in single file and almost always, that corresponds with a single public structure. (Though there may be several private ones). Java formalizes this by having one (outer) class per file. In Rust you should do the same thing with modules. Each module should be in it’s own file, and have a single, clearly defined responsibility, which means in all likelihood a single public structure (and any subspecies).</p>
<a class="header" href="#cargo" id="cargo"><h1>Cargo</h1></a>
<p>• https://blog.rust-lang.org/2016/05/05/cargo-pillars.html
• Toml format
• Dependencies
◦ Dev-Dependencies
• Cargo tools
◦ Audit
◦ Test
◦ Doc test</p>
<a class="header" href="#versions" id="versions"><h2>Versions</h2></a>
<p>• Depreciation warning</p>
<p>One old idea that Rust embraces is versioning. Unlike Java (or most other programming languages) in Rust when creating a new project you explicitly specify which edition of the language you wish use. This Book is written to the 2018 edition of the language. This edition has different syntax than the 2015 edition, and future editions will change things as well. But backwards compatibility is maintained because the compiler can check which edition is being used and compile to that standard. Because regardless of which edition is being used the code is compiled to native code, code written in any edition can depend on code written in any other edition. This frees the language to evolve and change overtime without being tied down to legacy.</p>
<p>Similarly in Rust all projects are expected to use semantic versioning of the form Major.Minor.Patch where a change to the patch version means no publicly visible changes have occurred, a change to the minor version means changes have occurred but existing code should still work, and a change to the major version means dependant code needs to be re-written. Changes that break backwards compatibility are also OK prior to a 1.0.0 version.</p>
<p>The Rust language itself also versioned in this way. This is actually how Java was originally versioned. They released 1.2, 1.3, 1.4, and 1.5. But then they decided that they could drop the leading 1 because they were not going to break compatibility. Just looking at the version number you can see that Rust releases a lot faster than Java. The Language is on a six-week release cycle so it's constantly improving.</p>
<p>This rapid release cycle is made possible because it is well factored in well tested. Most of what would be considered the standard library in another language is packaged and released separately. The developers even have a tool which will build all publicly available code against a new version of the language before it is released.</p>
<p>Unlike Java, Rust has a very small standard library. Instead it provides powerful and flexible primitives, that allow many features you wouldn’t expect to be developed as libraries. This works because Rust has a built in dependency management system called Cargo.</p>
<p>Cargo is very will integrated into the language. You can think of Cargo as being similar to Gradle and Maven in Java. Each project has a <code>Cargo.toml</code> file. This is where ….</p>
<a class="header" href="#common-dependencies" id="common-dependencies"><h2>Common dependencies</h2></a>
<p>• Logging of events for metrics
• Slotmap
◦ Provides a map where the map generates the key. Efficient useful for ECS.
◦ Slotmap vs slab?
• Rtfm for embedded systems. Also Singleton. And svd2rust
• Bindgen
• Rust-simple-signal
• Fuzzers
◦ Cargo fuzz uses an address checker to verify uninitialized memory is not being read.
• Command line arg library - clap
• Serde
◦ Versioning with Enum and option
• Serde_json json Macro
• Itertools crate adds more functions
◦ Rayon, faster, etc.
• anymap - as a component registry
• Instead of rolling your own graph: Petgraph or an ECS
• Rocket
◦ Prevents: directory traversal, csrf, SQL injection, css, remote code execution, authentication, authorization, input validation, misconfiguration.
• Habitat
• Serdie
• Servo
• redox
• Tokio
• Ripgrep
• Rustfmt/racer/rustfix
• Rustup
• Cargo
• Rr
• Quick check
• Crossbeam
• Rayon
• Diesel</p>
<p>Below are some common dependencies and a brief description of what they do:</p>
<p>Cargo</p>
<p>Rustup</p>
<p>Rustc</p>
<p>Random</p>
<p>High precision math and units
IoUtils</p>
<p>Builder equals, hash, and serializable
Log</p>
<p>slog</p>
<p>Similar to Junit
Benchmark / criterion</p>
<p>Example testing</p>
<p>Quick check / propcheck</p>
<p>Checksyle</p>
<p>Findbugs</p>
<p>Lint (clippy)</p>
<p>Fuzzers: afl / hongfuzz / cargo fuzz</p>
<a class="header" href="#rustc" id="rustc"><h2>Rustc</h2></a>
<p>If you've been programming in Java for a long time you're probably used to compiler-errors that you just look at to get the line number and then go to the that line and see what's wrong. IDEs have mostly even obsoleted this by just underlining the problem, which is usually sufficient to work out the problem. Rust goes well above and beyond this. It has very clear and detailed error messages explaining exactly what the problem is some of which even suggest Solutions what's more each error message has a number associated with it but you can look up online and see if full documentation as to why that error message occurs examples of it occurring how to avoid it and how to structure code so is to prevent it from being a problem.</p>
<a class="header" href="#equivalent-frameworks" id="equivalent-frameworks"><h1>Equivalent frameworks</h1></a>
<ul>
<li>
<p>Licence compatibility - Just fix it.</p>
</li>
<li>
<p>Licence auditing for everyone: like Rat. But automatically through all transitive deps.</p>
</li>
<li>
<p>Integrate https://github.com/onur/cargo-license to automatically check</p>
</li>
<li>
<p>Security audit - add to environment recommendations</p>
</li>
<li>
<p>Security notifications for everyone: any and all security vulnerabilities should propagate a fix as quickly as possible. Issue warn on build so the new dep can be pulled.</p>
</li>
<li>
<p>rustsec should be integrated and on by default in Cargoz</p>
</li>
<li>
<p>Localization with fluent</p>
</li>
<li>
<p>Rocket web service</p>
</li>
</ul>
<a class="header" href="#error-handling" id="error-handling"><h1>Error handling</h1></a>
<p>Java has both checked and unchecked exceptions. This is been criticized a lot of people both inside and outside Java community how are the original ideas actually sound. Checked exceptions make sense where the exception is expected to be handled by the immediate caller. unchecked exceptions make more sense were the exception just isn't anticipated at all, for example because it results from a situation that would require a programming error. this leads to a pattern that's rather elegant in theory: known failure modes must be handled explicitly, while unknown ones propagate up the stack as far as necessary until there's some general catch-all block that deals with them.</p>
<p>Java's implementation of this however isn't ideal. Part of the problem is in early versions of Java an implementation had to declare that a method throws an exception if it implemented an interface that declared such an exception. While this is no longer the case, it is the reason why ByteArrayOutputStream still throws IOException. There are also a couple of cases where Java defined things is a very awkward way, like that InputStream's and OutputStream's close method throws, or that InterruptedException is both checked and catching it resets interrupted status. Finally and more subjectivity, RuntimeExceptions and checked exceptions FEEL too similar. It's too easy to think of them as part of the same thing, and not realize the massive difference between ordinary errors and cases that truly cannot be handled, because they arise from bugs in the program itself.</p>
<p>All of this combined with a lack of a concise way to rethrow one exception as another lead to a large backlash against checked exceptions. This is somewhat unfortunate, because similar to how the backlash against some annoying corner cases with types resulted in the popularity of dynamic typed languages, the backlash against the inconveniences of checked exceptions directly lead to C# removing them and using a strictly runtime exception model. Which while more convenient than Java's model was a step back in terms of ensuring correctness.</p>
<p>Fortunately Rust has found a way to resolve these issues. Rust's solution is quite different from Java's. But it is similar in that there are two types of error handling. The “normal” way, which is used for expected errors provides strong guarantees that the error will be handled. Rust's error handling syntax is very lightweight. It doesn't require writing try/catch blocks all over the place, and provides a seamless way of converting between different exception types and converting to the “unrecoverable” type (analogous to Java's runtime exceptions) allowing a way to “bail out” instead of handling the error, if there isn't a way to do so. Below is an example __. (See Joe Duffy's “The error model” and use table)</p>
<p>In Java it is common to use Preconditions. The pattern in Rust is to use assertions. So the following are idiomatically equivalent</p>
<pre><code class="language-java">class Decoder {
  //...
  public Message decode(String message) {
    Preconditions.checkNotNull(message);
    Preconditions.checkArgument(!message.isEmpty(), &quot;Cannot decode an empty message.&quot;);
    //...
  }
}
</code></pre>
<p>and</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Message();
struct Decoder {
  //...
}
impl Decoder {
  //...
  pub fn decode(&amp;self, message : &amp;str) -&gt; Message {
    //No need for a null check because there are no NPEs in Rust.
    assert!(!message.is_empty());
    //...
  # Message()
  }
}
#}</code></pre></pre>
<p>If instead of panicking you just want to return an Error, use the 'ensure!’ macro from the Failure crate.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use derive_more::Display;
use failure::*;

struct Message{/* ... */}

struct Decoder {
  //...
}
impl Decoder {
  //...
  pub fn decode(&amp;self, message : &amp;str) -&gt; Result&lt;Message, Error&gt; {
    ensure!(!message.is_empty(), &quot;Message was empty&quot;);
    //...
    Ok(Message{/*...*/})
  }
}

#}</code></pre></pre>
<p>One problem with Java's exceptions is they don't work with things like Futures or Java Streams very well. This is because these interfaces need to be generic so the type information in the exception is lost, and they are likely running from a callback or threadpool so the stacktrace is not helpful. This eliminates two of the main benefits of using exceptions. Fortunately Rust's model overcomes both of these problems. So where in Java you would have to write something like this __ and if it failed you would get a stack traces that looked like __, whereas in Rust you could just write __ and if it failed you would get a stacktrace that looked like __.</p>
<p>To add a new exception type on a public interface, in Java you would either have to make the new exception Runtime. (Which may or may not be desirable depending on the circumstances) Or you can subtype an existing exception. In Rust the pattern is to use an error Enum. For example __. This way all the errors are explicitly enumerated and they can either be handled all the same or individually by the caller. If you use a non-exhaustive Enum like __. Then new types of failures can be added in the future without breaking compatibility. (Because in a matching on the Enum will require a default branch)</p>
<p>In Java there are checked exceptions such as IOException and unchecked exceptions such as Error. Rust has analogous concepts. Panic is a similar to an Error in Java. It is assumed to be unrecoverable. It is sort of a controlled crash. In the event of a panic rust will gracefully unwind the stack similar to Java. It runs destructors (which works like a finalize block in Java). However it will not release locks, as this could mean that only a part of a critical section was executed and the data is left in an inconsistent state. (Other threads trying to acquire the mutex will get error when they call lock()).</p>
<p>In addition Rust has error types these work like a return value but with some special syntax surrounding them. This ends up working a bit like checked exceptions in Java.</p>
<p>Exceptions like many things in Rust are a crate for imported. The preferred implementation is one called “Failure”. much like Java it allows you to create your own exception types chain exceptions together when one causes another, and provides stack traces. However exceptions in Rust work differently than they do in Java. In fact the exceptions isn't really the right word they work somewhere between a return value at an exception. They do however have a very compact syntax which is helpful.
In Java you might write __. The equivalent Rust would be __. Notice that the exception is actually part of the return value. Specifically the function either returns a _ or an Exception. If that was all there was, it still would be a step up from languages like c or go in that you cannot forget to check the value. But having to manually unwrap each return value and usually re-throw the exception at every stack frame would be very tedious and seem down right primitive compared to Java. Fortunately this is not the case. You can use a special operator the question mark. If you have code like the following: __ the? Was simply rethrow the exception. but that's not all you can also convert between exception types automatically changing the new exception to the old one. For example you might write the following code in Java: __. This is very verbose and not very clear in terms of its flow. However it is equivalent to the following Rest code: __. as you can see this is both very explicit and compact it shows the flow control very nicely you can see the points where function can exit, and it does so without any extraneous indentation Constructors or unnecessary blocks. Just to show a more sophisticated example the following are equivalent: __ and __. The exception generated will look like __ and __. but notice the rest code didn't have nice line numbers in backtrace is for the intermediate functions. fortunately to enable this is quite simple you just set the environmental variable RUST_BAKTRACE=1. Then it will print the following __. Because this doesn't add any overhead in the non-failure case (and is fairly cheap even in the error case), and increases debuggability I simply leave this on all the time.</p>
<p>In Java a common approach is to have use multiple subclasses of a common exception. In Rust the pattern is to use an enum. So this Java function <em>(io)</em>, would be written like this in Rust. __. So in Java a caller handling these together would just catch _ or would handle them separately with multiple catch blocks __. In Rust they can be handled collectively __ or via a Match statement __. However this code is messy and verbose. So Rust allows you to instead write __. This is exactly the same as the above code. The ? Operator unwraps the result object if the call was successful, otherwise it returns an error, and if the method’s error type is different it will automatically call __ to wrap or convert the error. This pattern is commonly used in conjunction with a crate called Failure which automatically generates a lot of the boilerplate code for you and provides backtraces that can we accessed just like in Java 10. __. The advantage of Failure backtraces as opposed to Java's is they automatically work across threads. __</p>
<p>Another common pattern in Rust that gets exceptions even further out of the way is to Alias error. For example __. Then all the methods can just have __ in their signature and not have to type the exception signature over and over.</p>
<a class="header" href="#destructors" id="destructors"><h2>Destructors</h2></a>
<p>• Destructors
◦ Drop trait
◦ Mutex
◦ Refcell
◦ Can't fail to close socket or file</p>
<p>Programming in Rust means never having to close a Socket…. ...</p>
<p>Another good example of where destructors are used is Mutexes, these are used for synchronization and will be discussed more in the next chapter. The mutex returns a mutexguard object. This is a wrapper object that holds the lock while it is in scope. The mutexguard locks the mutex when it is created and unlocks it when it goes out of scope. This works similarly to a try-with resource in Java. IE:__ Because he only to access the value is though the mutexguard it is impossible to misuse the interface. If you have access to the variable you must be holding a lock. There is no way to forget to either acquire or release the lock.</p>
<p>If in Java an exception is thrown from inside of a synchronized block, (assuming it is not caught inside) the lock will be released and the exception will propagate up the stack. Certainly this is desirable in the case where the exception is being deliberately thrown. But in the event of an Error this might be undesirable. The lock will be released and other threads will proceed to use it even though it only completed half of the critical section. This might be harmless or it might leave the object in a bad state and trigger weird problems in other threads. This is an example of why treating unexpected and expected errors in the same way is not a great idea.</p>
<p>Rust resolves this by distinguishing between an panic and a normal error. It is expected that critical sections may return errors. If they do, the lock is released normally and other threads can use the guarded resource. Critical section however are not expected to panic. If one does, in the destructor of the mutexguard it will detect the panic and “poison” the lock. This will mean any thread attempting to acquire the lock will receive an error and won’t be able to access the guarded resource. This acts as a safety check against the data being left in an inconsistent state.</p>
<a class="header" href="#how-rust-makes-you-a-better-java-programmer" id="how-rust-makes-you-a-better-java-programmer"><h1>How Rust makes you a better Java programmer</h1></a>
<p>• “Data structures make it easy to add new functions without changing the structure. Where as objects allow adding new classes without changing the functions.” Oo makes it hard to add new functions, but traits allow this.
• Shared mutable state is the source of most bugs.
◦ Oo languages limit sharing by hiding an impl behind the interface of an object. This is vastly better than the alternative. But doesn't fully hide things because …
▪ Indirection allows hidden changes
◦ Functional languages remove mutable state. That prevents many problems, but it makes it much harder to do certain things. Which introduces its own bugs. Or you end up writing a lot of code to make immutable state look like mutable state. Which ends reintroducing some of the problems that were prevented.
◦ Rust allows mutability without sharing, or sharing without mutation, but never both at the same time.
• The expression problem: The goal is to define a datatype by cases, where one can add new cases to the datatype and new functions over the datatype, without recompiling existing code, and while retaining static type safety (e.g., no casts)
• How rust makes you better at Java
◦ Ownership
▪ Nested sync
▪ Modifying an object after passing.
▪ Graphs
◦ Composition over inheritance
◦ Circular references
▪ Are a problem, for c..
▪ Are not needed most of the time.
▪ Usually for a callback. That is better handled via
• FUtures
• …
▪ Don’t fear copies. (10x java copy speed)
• to_owned() from a ref
◦ Solid principles</p>
<p>Rust’s strict enforcement of rules makes a lot of bad patterns particularly hard to write. This can be a good thing if you recognise when something is going wrong, because it stops you from making a design mistake. &lt;Insert don’t fight the borrow checker&gt;
For an example of this see the article “Too many linked lists” or the Rustconf 2018 closing keynote “__”.</p>
<a class="header" href="#thread-safety-provided-by-ownership" id="thread-safety-provided-by-ownership"><h2>Thread safety provided by ownership</h2></a>
<p>• Race conditions and ownership.
◦ Race by releasing lock
◦ Compare java and rust
• Deadlock
◦ In one class (obvious)
◦ Cyclic dependency
▪ Final initialization prevents
• Not always practiced in Java
• Often people do realize memory model implications
• Rust pattern is really akward and discouraged.
• Rust compiler correctly identifies memory model problem and forces you to grapple with it.
◦ Object passed in during call
▪ Java rules should prevent
• Often not practiced.
• Not as easy to spot because you can't tell at the call site. If code not always following rules and classes are mixed.
▪ In Rust still possible. Example: a owns b, c. B holds c. A passes B to C by reference. B and C both have inner objects guarded by a mutex. The scope of the guard extends over calls to each other.
• Could be prevented by the old fashioned advice to keep the scope of locks small.
• Should be aware of such cycles. Not always obvious. Rule of thumb is not to invoke methods on some other argument while holding a lock. For example __
• In general in Rust if you are using a mutex over two objects you are doing it wrong. It is reasonable to make updates atomic, but the lock is in the wrong place. It should just wrap the thing that needs to be made atomic. So instead just hold onto the inner objects directly and make the method take a &amp;mut self. Then wrap the object in mutex one level up.
◦ Call back
▪ Never invoke a callback or complete a future while holding a lock. (In any language)
• Really blatant violation of invoking a method on a passed object while holding a lock.
▪ This is the ultimate narrow the scope of a lock. Who knows what a callback includes!
▪ In Rust this is not a problem for futures as, unlike Java's they don't work as a callback. They get run by the executor. It's like if in Java you invoked __ every time instead of __. This is a safe way to avoid holding a lock in Java. Unfortunately it does have some overhead, so most codebases can't afford to simply have the rule that it should be used every time. Fortunately Rust have found a way to use their ownership model to make their futures Radically more efficient. For example <strong>benchmark</strong>.</p>
<p>How to write thread safe code in Java….</p>
<p>These concurrency rules help deal with cases where you have multiple independent tasks running in parallel, or where you have a shared state the needs to be coordinated between two tasks.
Another pattern is message passing. This is also often used in Java using Queues such as the ArrayBlockingQueue or the LinkedBlockingQueue or the synchronunsQuntne. These are totally compatible with the model, they should just be considered an…..</p>
<p>When I was first learning Rust, after reading the Rust book, I started reading the trust-dns codebase to make sure I understood things. I remember being shocked when I saw this: https://github.com/bluejekyll/trust-dns/blob/master/https/src/https_client_stream.rs#L38 I saw and Arc around the String and was immediately afraid. Coming from many years of managing thread safety in Java, the idea that a mutable class (String) was being shared across threads (why else would it be wrapped in an Arc), and this object was wrapped in a struct that was going to be returned from a function (Implied by the #must_use annotation) nearly sent me into cardiac arrest! (And if it didn’t deeply frighten you, let me assure you, your code is riddled with thread safety errors).</p>
<p>In just 7 lines of a struct definition, it is violating every possible tenet of writing thread safe code at the same time. And yet… it’s ok. String is itself mutable, Arc won’t allow any mutable borrows of the value unless there is only one reference to it. And the string is owned by the Arc, so there can’t be code anywhere that could have a direct reference to the string. So even though String can be modified, and is shared, and the struct is shared across threads, and is returned out of a public method, any code using that string can treat it as immutable. It will never change out from underneath it.</p>
<p>After spent years working strictly following the discipline above, teaching it to all of my co-workers and carefully reviewing code for compliance, I always thought having the compiler enforce thread safety was just a matter of automating this work. It would be just like writing code in Java, but the conventiones would be formalized, and the review would be done by the compiler. What I didn’t anticipate was that having safety enforced by the compiler would open up new possibilities. A pattern like the one in the trust-dns client would never be allowed, because no sane person would ever want to use it in Java, because it would be hopeless to ever get right. But in Rust, it was just nonchalantly written by someone who didn’t even think about it because they <em>knew</em> the compiler would keep things safe. I think that’s pretty cool.</p>
<a class="header" href="#concurrency" id="concurrency"><h1>Concurrency</h1></a>
<p>• Futures_cpupool
◦ Futures chaining
◦ Async / await.
◦ Futex
• Async example w/ futures
◦ Select and join compared to and and or in Java
◦ Futures with streams (.buffered)
◦ Performance
• Async! Macro
• Arc
• Queue example / channels
◦ Send attribute
◦ Select
◦ using channels doesn't prevent race conditions because Go lacks immutability. In Java the same problem exists. In Rust it ownership is explicit so it’s safe
• Turn a sync API into an async one</p>
<p>In Java you would synchronize the code like this.__ In Rust you synchronize it like this.__  In both cases the lock is guaranteed to be released at the end of the scope. In Java’s case it is because a special scope is being introduced. In the case of Rust, there is no special language feature it just uses the normal destructor to release the lock. This means a new scope does not need to be introduced. Of course you can add one line this __ if you want to reduce the scope a lock is held. (This could also be done with a private method). Another common pattern is to use a loop conditional expression __ as this has a very small scope.</p>
<p>Locks in both languages work the same way, if one thread holds the lock, another thread attempting to acquire the same lock will block.</p>
<p>The mutex object returns a MutexGard object which works like a RefCell. It allows for mutablity borrowing the data but does not allow for taking ownership.</p>
<p>Safety Monitor: Notice that the type perfectly reflects the guarantees. The mutex is guaranteeing only a single thread can hold the lock at any given time, and hence follows the contract of mut. And the value is borrowed so it can't be accidentally stored into some other object which would allow it to be accessed outside the scope of the lock.</p>
<p>In Java the pattern is that locks should live inside of the class and it is the responsibility of the implementation to implement the locking. This makes sense as the code is relatively compact and all located in a single file which makes it easier to validate. In Rust the pattern is to do synchronization outside. This has a few advantages: it allows callers to make multiple calls under the same lock, so two or more calls in order can be done atomically together without using a second lock. It also means the class can be written once without thinking about thread safety and added by the caller if needed. Applying this pattern to Java would be a bad idea because it would be very hard to verify the lock is held everywhere the data is being accessed. By putting all of the places you need to check into a single file, you can verify it is correct. This is not a problem with Rust because the correctness will be enforced by the compiler. Applying the Java pattern to Rust is also a bad idea. Because other someone else in another module can add methods to your objects neither the compiler nor any of the standard tools will allow a pattern where all of the methods on a particular object are expected to do something.</p>
<p>In Java it is important to encapsulate state for ownership and in turn thread safety. In many functional programming languages the pattern is to do the reverse and have the state passed into the function. The advantage of this is it makes the program very easy to test. Example:</p>
<hr />
<p>In Rust because the ownership contract is explicit it becomes easier to write more testable code around state transitions. Example:
__
This retains the strong ownership and safety guarantees of the Java version while improving the testability.
This can be made explicit using types. If we write it like this the compiler will enforce the correct pattern on callers.
__
Notice that as far as the caller is concerned they are dealing with a single class, but internally we have made it such that only the valid sequence transitions can occur.</p>
<p>Here is an example of how to make a thread safe version of a Map in both Java and Rust. __ In Java we use Collections.synchronizedMap(). The implementation of this looks like __. There are a few things to notice. First, this is very specific to Map. It can't even deal with a nested data structure. So the standard library needs a different one of these for every collection and have to write your own class like this for every data structure you create. Not great in terms of code duplication. Additionally it does not solve the whole problem. The method iterator() and stream() note this in their Javadocs. The caller is expected to grab the lock like this __. This is not ideal because it breaks the abstraction and it's not safe because there is nothing to check and make sure the caller actually does this. Finally the caller itself could modify the map when iterating over it. This would result in incorrect behavior even in a single thread. None of these sort of mistakes are possible in the Rust version as they would all be compile errors. (The iterator method borrows the collection, so it cannot be modified elsewhere before the iterator is dropped.) __</p>
<p>There is a popular crate called Rayon that takes this one level further. If you import Rayon it adds a concept of a parrallel iterator, to automatically provide data-parallel operations on most data structures. For example if you have __ you can just change ‘.iter’ to ‘.par_iter’ like so __. Then the code will run in parallel on multiple threads. All the needed synchronization and coordination is managed by Rayon, and all safety guraentees remain in place. So if you accidentally tried to modify an outside variable without synchronization like this __ the compiler will catch it and produce and error _.</p>
<p>Another elegant albeit rarely used pattern in Rust is Cow. COW stands for copy on write. Cow is similar to Java’s CopyOnWriteArrayList or CopyOnWriteArraySet but it isn't specific to a single data structure. It is generic and can wrap any cloneable object. It will clone the object if it gets modified while there is another reference outstanding. Which means if cow is wrapping a list that is modified in a loop, the list will be copied at most once.</p>
<p>There are two important traits 'send’ which indicates a type can be sent from one thread to another. And ‘sync’ which indicates a type can be accessed by multiple threads at the same time. These are Auto traits. So the compiler will automatically work out for each type if it is one or both of those. So while you normally don't need to think about them, they can be useful if you want to declare this requirement on an interface. For example __. Here the interface explicitly requires that the Type passed in be sendable between threads.</p>
<p>In Java if you had an application where you were dealing with users and users are allowed to perform certain operations once they have been authenticated. Then you might define two different classes _ and _. Then your method signature could like _ and AuthenticatedUser could look like this _. The advantage of this approach is there is not an “isAuthenticated” boolean that you could forget to check, or that could be accidentally set through some other code path. Here the only way to invoke the sensitive method is to have an AuthenticatedUser and the only way to get one is to call Authenticate. This is in effect using Java’s type system to enforce an invariant in your code. These sort of techniques allow Java code to offer stronger security guarantees than more dynamic languages like Ruby or Python. It Rust this pattern is even more common because in addition to types, Rust's stronger notion or generics, Traits, Lifetimes, and ownership allow many different types of guarantees to be enforced. This is worth thinking about when you are designing interfaces. A great example of this is the “mpsc” class in Rust's standard library.</p>
<p>In CS theory there is a really clever and very low overhead lock-free algorithm for transferring data between threads. However it only works if there is only a single thread that is receiving the data. This is still handy because it is common to have many worker threads reporting their results back to some master thread. This algorithm was actually well known at the time that Java was designing its concurrent collections. But it wasn't used. It wasn't because it would be very awkward to explain. Imagine reading the docs to a class like LinkedBlockingQueue and seeing a long explanation of which threads were allowed to call which methods. Because this would simply be too error-prone Java only provided a less efficient but more general algorithm. The crux of the problem was that Java just couldn't represent the restrictions on the object within the language itself. This isn't true in Rust. You can see an implementation of this in std::sync::mpsc (mpsc is an acronym for multiple producer single consumer). FOOTNOTE:(This isn't the only or best way to send data between threads. If you are looking for a more flexible alternative check out crossbeam-channel)</p>
<p>(While the implementation of mpsc isn't a big deal, it is a useful example to show how complicated restrictions can be modeled). To create sure a channel you call _ and it returns two objects a sender and a receiver, where items sent to the sender go to the receiver. The sender implements clone which means you are free to make multiple copies of it. (The copies are similarly connected to the receiver) Both sender and receiver implement the trait Send but not the trait Sync. This means they can be passed to another thread but not used by multiple threads at the same time. (This is enforced by the compiler) The channel is closed automatically when all the producers or the consumer are dropped. While this pattern looks a little odd, it creates an interface that is impossible to use incorrectly. So even though the requirements for this algorithm are oddly specific, Rust allows it to be implemented in a way where any bug in the way it is used will be a compilation error. This is the Rustacean ideal. </p>
<a class="header" href="#testing" id="testing"><h1>Testing</h1></a>
<p>• Assert and derived macros (dbc and hoare)
◦ Used as preconditions and for tests</p>
<p>Rust has a strong culture of testing. Testing is built into cargo. They are run by invoking 'cargo test’. Tests are declared like this __. This is very similar to Junit in Java. Assertions can be made like __ or __.</p>
<p>The way interfaces work in Rust make it easy to mock out components. For example __.</p>
<p>Cargo can also generate code coverage reports via the __ command. These are compatible with _ and so you can visualize them in __.</p>
<p>Rust also supports randomized testing. Two popular libraries for this are _ and _. They work as follows __ or __ <need to pick one></p>
<p>Cargo also has built in support for microbenchmarking. This is done by writing a test like __. The _ does all the timing for you. All you have to do is implement the function to be benchmarked. You can run benchmarks via _. This shows output and allows you to track changes across versions by __.</p>
<p>• Tools for profiling: perf
Visible for testing and Mocks
• Mocking example
• Yup-hyper-mock</p>
<a class="header" href="#debugging" id="debugging"><h1>Debugging</h1></a>
<a class="header" href="#operator-overloading" id="operator-overloading"><h1>Operator Overloading</h1></a>
<p>• Size() length, get(), []</p>
<p>Traits are also used to what in other languages is called “operator overloading”. For each operator like ‘+’ for example there is an associated trait, which has a method that can be implemented. If an object has an implementation of the trait, you can use the operator as a shorthand for invoking that method. For example in Java it is very common to implement Compairable. However only primitive types can use the ‘&lt;’ and ‘&gt;’ operators. So you have to write:
__
Where as in rust if your type implements the Ord trait you can just write:
__
Note that Ord compares the object against others of the same type so unlike Java you don't have to worry about a class cast exception at runtime.</p>
<p>Unlike C++ or Scala all of the operators that can be overloaded and the signature of their corresponding methods is pre-defined by the language. Because implementing a trait is only allowed in the package that defined either the trait or the type you can add support for operators to your own types, but you can't add or alter their behavior on someone else's types. So you can't add you own “pope operator” that looks like “&lt;+|:-)”. And operators can't be used to do anything crazy or surprising.</p>
<p>Operators are just syntactic sugar for the method call, so they are still statically checked at compile time. So using them your code is every bit as safe if you simply called the corresponding methods yourself.</p>
<p>Below is a table of operators and the corresponding trait that allows you to implement support for them.
__</p>
<p>One common operator is known as the “deref” operator. It's trait is defined as __. The idea of deref is to allow access to a wrapped inner object. You may have heard invoking a method on a member variable is: “this.foo.bar()” refered to as “dereferencing” the member variable. This is where the name comes from. ‘Box’ implements 'deref’. This allows you to write __ or even more simply __. This allows you to treat a 'Box<T>’ as though it was a T most of the time, which makes working with Box a lot more convenient.</p>
<p>Similarly MutexGard implements deref. So you can just write __. And use the methods on the guarded object directly without having to unwrap it.</p>
<p>This even holds for assignment. So with a Box you could write __. Or with a MutexGard you could write __.</p>
<p>Suppose you want to add some functionality to a type, the easiest way is to wrap it and add the functionality to your wrapper. For example to make an existing type sortable, in Java it would look like __. In Rust it would look like __. Of course you probably want to get the original object out of your wrapper so you can actually use it. In Java you might use a getter. In Rust you would use Deref. Deref is the trait the corresponds with the ‘*’ prefix operator. So you can do this __.</p>
<p>The deref method will automatically be invoked by the compiler any time an object is passed to a method expecting a type that it can deref into. This means for example you could pass an object like this __ because the method is implemented for _ and the wrapper will automatically have its deref method called and the result passed to the function.</p>
<p>A good example of this is String. Strings much like arrays support slicing. So you can take a view of a subset of a string. This is similar to the way in Java you can have a ByteBuffer which provides a view of a subset of a byte array. String implements Deref for str. Given a borrowed string it returns a borrowed slice containing the whole string. So you invoke deref explicitly or just pass a String anywhere a string slice is expected, the conversion is done for you automatically. This is even true when invoking methods on the object. Say you have a borrowed String. You can call ‘.chars()’ and get the characters in the string. Even though the ‘chars’ method was actually defined for the string slice.</p>
<p>Now imagine that for your own wrapper types, it means they be generic to what they contain an still allow the caller to invoke whatever methods they need on the wrapped object with no syntactic overhead safely without any ambiguity. (Cool right?) It should be noted that because Deref is automatic, it is not meant for costly conversions. For that you should use the ‘From’ or ‘Into’ traits. Where the conversion is more explicit.</p>
<a class="header" href="#lifetimes" id="lifetimes"><h1>Lifetimes</h1></a>
<p>• http://cglab.ca/~abeinges/blah/too-many-lists/book/second-iter.html
• Normally figured out by the compiler for you
◦ Here is what it is doing
◦ Only applies to borrows, not to owned items, and not the item being borrowed.
▪ This means that for instance you can specify a single ‘a on one of the parameters and the return value to indicate that the returned value came from that parameter and therefore the borrow should last as long as the parameter’s it came from.
▪ Similarly you can have a case where the value could come from more than one input, you can just add a parameter to all the relevant inputs __. This will result in compiler checking that the original objects this function is borrowing live at least as long as the result returned from this function.
▪ Notice that we don’t actually have to know where the inputs came from or have any idea how long they will live. The compiler will just check and make sure things are OK.
◦ Specified with a lowercase letter to distinguish from T.
◦ Convention is to start with ‘a and then ‘b etc.
◦ Unlike a generic value T they don’t have any meaning. They are only needed to distinguish one value from another.
▪ Example
• Statics lifetimes - live for as long as the program.
◦ &amp;str is often this. Because string constants are part of the program itself and hence by definition exist for the lifetime of the program. You can of course borrow them, and when you do they have a static lifetime.
• Destructors
• try/with replaced by destructor
◦ Examples
• Destructors cannot fail and shouldn’t block. So sometimes close exists.</p>
<a class="header" href="#cool-rust-tricks" id="cool-rust-tricks"><h1>Cool Rust Tricks</h1></a>
<p>• Zero cost abstraction
◦ Create a wrapper type like append only vec. (Makes contract clear, removed by optimizer)
▪ Can have intoVec which requires ownership. Prevents calling 'externally’
◦ Is whitespace
• Really low memory use
◦ Skylight by Tilde went from a 5gb jvm to 50mb in rust
◦</p>
<a class="header" href="#writing-mactos" id="writing-mactos"><h1>Writing Mactos</h1></a>
<p>• Vs reflection</p>
<p>In Rust you will find yourself using macros in a lot of the same places you would use reflection in Java. Which is to say in a normal program, almost never. But they are often a core component of any sort of framework or library that automates writing a bunch of boilerplate code.</p>
<p>We've already seen simple macros like 'println!’, 'format!’ as well as some more complicated ones like Serde’s serialize/deserialize. Now we're going to get into how they work.</p>
<p>Macros work by running code at compilation time. This is done by invoking the macro i to the</p>
<p>Macros can even be used to write other macros. Because writing macros is complicated there is a simple macro defmac! That lets you define a macro with a very simple syntax. You can write __ to define a macro that will __. Compared to this Java code __ . This is all run at compile time and ____</p>
<a class="header" href="#command-line-programs" id="command-line-programs"><h1>Command line programs</h1></a>
<p>• Signals (os)
• DSL
• Builder pattern works the same way in both langs, but ownership sometimes helps
• Clap and glob</p>
<p>Command line applications is another area where rust shines. Normally you might write things in bash but it quickly becomes unreadable after a couple hundred lines of code. Pearl and Python are commonly used and work reasonably well but they have some serious drawbacks in both performance and compatibility. (IE if you wrote and tested you code on version 2.3 on Linux, it might or might not work running in version 2.2 on Windows) You could use Java, Go, or C++ but they involve writing a fair amount of boilerplate and they never really feel very natural for command line application. Where as Rust has high level features and ability to run on Windows, Mac, and Linux without any special work. It can do this by compiling into a single binary file that has no dependencies on any vm, interpreter, or library already being installed on the system. Additionally libraries like <code>clap</code> or <code>quicli</code> make parsing args easy.</p>
<a class="header" href="#example-program" id="example-program"><h1>Example program</h1></a>
<p>Web server example (mio, surdie, tokio, rotor, hyper)
• Writing a parser
• Performance</p>
<a class="header" href="#webasm" id="webasm"><h1>Webasm</h1></a>
<p>these days almost everyone uses JavaScript and not job in the browser. You could use a tool kit like GWT to do cross compilation but this comes with some significant downsides. So generally speaking if you're using Java and your back and you usually use JavaScript in your front end. in practice this eliminates shared code which is often necessary to do things like validation. it is often difficult to have two copies of the same code written in different languages, and in practice probably by different people, maintained identical functionality as changes are made over time. so this gives rise not only to wasted time and effort but also potentially to security vulnerabilities, an area where JavaScript is already not great.</p>
<p>Rust can execute through something called Web assembly. This means programs written in Rust can safely run in the browser without any special plugin. This allows you to use Rust for both your front-end and back-end code. It also provides your in-browser code with the safety of Rust and the performance of native code. This is a huge win for productivity because it means you can have a single code base with a much higher degree of validation testing.</p>
<a class="header" href="#using-rust-with-java" id="using-rust-with-java"><h1>Using Rust with Java</h1></a>
<p>• Crossbeam
• Jni crate
• Unsafe
◦ Don’t do it.
◦ Not faster
◦ Really unsafe.
◦ Better to have tiny parts like split at mut
◦ Just because you can doesn't mean you should.
◦ Use sanitizers and prop/quickcheck or fuzzer
◦ Rust-san
▪ Note that rust has __ enabled by default. (As opposed to go)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
