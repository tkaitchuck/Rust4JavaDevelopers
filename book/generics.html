<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Generics - Rust for Java developers</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guiide to learning Rust for developers familiar with Java">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="why_rust.html"><strong aria-hidden="true">1.</strong> Why Rust</a></li><li><a href="history_of_rust.html"><strong aria-hidden="true">2.</strong> History of Rust</a></li><li><a href="rust_community.html"><strong aria-hidden="true">3.</strong> The Rust Community</a></li><li><a href="variable_declaration.html"><strong aria-hidden="true">4.</strong> Variable declaration</a></li><li><a href="method_signatures.html"><strong aria-hidden="true">5.</strong> Method Signatures</a></li><li><a href="flowcontrol.html"><strong aria-hidden="true">6.</strong> Flowcontrol</a></li><li><a href="ownership.html"><strong aria-hidden="true">7.</strong> Ownership</a></li><li><a href="objects.html"><strong aria-hidden="true">8.</strong> Objects and Traits</a></li><li><a href="generics.html" class="active"><strong aria-hidden="true">9.</strong> Generics</a></li><li><a href="collections.html"><strong aria-hidden="true">10.</strong> Collections</a></li><li><a href="enums.html"><strong aria-hidden="true">11.</strong> Enums, tuples, and aliases</a></li><li><a href="modules.html"><strong aria-hidden="true">12.</strong> Modules</a></li><li><a href="cargo.html"><strong aria-hidden="true">13.</strong> Cargo</a></li><li><a href="equivalent_frameworks.html"><strong aria-hidden="true">14.</strong> Equivalent frameworks</a></li><li><a href="error_handling.html"><strong aria-hidden="true">15.</strong> Error handling</a></li><li><a href="rust_makes_you_better_at_java.html"><strong aria-hidden="true">16.</strong> How Rust makes you a better Java programmer</a></li><li><a href="concurrency.html"><strong aria-hidden="true">17.</strong> Concurrency</a></li><li><a href="testing.html"><strong aria-hidden="true">18.</strong> Testing</a></li><li><a href="debugging.html"><strong aria-hidden="true">19.</strong> Debugging</a></li><li><a href="operator_overloading.html"><strong aria-hidden="true">20.</strong> Operator Overloading</a></li><li><a href="lifetimes.html"><strong aria-hidden="true">21.</strong> Lifetimes</a></li><li><a href="cool_rust_tricks.html"><strong aria-hidden="true">22.</strong> Cool Rust Tricks</a></li><li><a href="writing_macros.html"><strong aria-hidden="true">23.</strong> Writing Mactos</a></li><li><a href="command_line_programs.html"><strong aria-hidden="true">24.</strong> Command line programs</a></li><li><a href="example_program.html"><strong aria-hidden="true">25.</strong> Example program</a></li><li><a href="webasm.html"><strong aria-hidden="true">26.</strong> Webasm</a></li><li><a href="rust_with_java.html"><strong aria-hidden="true">27.</strong> Using Rust with Java</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust for Java developers</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#generics" id="generics"><h1>Generics</h1></a>
<p>• Basic syntax
◦ Functions
◦ In structs
◦ In traits
◦ Defaults
◦ Associated types - FromStr provides a good example.
Non-trivial example to show assignment + use
• Strongly Prefer associated types on traits
◦ Better declaration syntax with multiple values
◦ Real name for type
◦ Named when used so more clear what is what vs order
◦ No call site turbofish
◦ Allows certain patterns, like continuation token. (Doesn't go up the stack)
◦ Makes faster code (one impl, static dispatch)
◦ It avoids “generics hell”
◦ If you are the one implementing the trait, you can add new types without breaking users
◦ Can also have default.
◦ Does not work for things like Add where you want many impls depending on both Lhs and rhs
◦ Only case for normal generic is for overloading
• In Rust Generics are called “Type Parameters” because that’s sortof what they are. They are parameters to the function that are types, as opposed to objects. Rust actually handles them this way as opposed to just using them to generate an error if type don’t match. For example in Rust you can define an interface with a ‘new’ method on it. __ Notice that this method does not take a ‘self’ parameter. This means you can’t invoke it on an object. It is what Java would call a static method. However unlike Java you can still invoke this function from inside of a static method. For example __. Here we have a struct that implemented out trait _ and then later when we invoked the generic method _. It used the Type Parameter to invoke the function on the correct type. In this case that parameter did not come from any of the input arguments because there weren’t any. It was inferred from the return type which the compiler obtained by looking at the type of the value we were assigning the call to.
◦ https://bluejekyll.github.io/blog/rust/2017/08/06/type-parameters.html
• Conditional trait implementation
• Traits with methods contingent of a generic implementing a specific trait.
◦ IE: cell has take if T is default or get if T is copy. Or a wrapper implements order if the thing it wraps does.
• Syntax for ‘where’ vs ‘:’ (also ‘+’)
• Generics + Builders
• Self type
◦ Can return an newly created instance of a generic type. (collect on iterator)
• Generics and dyn
• static vs dynamic dispatch
◦ Dyn keyword
• Rust avoids generics hell
◦ Ownership and borrowing save the day
◦ https://doc.rust-lang.org/nomicon/subtyping.html</p>
<p>Rust generics look a lot like Javas. When declared on a type:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::marker::PhantomData;
pub struct LinkedList&lt;T&gt; {
  //...
# notImplemented : PhantomData&lt;T&gt;,
}
#}</code></pre></pre>
<p>When instantiated:</p>
<pre><code class="language-rust ignore">let connection : HashMap&lt;String, TcpStream&gt; = //...
</code></pre>
<p>When in a function signature:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;
pub fn lookup_emojis(characters : Vec&lt;&amp;str&gt;) -&gt; HashMap&lt;&amp;str, &amp;str&gt; {
  //...
# HashMap::new()
}
#}</code></pre></pre>
<a class="header" href="#type-inference" id="type-inference"><h2>Type Inference</h2></a>
<p>Rust also has some shortcuts to make things easier. For example a type can be declared like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn get_items() -&gt; Vec&lt;String&gt; {
  vec![&quot;Hello&quot;.to_string()] 
}
let toPrint : Vec&lt;_&gt; = get_items();
#}</code></pre></pre>
<p>Here the character ‘_’ tells the compiler “You figure out what's supposed to go here, I'm not going to bother to type it.”. This allows you to specify a type, while still allowing the generics to be infered. This works and can be used any place where the compiler has enough content to work out the generic value.</p>
<a class="header" href="#bounds" id="bounds"><h2>Bounds</h2></a>
<p>In java you might write a function that looks like this:</p>
<pre><code class="language-java">public static void &lt;T extends Comparable&lt;T&gt;&gt; sort(List&lt;T&gt; toSort) {
  //...
}
</code></pre>
<p>Here the <code>entends</code> keyword is used to specify that the geric type <code>T</code> is must satisfy the &quot;bounds&quot; of Implementing <code>Comparable&lt;T&gt;</code>.
The same function in Rust would look like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn sort&lt;T : Ord&gt;(toSort : &amp;mut Vec&lt;T&gt;) {
  //...
}
#}</code></pre></pre>
<p>The <code>:</code> takes the place of &quot;extends&quot;. <code>Ord</code> is a trait that allows items to be ordered similar to <code>Comparable</code> in Java.</p>
<p>You may be wondering, &quot;Why doesn't Ord take a generic parameter?&quot;. After all <code>Comparable</code> in Java needs one because the interface is not specific to one implementation, and needs to refer to the same type. This is due to another feature, the &quot;Self&quot; type.</p>
<p>If you'll recall, when we define a method on an object we write:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Foo;
impl Foo {
  fn bar(&amp;self) {
    //...
  }
}
#}</code></pre></pre>
<p>Where the 'self' variable is a way to pass the equivlent of &quot;this&quot; in Java. Well that's actually just shorthand for:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Foo;
impl Foo {
  fn bar(self : &amp;Self) {
    //...
  }
}
#}</code></pre></pre>
<p>Where <code>Self</code> is the type of the object. This isn't useful on an impl because you know the type, but on an interface it can be. For example you can define something like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait doubleable {
  fn double(self) -&gt; Self;
}
impl doubleable for i32 {
  fn double(self) -&gt; Self {
    self * 2
  }
}
//then this method can be invoked
assert_eq!(4, 2.double());
#}</code></pre></pre>
<p>So the <code>Self</code> type allows the trait to refer to whatever is implementing the interface without actually knowing what that is or having to have a generic itself.</p>
<a class="header" href="#features-unique-to-rust" id="features-unique-to-rust"><h2>Features unique to Rust</h2></a>
<p>Rust also has a few other features that help avoid so called &quot;generics hell&quot; that sometimes crops up in Java.</p>
<a class="header" href="#where-clauses" id="where-clauses"><h3>Where clauses</h3></a>
<p>A simple one is &quot;where&quot; clauses. Suppose you had an interface like this:</p>
<pre><code class="language-java">public &lt;T extends Comparable&lt;T&gt;, ProcT extends Serializable, Processor&lt;T&gt;&gt; byte[] serializeMaximumValue(List&lt;T&gt;, ProcT processor);
</code></pre>
<p>You could just do the same thing in Rust:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# //Normally Serialize is imported as: use serde::Serialize;
# trait Serialize {}
pub fn serialize_max_value&lt;T : Ord, ProcT : Proc&lt;T&gt; + Serialize&gt;(items : Vec&lt;T&gt;, processor : ProcT) -&gt; Vec&lt;u8&gt; {
  //...
# vec![]
}
# pub trait Proc&lt;T&gt; {
#  fn doSomething(item : T);
# }
#}</code></pre></pre>
<p>The problem with this in both Rust and java is the generics really get in the way and make the function signature hard to read. So it's easier to use the <code>where</code> keyword to move these bounds over to the right, so they can be wrapped onto the following lines:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# //Normally Serialize is imported as: use serde::Serialize;
# trait Serialize {}
pub fn serialize_max_value&lt;T, ProcT&gt;(items : Vec&lt;T&gt;, processor : ProcT) -&gt; Vec&lt;u8&gt; where
 T : Ord,
 ProcT : Proc&lt;T&gt; + Serialize {
  //...
# vec![]
}
# pub trait Proc&lt;T&gt; {
#  fn doSomething(item : T);
# }
#}</code></pre></pre>
<p>This is strictly equivlent, but hopefully easier to read.</p>
<a class="header" href="#impl-keyword" id="impl-keyword"><h3>Impl keyword</h3></a>
<p>In the case of a single trait/interface. In Java you might write __ where 'T extends’ is used to indicate there is some type T but the function doesn't care about the exact type of the object, provided it implements the specified interface. In Rust there is a shorthand for this using the 'impl’ keyword. __. This is most commonly used for return values for example __ specifies that this function is returning a _ but without providing the exact type. This is especially common when a function is returning a function. (Like a callback for example) __ here the function is specifying that it is returning a function with a particular signature but without specifying exactly which function it is returning. So you can think of impl as meaning “some implementation of this trait”. (It doesn't matter which) ‘impl’ only can refer to one trait. So if you need to use multiple, you'll have to use a where clause _ or an alias _.</p>
<p>Optimizer: I can actually make methods invoked on an ‘impl’ parameter a lot faster. So take advantage of that.</p>
<a class="header" href="#associated-types" id="associated-types"><h3>Associated Types</h3></a>
<p>Finally there is one feature that cuts down on the burdon of generics a lot: &quot;Associated types&quot;. Too often in Java when one component uses generics it forces other components interacting with it to be generic also even though they don't care about the type they are genericized over. For example if you had the classes:</p>
<pre><code class="language-java">abstract class Graph&lt;ItemT&gt; {
  private final List&lt;Node&lt;ItemT&gt;&gt; nodes;
  private final List&lt;Edge&lt;ItemT&gt;&gt; edges;
  //...
}
//Then you might define another class:
class Pathfinder&lt;GraphT extends Graph&lt;ItemT&gt;, ItemT&gt; {
//...
}

</code></pre>
<p>Here the class <code>Pathfiner</code> operates on a <code>Graph</code> and perfrom operations. The thing is, it does't actually care about <code>itemT</code>. For that matter neither does <code>Edge</code>. In both cases it is generic with respect to it only because it has to be, because it refers to <code>Graph</code>. What's move if Graph were to change, by adding a new generic parameter <code>Pathfiner</code> would brea. However this doesn't really make sense. It doesn't care about how graph is implemented, so it should be able to use <code>Graph</code>s generally being generic itself with respect to the implementation.</p>
<p>So in Rust instead of:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Graph&lt;ItemT&gt; {
  //...
}
#}</code></pre></pre>
<p>you would do this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Graph {
  type ItemT;
  //...
}
#}</code></pre></pre>
<p>Here <code>type</code> is a keyword. This is very similar to the first version but Pathfinder can now be declared without refering to the item type.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait Graph{} trait Node{}
trait Pathfinder {
  fn is_connected(start: Node, end: Node, graph: Graph) -&gt; bool;
  //...
}
#}</code></pre></pre>
<p>of course it is allowed to do so, it would look like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Graph {
  type T;
}
trait Node {
  type T;
}
trait PathFinder&lt;ItemT&gt; {
  fn is_connected(start: Node&lt;T=ItemT&gt;, end: Node&lt;T=ItemT&gt;, graph: Graph&lt;T=ItemT&gt;) -&gt; bool;
}
#}</code></pre></pre>
<p>In general the major difference between associated types and generics, is that for an associated type each implementation is tied to a speffic type. (For the language geeks this is called &quot;unicity&quot;.) For example If you were to define a concrete class <code>LinkedList</code> it should use generics because any sort of item should be able to go into one. However when defining a more general trait for example <code>Iterator</code> in that case it should use an associated type, because each implementation of iterator is only going to have one perticularl type associated with it. Usually this is the type of whatever collection is implementing it, which of course itself is likely a generic. The reason having a single associated type is useful for Iterator as opposed to being generic is that it allows callers to implement functions for it that don't depend on the type. For example we can implement additional traits that don't care about the type:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Countable {
    fn count(self) -&gt; i32;
}
impl&lt;T&gt; Countable for T where T:Iterator {
    fn count(self) -&gt; i32 {
        let mut counter = 0;
        for _ in self {
            counter += 1;
        }
        counter
    }
}
#}</code></pre></pre>
<p>Similarly traits with associated types can be put into a class or passed to a method that doesn't care about the implementation:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Storage {
  type Item;
  //...
  fn insert(&amp;self, item: Self::Item);
}
trait Processor&lt;T&gt; {
  type store : Storage&lt;Item=T&gt;;

  fn process_item(&amp;self, item: T);
}
struct Message{/*...*/}
struct MessageDispatcher {
  processor : Processor&lt;Message&gt;,
  //...
}
impl MessageDispatcher {
  fn fetch_next_message(&amp;self) -&gt; Message {
    //...
# Message{}
  }
  fn run(&amp;self) {
    loop {
      let message = self.fetch_next_message();
      self.processor.process_item(message);
    }
  }
}
#}</code></pre></pre>
<p>Here we have a <code>MessageDispatcher</code> which in a loop is sending messages to a <code>Processor</code> which is inturn inserting them into <code>Storage</code>. What's interesting about this is <code>MessageDispatcher</code> holds onto a <code>Processor</code> but it knows nothing about <code>Storage</code>. So even though <code>Processsor</code> is generic with respect to which <code>Storage</code> it uses, upstream classes don't know or care about this generalization.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="objects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="collections.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="objects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="collections.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
